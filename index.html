<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="分享，交流，学习，成长"><meta name="keywords" content=""><meta name="author" content="woyao"><meta name="copyright" content="woyao"><title>编程笔记 | woyao的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="author-info"><div class="author-info__avatar text-center"><img src="http://0.gravatar.com/avatar/0e261cd9b93afcd1c13b39d5ba7d6e2d"></div><div class="author-info__name text-center">woyao</div><div class="author-info__description text-center">分享，交流，学习，成长</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/ChenWoyao">follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">woyao的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/categories">目录</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/projects">项目实战</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/about">关于作者</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="site-info"><div id="site-title">woyao的博客</div><div id="site-sub-title">编程笔记</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/ChenWoyao" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/22/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">linux常用命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/linux/">linux</a></span><div class="content"><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这是一个linux常用命令大全</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+d</td>
<td>键盘输入结束或退出终端</td>
</tr>
<tr>
<td>Ctrl+s</td>
<td>暂停当前程序，暂停后按下任意键恢复运行</td>
</tr>
<tr>
<td>Ctrl+z</td>
<td>将当前程序放到后台运行，恢复到前台为命令fg</td>
</tr>
<tr>
<td>Ctrl+a</td>
<td>将光标移至输入行头，相当于Home键</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td>将光标移至输入行末，相当于End键</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td>删除从光标所在位置到行末</td>
</tr>
<tr>
<td>Ctrl+c</td>
<td>使用键来强行终止当前程序</td>
</tr>
<tr>
<td>Alt+Backspace</td>
<td>向前删除一个单词</td>
</tr>
<tr>
<td>Shift+PgUp</td>
<td>将终端显示向上滚动</td>
</tr>
<tr>
<td>Shift+PgDn</td>
<td>将终端显示向下滚动</td>
</tr>
</tbody></table>
<h2 id="功能手册（man"><a href="#功能手册（man" class="headerlink" title="功能手册（man)"></a>功能手册（man)</h2><p>可以使用功能手册查看一个命令的具体用法</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ man &lt;command_type&gt; &lt;command_name&gt;</span><br><span class="line"><span class="comment"># `man 1 ls` 这条命令可以查看`ls`有哪些用法</span></span><br><span class="line"><span class="comment"># comman_type 的选择如下</span></span><br><span class="line"><span class="comment"># 1	一般命令</span></span><br><span class="line"><span class="comment"># 2	系统调用</span></span><br><span class="line"><span class="comment"># 3	库函数，涵盖了C标准函数库</span></span><br><span class="line"><span class="comment"># 4	特殊文件（通常是/dev中的设备）和驱动程序</span></span><br><span class="line"><span class="comment"># 5	文件格式和约定</span></span><br><span class="line"><span class="comment"># 6	游戏和屏保</span></span><br><span class="line"><span class="comment"># 7	杂项</span></span><br><span class="line"><span class="comment"># 8	系统管理命令和守护进程</span></span><br></pre></td></tr></table></figure>

<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul>
<li>查看用户<br>具体的用法可以： <code>man 1 who</code> 打开功能手册<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前用户的两种写法</span></span><br><span class="line">who am i</span><br><span class="line">who mom likes</span><br></pre></td></tr></table></figure></li>
<li>创建用户<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新用户 woyao</span></span><br><span class="line">sudo adduser woyao</span><br><span class="line"><span class="comment"># 更新用户密码</span></span><br><span class="line">passwd woyao</span><br></pre></td></tr></table></figure></li>
<li>切换用户<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su -l woyao</span><br><span class="line">su woyao</span><br></pre></td></tr></table></figure></li>
<li>删除用户<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo userdel woyao -f</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><ul>
<li>创建<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line">touch 1.txt 2.txt</span><br><span class="line">touch love_&#123;1..10&#125;_woyao.txt</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir mydir</span><br><span class="line">mkdir -p user/woyao/name</span><br></pre></td></tr></table></figure></li>
<li>复制<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line">cp a.txt user/woyao/name</span><br><span class="line"><span class="comment"># 复制目录</span></span><br><span class="line"><span class="comment"># 将father内的子文件复制到family文件夹</span></span><br><span class="line">cp -r father family</span><br></pre></td></tr></table></figure></li>
<li>删除<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">rm a.txt</span><br><span class="line">rm -f a.txt</span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line">rm -rf father</span><br></pre></td></tr></table></figure></li>
<li>移动文件和文件重命名：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.txt 移动到 father</span></span><br><span class="line">mv a.txt father</span><br><span class="line"><span class="comment"># a.txt 重命名为b.txt</span></span><br><span class="line">mv a.txt b.txt</span><br><span class="line"><span class="comment"># 批量将后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件:</span></span><br><span class="line">rename <span class="string">&#x27;s/.txt/.c/&#x27;</span> *.txt</span><br><span class="line"><span class="comment"># 批量将文件，文件名和后缀改为大写:</span></span><br><span class="line">rename <span class="string">&#x27;y/a-z/A-Z/&#x27;</span> *.c</span><br></pre></td></tr></table></figure></li>
<li>查看<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt</span><br><span class="line"><span class="comment"># -n 参数显示行号</span></span><br><span class="line">cat -n a.txt</span><br><span class="line"><span class="comment"># 更多显示</span></span><br><span class="line">more a.txt</span><br><span class="line"><span class="comment"># 显示一部分</span></span><br><span class="line">less a.txt</span><br><span class="line"><span class="comment"># 文件的最后一行</span></span><br><span class="line">tail -n 1 /father/son/grandson/a.txt</span><br><span class="line"><span class="comment"># 文件的开始</span></span><br><span class="line">head b.txt</span><br><span class="line"><span class="comment"># 查看文件类型</span></span><br><span class="line">file a.txt</span><br><span class="line"><span class="comment"># 查看文件大小</span></span><br><span class="line">du -h -d 0 *.zip ~ | sort</span><br><span class="line">du -h woyao.zip</span><br></pre></td></tr></table></figure></li>
<li>搜索<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配所有文件名带a.txt的路径</span></span><br><span class="line">locate a.txt</span><br><span class="line"><span class="comment"># 在root目录下，查找有a.txt的路径</span></span><br><span class="line">find /root/ -name a.txt</span><br></pre></td></tr></table></figure></li>
<li>文件权限管理<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#x27;r&#x27;读4， &#x27;w&#x27;写2， &#x27;x&#x27;可执行1</span></span><br><span class="line"><span class="comment"># 600 等价于 -wr-----</span></span><br><span class="line"><span class="comment"># 644 等价于 -rw-r--r--</span></span><br><span class="line">chmod 600 a.txt</span><br><span class="line"><span class="comment"># 变更文件所有者</span></span><br><span class="line">sudo chown chen a.txt</span><br></pre></td></tr></table></figure></li>
<li>文件的压缩，解压，打包<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把woyao文件夹压缩成woyao.zip</span></span><br><span class="line"><span class="built_in">cd</span> /Desktop</span><br><span class="line">zip -r -q -o woyao.zip woyao</span><br><span class="line"><span class="comment"># 解压woyao.zip</span></span><br><span class="line">unzip woyao.zip</span><br><span class="line"><span class="comment"># 解压到指定目录</span></span><br><span class="line">unzip -q woyao.zip -d /Desktop/tomas</span><br><span class="line"><span class="comment"># 查看zip压缩包的内容</span></span><br><span class="line">unzip -l woyao.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把woyao文件夹压缩成woyao.tar</span></span><br><span class="line"><span class="built_in">cd</span> /Desktop</span><br><span class="line">tar -cf woyao.tar woyao</span><br><span class="line"><span class="comment"># 解压woyao.tar</span></span><br><span class="line">tar -xf woyao.tar</span><br><span class="line"><span class="comment"># 解压到指定目录</span></span><br><span class="line">tar -xf woyao.tar -C /Desktop/tomas</span><br><span class="line"><span class="comment"># 查看tar压缩包的内容</span></span><br><span class="line">tar -tf woyao.tar</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 declare 命令创建一个变量名为 tmp 的变量：</span></span><br><span class="line"><span class="built_in">declare</span> tmp</span><br><span class="line">tmp=woyao</span><br><span class="line"><span class="comment"># $符号用于表示引用一个变量的值，</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$tmp</span></span><br></pre></td></tr></table></figure>

<h2 id="骚操作-管道，重定向，…"><a href="#骚操作-管道，重定向，…" class="headerlink" title="骚操作(管道，重定向，…)"></a>骚操作(管道，重定向，…)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 家目录 ~</span></span><br><span class="line"><span class="built_in">echo</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重定向 &gt;, &gt;&gt;, tee</span></span><br><span class="line"><span class="comment"># 输出重定向覆盖模式(会覆盖原文件内容)</span></span><br><span class="line">cat b.gua &gt; c.gua</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello gua&quot;</span> &gt; c.gua</span><br><span class="line"><span class="comment"># 输出重定向的追加模式，不会覆盖文件内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello gua&quot;</span> &gt; c.gua</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道 |</span></span><br><span class="line"><span class="comment"># 管道符号把输出传给另一个程序作为输入</span></span><br><span class="line">cat c.gua | tee f.gua</span><br><span class="line"><span class="comment"># 显示历史密令中带有cat命令的字符串</span></span><br><span class="line"><span class="built_in">history</span> | grep cat</span><br><span class="line"></span><br><span class="line">tee: 把输入过来的数据输出到屏幕上并且重定向一份到文件</span><br><span class="line"><span class="built_in">history</span> | grep cat | tee new.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让程序在后台运行 &amp;</span></span><br><span class="line"><span class="comment"># 可以使运行的Firefox在终端后台运行</span></span><br><span class="line">firefox &amp;</span><br></pre></td></tr></table></figure>

<h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><ol>
<li>安装shadowsocks<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-pip</span><br><span class="line">pip install shadowsocks</span><br><span class="line">sudo apt install nano</span><br><span class="line">nano /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>
<blockquote>
<p>shadowsocks.json 的配置如下<br>{<br> “server”:”主机的Ip地址是”,<br> “server_port”:8388,<br> “local_address”: “127.0.0.1”,<br> “local_port”:1080,<br> “password”:”密码”,<br> “timeout”:300,#超时<br> “method”:”aes-256-cfb”,#加密方式<br> “fast_open”: false<br>}</p>
</blockquote>
</li>
<li>后台运行<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></li>
<li>服务器开机自动启动，必要性不大，因为服务器基本不重启<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/usr/bin/ssserver -c /etc/shadowsocks.json -d&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker教程系列七</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/docker/">docker</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/docker/">docker</a></span><div class="content"><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li>
</ul>
<h2 id="docker持续集成和部署"><a href="#docker持续集成和部署" class="headerlink" title="docker持续集成和部署"></a>docker持续集成和部署</h2><pre><code>现在是docker系列的最后一篇文章，这里直接实战吧。另外这一篇文章的代码没有测试。看一看就好，就不要实操了
主要是了解一套部署流程，因为实际工作中的流程操作用到的镜像都不是这些
</code></pre>
<h3 id="安装代码托管服务gogs"><a href="#安装代码托管服务gogs" class="headerlink" title="安装代码托管服务gogs"></a>安装代码托管服务gogs</h3><p>gogs 是一个类似github的代码托管服务, 它简单方便易于使用，我们使用它进行源代码管理.<br>将本目录下的docker-compose.yml 上传到服务器的 /root/gogs/docker-compose.yml<br>在服务器的 /root/gogs 中启动服务<code>docker-compose up -d</code>.<br>访问服务器的 3000 端口并初始化服务.</p>
<p>docker-compose.yml文件内容:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">    gogs:</span><br><span class="line">      image: gogs/gogs</span><br><span class="line">      restart: always</span><br><span class="line">      volumes:</span><br><span class="line">        <span class="comment"># 将 gogs 的数据文件存储在本机</span></span><br><span class="line">        - <span class="string">&quot;./data/gogs:/data&quot;</span></span><br><span class="line">      ports:</span><br><span class="line">        - <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">      environment:</span><br><span class="line">        - <span class="string">&quot;RUN_CROND=true&quot;</span></span><br><span class="line">      depends_on:</span><br><span class="line">        - postgres</span><br><span class="line">    postgres:</span><br><span class="line">      image: postgres:<span class="number">9.5</span></span><br><span class="line">      restart: always</span><br><span class="line">      volumes:</span><br><span class="line">        <span class="comment"># 将数据库文件存储到本机，以免丢失</span></span><br><span class="line">        - <span class="string">&quot;./data/postgresql:/var/lib/postgresql&quot;</span></span><br><span class="line">      ports:</span><br><span class="line">        - <span class="string">&quot;127.0.0.1:5432:5432&quot;</span></span><br><span class="line">      environment:</span><br><span class="line">        <span class="comment"># 数据库的连接信息</span></span><br><span class="line">        - <span class="string">&quot;POSTGRES_USER=admin&quot;</span></span><br><span class="line">        - <span class="string">&quot;POSTGRES_PASSWORD=123456&quot;</span></span><br><span class="line">        - <span class="string">&quot;POSTGRES_DB=gogs&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打开 <code>&lt;server ip&gt;:3000</code>，会看到如下<br><img src="http://121.5.231.10:3000/docker/gogs.png" alt="gogs配置图片"><br>修改数据库用户为:admin, 用户密码：123456. 数据库主机改为你的服务器ip<br>点击安装</p>
</blockquote>
<h1 id="安装持续集成服务器"><a href="#安装持续集成服务器" class="headerlink" title="安装持续集成服务器"></a>安装持续集成服务器</h1><p>drone 是一个轻便简介的持续继承服务器程序。持续继承服务器的功能是我们提交代码后自动拉取，自动运行预先配置好的测试<br>以确保及发现代码中的bug。在代码测试失败后，我们可以配置通过微信，短信，邮箱等方式接收通知以便于即使修复bug<br>在代码测试成功后，我们可以配置自动部署到线上生产环境，这个过程叫持续部署<br>将本目录下的docker-compose.yml 上传到服务器的 /root/drone/docker-compose.yml. 在服务器的 /root/drone 中启动服务<code>docker-compose up -d</code><br>由于docker-compose.yml 中配置了gogs, 所以现在可以访问服务器的8000端口并使用gogs的账号登录, 它会在登录后自动同步我们存放在gogs中的项目<br>文件内容如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  server:</span><br><span class="line">    image: drone/drone:0.8.6</span><br><span class="line">    ports:</span><br><span class="line">      - 8000:8000</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/drone:/var/lib/drone/</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      <span class="comment"># false 表示禁止注册</span></span><br><span class="line">      - DRONE_OPEN=<span class="literal">false</span></span><br><span class="line">      <span class="comment"># DRONE_ADMIN 配置的用户作为管理员</span></span><br><span class="line">      - DRONE_ADMIN=kuaibiancheng.com</span><br><span class="line">      <span class="comment"># 本机主机名</span></span><br><span class="line">      - DRONE_HOST=http://111.231.98.114</span><br><span class="line">      <span class="comment"># 随机输入一个字符串</span></span><br><span class="line">      - DRONE_SECRET=random_string_123</span><br><span class="line">      <span class="comment"># 使用 gogs 服务</span></span><br><span class="line">      - DRONE_GOGS=<span class="literal">true</span></span><br><span class="line">      <span class="comment"># gogs 的地址</span></span><br><span class="line">      - DRONE_GOGS_URL=http://111.231.98.114:3000</span><br><span class="line">      <span class="comment"># gogs 的 git 用户名</span></span><br><span class="line">      - DRONE_GOGS_GIT_USERNAME=kuaibiancheng.com</span><br><span class="line">      <span class="comment"># 密码</span></span><br><span class="line">      - DRONE_GOGS_GIT_PASSWORD=123</span><br><span class="line">      <span class="comment"># 私有模式</span></span><br><span class="line">      - DRONE_GOGS_PRIVATE_MODE=<span class="literal">true</span></span><br><span class="line">      <span class="comment"># 关闭 ssl 验证（我们没有配置 https 访问）</span></span><br><span class="line">      - DRONE_GOGS_SKIP_VERIFY=<span class="literal">true</span></span><br><span class="line">  agent:</span><br><span class="line">    image: drone/agent:0.8.6</span><br><span class="line">    <span class="built_in">command</span>: agent</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - server</span><br><span class="line">    volumes:</span><br><span class="line">      <span class="comment"># 这样才可以在容器中使用宿主机的 Docker 服务</span></span><br><span class="line">      - /var/run/docker.sock:/var/run/docker.sock</span><br><span class="line">    environment:</span><br><span class="line">      <span class="comment"># secret 和上面的 DRONE_SECRET 配置一致</span></span><br><span class="line">      - DRONE_SECRET=random_string_123</span><br><span class="line">      <span class="comment"># 上面的 server 服务的 9000 端口</span></span><br><span class="line">      - DRONE_SERVER=server:9000</span><br></pre></td></tr></table></figure>

<h1 id="drone-的使用"><a href="#drone-的使用" class="headerlink" title="drone 的使用"></a>drone 的使用</h1><p>首先在drone 的网页中打开对仓库的监听, 点开仓库的详细页面<br>drone 使用 .drone.yml 文件配置自动测试. 如果drone监听了一个仓库，仓库的根目录下有.drone.yml文件<br>drone就会使用.drone.yml 文件中定义的步骤测试代码并做一些自定义的操作<br>自定义的操作包括通知，自动部署等<br>详见.drone.yml 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline:</span><br><span class="line">  run:</span><br><span class="line">    image: python:3.7-alpine3.8</span><br><span class="line">    commands:</span><br><span class="line">      - python3 test.py</span><br><span class="line">  deploy:</span><br><span class="line">    image: appleboy&#x2F;drone-ssh</span><br><span class="line">    host: 115.159.181.16</span><br><span class="line">    username: ubuntu</span><br><span class="line">    secrets: [ ssh_key ]</span><br><span class="line">    port: 22</span><br><span class="line">    script:</span><br><span class="line">      - cd &#x2F;home&#x2F;ubuntu&#x2F;test</span><br><span class="line">      - git pull</span><br><span class="line">      - sudo sh reload.sh</span><br></pre></td></tr></table></figure>
<p>如果你有其他需求，下面是drone 的文档地址，请自行参阅<br><a target="_blank" rel="noopener" href="http://readme.drone.io/">http://readme.drone.io/</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li><a target="_blank" rel="noopener" href="http://plugins.drone.io/">插件</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.drone.io/pipeline-conditions/">让整个构建步骤只在某些分支发生变化的时候执行</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.drone.io/step-conditions/">让某一步动作在特定条件执行</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.drone.io/install-for-github/">让 Drone 支持 GitHub</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker教程系列六</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/docker/">docker</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/docker/">docker</a></span><div class="content"><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li>
</ul>
<h2 id="docker在服务器部署"><a href="#docker在服务器部署" class="headerlink" title="docker在服务器部署"></a>docker在服务器部署</h2><h3 id="前面的文章也写过关于服务器怎么部署的"><a href="#前面的文章也写过关于服务器怎么部署的" class="headerlink" title="前面的文章也写过关于服务器怎么部署的"></a>前面的文章也写过关于服务器怎么部署的</h3><p>详见: <a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></p>
<h3 id="下面是一个安装docker的sh配置脚本"><a href="#下面是一个安装docker的sh配置脚本" class="headerlink" title="下面是一个安装docker的sh配置脚本"></a>下面是一个安装docker的sh配置脚本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方安装指南 Ubuntu 版本</span></span><br><span class="line"><span class="comment"># https://docs.docker.com/install/linux/docker-ce/ubuntu</span></span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 的源是 https，所以安装这些软件用于支持 https 的 apt 仓库</span></span><br><span class="line">sudo apt install -y apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG key</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置官方 Docker 源</span></span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你想验证 Docker 安装好了，可以运行一个 hello-world 容器</span></span><br><span class="line"><span class="comment"># sudo docker run hello-world</span></span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">docker教程系列五</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/docker/">docker</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/docker/">docker</a></span><div class="content"><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li>
</ul>
<h2 id="给docker加上数据持久"><a href="#给docker加上数据持久" class="headerlink" title="给docker加上数据持久"></a>给docker加上数据持久</h2><h3 id="数据券介绍"><a href="#数据券介绍" class="headerlink" title="数据券介绍"></a>数据券介绍</h3><p>我们可以在概念上把docker看做虚拟机,当容器被删除的时候，容器里所有数据都会被删除,两个不同容器之间无法互通<br>可以把数据卷理解为虚拟机的虚拟磁盘，他是独立于容器的文件.在容器中他被挂载为一个目录的形式.<br>对于容器中的应用来说，数据卷是透明的，无法感知它的存在，他就是一个普通的文件夹<br>由于数据卷独立于容器而存在，因此删除容器的时候数据卷也不会受影响。数据卷有以下优点:</p>
<ol>
<li>多容器可以通过挂载同一个数据卷来共享数据</li>
<li>数据卷可以方便地备份，存储数据</li>
</ol>
<h3 id="数据卷的相关命令操作"><a href="#数据卷的相关命令操作" class="headerlink" title="数据卷的相关命令操作"></a>数据卷的相关命令操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个volume</span></span><br><span class="line">docker volume create testvolume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个数据卷</span></span><br><span class="line">docker volume rm testvolume</span><br></pre></td></tr></table></figure>

<h3 id="在容器中使用数据卷"><a href="#在容器中使用数据卷" class="headerlink" title="在容器中使用数据卷"></a>在容器中使用数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建数据卷</span></span><br><span class="line">docker volume create web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在运行容器的时候，使用参数--mount 如下</span></span><br><span class="line"><span class="comment"># 下面的参数含义是把数据卷(web)挂载到容器的/volume目录上面</span></span><br><span class="line"><span class="comment"># 这里的webimage 镜像可以用我前面文章写得Dockerfile生成</span></span><br><span class="line"><span class="comment"># 这样就运行了一个带有数据卷的容器，这个容器的/volume目录中的内容在容器被删除之后仍然存在.</span></span><br><span class="line"><span class="comment"># 因为它实际上是存在Docker数据卷中。</span></span><br><span class="line">docker run -d --name demovolume --mount <span class="built_in">source</span>=web,target=/volume webimage</span><br></pre></td></tr></table></figure>

<h3 id="以下例子用于演示数据卷保存数据的特性"><a href="#以下例子用于演示数据卷保存数据的特性" class="headerlink" title="以下例子用于演示数据卷保存数据的特性"></a>以下例子用于演示数据卷保存数据的特性</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行命令在容器的 /b.txt 写入时间内容并查看</span></span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;date &gt; /b.txt&#x27;</span></span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;cat /b.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器后重新启动一个同名容器在查看，之前容器的内容已经没有了</span></span><br><span class="line">docker rm -f demovolume</span><br><span class="line">docker run -d --name demovolume --mount <span class="built_in">source</span>=web,target=/volume webimage</span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;cat /b.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存在数据卷上的文件，即使容器被删除仍然存在</span></span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;date &gt; /volume/b.txt&#x27;</span></span><br><span class="line">docker rm -f demovolume</span><br><span class="line">docker run -d --name demovolume --mount <span class="built_in">source</span>=web,target=/volume webimage</span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;cat /volume/b.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="共享目录"><a href="#共享目录" class="headerlink" title="共享目录"></a>共享目录</h3><p>除了挂载数据卷以外，docker还可以挂载共享目录（这一点和虚拟机一样），共享目录的优势是使用方便，易于理解，可以在某些场景下方便使用<br>（比如开发是在宿主机中修改源代码docker中实时生效省却build镜像的过程）<br>下面用一个具体的例子来演示挂载共享目录的用法:</p>
<ol>
<li>在当前目录下创建index.html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>volume<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个在宿主机的 index.html 文件。<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>打开终端输入<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令会从nginx镜像运行一个名为nginx1的容器</span></span><br><span class="line"><span class="comment"># 并且设置了8080：80的端口映射</span></span><br><span class="line"><span class="comment"># --mount 参数的 type=bind 表明要挂载的共享目录</span></span><br><span class="line"><span class="comment"># 把宿主机的当前目录映射为容器的 /usr/share/nginx/html (这是nginx容器的静态页面文件存放路径)</span></span><br><span class="line"><span class="comment"># 这样在宿主机中访问localhost:8080会自动访问宿主机当前目录下的index.html文件 （这是nginx的默认静态文件首页）</span></span><br><span class="line"></span><br><span class="line">docker run -p 8080:80 --name nginx1 --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>,target=/usr/share/nginx/html/ nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要注意的是source参数必须使用绝对路径</span></span><br><span class="line"><span class="comment"># 所以这里使用&quot;$&#123;PWD&#125;&quot;的方式来在 Mac/Linux/Windows 中获取当前目录路径</span></span><br><span class="line"><span class="comment"># 这是一个可以在多平台通用的获取当前目录路径的方法 (windows下必须使用PowerShell)</span></span><br><span class="line"><span class="comment"># 加引号是因为路径中可能含有空格等特殊符号，如果路径有空格而未加引号，会产生错误</span></span><br></pre></td></tr></table></figure></li>
<li>打开浏览器输入: localhost:8080</li>
</ol>
<h3 id="其他挂载模式"><a href="#其他挂载模式" class="headerlink" title="其他挂载模式"></a>其他挂载模式</h3><p>除了挂载整个目录，还可以单独挂载一个文件。 如果要挂载单个文件，一定要要保证宿主机文件存在，否则整个路径会被认为是一个目录挂载</p>
<ol>
<li>创建index.html, 随便写点东西</li>
<li>打开终端输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8081:80 \</span><br><span class="line">    --name nginx2 \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>/index.html,target=/usr/share/nginx/html/test.html \</span><br><span class="line">    nginx</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  这时候我们访问http://localhost:8081 返回的是nginx的默认首页</span></span><br><span class="line">    <span class="comment">#  而访问http:/localhost:8081/test.html 返回的是挂载的单个文件</span></span><br></pre></td></tr></table></figure>
注意：可以创建多文件挂载<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8082:80 \</span><br><span class="line">    --name nginx3 \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>/index.html,target=/usr/share/nginx/test.html/ \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>/test.html,target=/usr/share/nginx/test2.html/ \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">docker教程系列四</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/docker/">docker</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/docker/">docker</a></span><div class="content"><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li>
</ul>
<h2 id="使用compose部署多容器应用"><a href="#使用compose部署多容器应用" class="headerlink" title="使用compose部署多容器应用"></a>使用compose部署多容器应用</h2><h3 id="compose介绍"><a href="#compose介绍" class="headerlink" title="compose介绍"></a>compose介绍</h3><pre><code>`docker`被设计为程序容器，所以每一个容器只应该运行一个程序。但是在实际的项目中会有需要多个程序相互配合一起运行的情况。比如web程序通常包含app, 数据库，nginx，redis等。这些程序各自的容器需要协同工作，并且需要能够互相访问网络。比如app需要连接数据库，nginx需要能访问app才能给他做反向代理。由于docker容器是一个隔离的环境，正常情况下容器与容器之间是无法互相访问的。为了应对复杂工程的需要，我们可以手动配置多容器之间的虚拟网络，文件互访等功能来实现容器互相访问。但docker官方推出了compose程序用于配置管理多容器的运行。`compose`通过一个单独的`docker-compose.yml`配置文件来管理一组容器。
</code></pre>
<h3 id="compose安装"><a href="#compose安装" class="headerlink" title="compose安装"></a>compose安装</h3><pre><code>在`docker for mac`, `docker for windows`中`docker-compose`是自带的。
linux服务器上，需要单独安装，方法如下：
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你应该检查如下的链接用最新的版本: https://github.com/docker/compose/releases</span></span><br><span class="line"><span class="comment"># 这是linux服务器的安装方法：</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose</span><br><span class="line"><span class="comment"># 给docker-compose 增加修改的权限</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment"># 由于官方的Compose程序在github速度比较慢，所以我们也可以用国内的地址安装</span></span><br><span class="line">curl -L https://get.doocloud.io/docker/compose/releases/download/1.22.0/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment"># 其他系统安装方法见官方指南： https://docs.docker.com/compose/install/</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="compose使用"><a href="#compose使用" class="headerlink" title="compose使用"></a>compose使用</h3><pre><code>`compose`把一组容器作为一个项目来进行管理，并且会设置好容器间互联的内部网络
每一个容器在compose中被称之为服务（service). 如同docker使用dockerfile来描述一个镜像的构建一样.
`compose`使用一个`docker-compose.yml`文件来描述`compose`项目的构建. 请注意，如果你对yml格式不太熟悉，那么可能需要查阅一下yml格式的相关信息. 下面是关于`compose`的相关命令操作

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line">docker-compose up</span><br><span class="line"><span class="comment"># 重新运行</span></span><br><span class="line">docker-compose up --build</span><br><span class="line"><span class="comment"># 用-d参数让项目后台运行</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用stop暂停容器的运行</span></span><br><span class="line">docker-compose stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用down关闭并且删除项目的所有容器</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目运行起来后，用ctrl+c终止项目</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="实例操作1-compose的使用"><a href="#实例操作1-compose的使用" class="headerlink" title="实例操作1: compose的使用"></a>实例操作1: compose的使用</h3><ol>
<li><p>在当前目录下创建compose1文件夹</p>
</li>
<li><p>进入compose1, 创建<code>app.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># redisdemo 是 compose 中创建的主机名，由 docker-compose.yml 中指定</span></span><br><span class="line"><span class="comment"># compose 会给每个容器提供 DNS 服务保证容器间互相访问</span></span><br><span class="line">redis = Redis(host=<span class="string">&#x27;redisdemo&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    count = redis.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;views &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>进入compose1, 创建Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install flask redis</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
<li><p>进入compose1, 创建docker-compose.yml</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示这是 compose 配置文件的版本</span></span><br><span class="line">version: <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="comment"># 每个服务都是一个 Docker 容器</span></span><br><span class="line"><span class="comment"># 所以必须用 image 指定服务的镜像名或者从 Dockerfile 中 build 镜像</span></span><br><span class="line">services:</span><br><span class="line">    pyweb:</span><br><span class="line">    <span class="comment"># build 指定了 Dockerfile 所在的路径。docker build -t pyimage .</span></span><br><span class="line">    build: .</span><br><span class="line">    <span class="comment"># ports 指定暴露的端口，9000 是宿主机，5000 是容器</span></span><br><span class="line">    <span class="comment"># 可以指定多个暴露端口</span></span><br><span class="line">    ports:</span><br><span class="line">        - <span class="string">&quot;9000:5000&quot;</span></span><br><span class="line">    <span class="comment"># depends_on 设定了依赖，这里 redisdemo 会先于 pyweb 启动</span></span><br><span class="line">    <span class="comment"># 但是如果 redisdemo 启动时间长于 pyweb</span></span><br><span class="line">    <span class="comment"># 那么 pyweb 运行的时候 redisdemo 未必可用</span></span><br><span class="line">    depends_on:</span><br><span class="line">        - redisdemo</span><br><span class="line"></span><br><span class="line">    redisdemo:</span><br><span class="line">        <span class="comment"># 每个服务必须用 image 指定镜像名或者从 Dockerfile 中 build</span></span><br><span class="line">        <span class="comment"># 这里用 image 指定镜像，redis:alpine 是 redis 项目的官方 Docker 镜像</span></span><br><span class="line">        image: <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动项目,打开终端</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure></li>
<li><p>打开浏览器输入: localhost:9000/. 不断刷新浏览器你会发现redis记录了该页面访问的次数变化。</p>
</li>
<li><p>输入<code>docker-compose down</code>关闭应用</p>
</li>
</ol>
<h3 id="实例操作2-使用共享券"><a href="#实例操作2-使用共享券" class="headerlink" title="实例操作2: 使用共享券"></a>实例操作2: 使用共享券</h3><p>在开发过程中，如果每次修改<code>app.py</code>文件都要重新build再启动容器会比较繁琐<br>我们可以用共享券的方式来直接修改程序文件,这样可以大大提高开发效率.<br>上面的实例操作一，每次修改compose1文件夹下的文件都需要输入<code>docker-compose up --build</code>重启启动应用。现在使用了共享券(volumes)，容器中<code>/code</code>下的文件都来自宿主机的当前目录。<br>.</p>
<ol>
<li><p>进入目录compose1, 修改docker-compose.yml文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改pyweb容器的配置</span></span><br><span class="line">pyweb:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">        - <span class="string">&quot;9000:5000&quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">        - redisdemo</span><br><span class="line">    volumes:</span><br><span class="line">        - .:/code</span><br></pre></td></tr></table></figure></li>
<li><p>进入目录compose1, 修改Dockerfile文件</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除 COPY 命令</span><br><span class="line"><span class="deletion">- COPY app.py /code/app.py</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>打开终端, 启动项目</p>
</li>
<li><p>打开浏览器输入: localhost:9000/. 不断刷新浏览器你会发现redis记录了该页面访问的次数变化。这时候修改<code>app.py</code>不需要重新启动容器</p>
</li>
<li><p>输入<code>docker-compose down</code>关闭应用</p>
</li>
</ol>
<h3 id="实例操作3-在服务器中使用docker-compose启动项目"><a href="#实例操作3-在服务器中使用docker-compose启动项目" class="headerlink" title="实例操作3: 在服务器中使用docker-compose启动项目"></a>实例操作3: 在服务器中使用docker-compose启动项目</h3><ol>
<li>进入compose1文件夹，创建upload-and-run.sh文件.<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传项目到服务器</span></span><br><span class="line"><span class="comment"># 比如`scp -r . root@xxxxx:/local/woyao`</span></span><br><span class="line">scp -r . &lt;username&gt;@&lt;server host&gt;:&lt;server path&gt;</span><br><span class="line"><span class="comment"># 在服务器重启项目</span></span><br><span class="line"><span class="comment"># 登录服务器</span></span><br><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line">ssh &lt;username&gt;@&lt;server host&gt; <span class="string">&#x27;sh &lt;server path&gt;/run.sh&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>进入compose1文件夹，创建run.sh文件.<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;server path&gt;</span><br><span class="line">sudo docker-compose down</span><br><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure></li>
<li>在本地执行<code>sh upload-and-run.sh</code></li>
<li>打开浏览器输入: <code>&lt;server ip&gt;:9000</code>，就可以访问了。</li>
<li>注意事项:</li>
</ol>
<ul>
<li>可能服务器docker服务会关闭，在服务器输入<code>systemctl start docker</code>重启docker。</li>
<li>服务器防火墙原因，只放开了80,443端口</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">docker教程系列三</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/docker/">docker</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/docker/">docker</a></span><div class="content"><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li>
</ul>
<h2 id="使用dockerfile打包镜像"><a href="#使用dockerfile打包镜像" class="headerlink" title="使用dockerfile打包镜像"></a>使用dockerfile打包镜像</h2><pre><code>上一篇文章，我们实现了在一个基础的ubuntu镜像中运行我们的程序。但是运行程序的过程手动执行行命令式一件很麻烦的事情。
接下来我们又把执行的命令协程了脚本，提高了一定的效率。但是如果要启动多个容器，我们的自制脚本每次都要重新安装配置一次这个过程是很耗时的。有没有更简单的办法呢？有的下面介绍dockerfile.
</code></pre>
<h3 id="dockerfile介绍"><a href="#dockerfile介绍" class="headerlink" title="dockerfile介绍"></a>dockerfile介绍</h3><pre><code>docker 可以让我们自行编写配置文件（名为Dockerfile）来构建一个镜像,这样我们就可以轻松地从自定义构建的镜像中启动多个容器, 所以在实际使用中，我们会把整个程序打包成一个新的docker. 也就是说把所得配置操作，启动运行操作都写到自己的自定义的镜像配置文件中，这样生成的镜像实例(容器)只管运行就好了。不需要额外配置
</code></pre>
<h3 id="关于镜像相关的命令"><a href="#关于镜像相关的命令" class="headerlink" title="关于镜像相关的命令"></a>关于镜像相关的命令</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用下面的命令查看本机存储的镜像 (包括下载的和构建的)</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker image rm &lt;webimage&gt;</span><br><span class="line">or</span><br><span class="line">docker rmi -f &lt;webimage&gt;</span><br><span class="line"><span class="comment"># 构建镜像, -t表示镜像的名字和标签，.代表当前的工作目录</span></span><br><span class="line">docker build -t webimage .</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="使用dockerfile构建的镜像启动容器"><a href="#使用dockerfile构建的镜像启动容器" class="headerlink" title="使用dockerfile构建的镜像启动容器"></a>使用dockerfile构建的镜像启动容器</h3><pre><code>下面是对dockerfile文件中内容的解释

<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在dockerfile文件中 #是注释</span></span><br><span class="line"><span class="comment"># FROM用于指定构建镜像使用的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN 用于在构建镜像的时候在镜像中执行命令</span></span><br><span class="line"><span class="comment"># 这里我们安装python3 和 flask web 框架</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip2 insatll flask</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY 相当于命令的 docker cp</span></span><br><span class="line"><span class="comment"># 把本机当前目录下的app.py文件拷贝到镜像的 /code/app.py</span></span><br><span class="line"><span class="comment"># 和docker cp 不同的是， COPY 会自动创建镜像中不存在的目录, 比如/code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR 用于指定从镜像启动的容器内的工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 用于指定容器运行后要执行的命令和参数列表</span></span><br><span class="line"><span class="comment"># 这样从本镜像启动容器后会自动执行 python3 app.py 这个命令</span></span><br><span class="line"><span class="comment"># 由于我们已经用WORDKDIR指定了容器的工作目录</span></span><br><span class="line"><span class="comment"># 所以以下的命令都是在 /code 下执行的</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><ol>
<li>当前目录下创建app.py文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from Dockerfile&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
<li>当前目录下创建Dockerfile文件<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install flask</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为使用了docker build -t webimage .</span></span><br><span class="line"><span class="comment"># 指明了镜像的工作目录是当前目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
<li>打开终端输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令中参数 -t webimage 指定了镜像的名字为 webimage</span></span><br><span class="line"><span class="comment"># 这个名字可以用于在之后从镜像启动容器</span></span><br><span class="line"><span class="comment"># 最后那个 . 用来指定构建镜像时候的工作目录为本机当前目录</span></span><br><span class="line">docker build -t webimage .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用下面的命令查看本机存储的镜像 (包括下载的和构建的)</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -p 8000:5000 --name demo webimage</span><br></pre></td></tr></table></figure></li>
<li>在浏览器输入: localhost:8000</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">docker教程系列二</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/docker/">docker</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/docker/">docker</a></span><div class="content"><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li>
</ul>
<h2 id="手动从镜像运行一个容器"><a href="#手动从镜像运行一个容器" class="headerlink" title="手动从镜像运行一个容器"></a>手动从镜像运行一个容器</h2><h3 id="手动启动一个容器"><a href="#手动启动一个容器" class="headerlink" title="手动启动一个容器"></a>手动启动一个容器</h3><pre><code>手动在本地电脑的docker容器中运行一个web应用

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令启动一个docker容器</span></span><br><span class="line">docker run -d -t -p 8000:5000 --name demo ubuntu:18.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这条命令的解释</span></span><br><span class="line">-d 的意思是让容器在后台运行</span><br><span class="line">-t 极少能用到，用于让一个空白的Ubuntu镜像在后台运行</span><br><span class="line">-p 用于指定端口映射，表示在本机访问8000会被自动转到容器中5000端口</span><br><span class="line">   必须保证本机没有其他应用程序占用了8000端口，否则这里会失败</span><br><span class="line">--name demo 制定了容器的名字是demo</span><br><span class="line">ubuntu:18.04 是启动容器时用的镜像名, docker会自动从镜像服务器去下载这个镜像</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="启动容器常见的问题"><a href="#启动容器常见的问题" class="headerlink" title="启动容器常见的问题"></a>启动容器常见的问题</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个端口为3456的进程</span></span><br><span class="line">docker run -t -d -p 3456:5000 --name <span class="built_in">test</span> ubuntu:18.04</span><br><span class="line"><span class="comment"># 报错1，端口被占用，删除test容器来不安比3456端口的占用</span></span><br><span class="line">docker rm -f <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 报错2，名字已存在, 那么改名字, 也可以用上面的删除容器命令</span></span><br><span class="line">docker run -t -d -p 3456:5000 --name test1 ubuntu:18.04</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="关于容器相关的命令"><a href="#关于容器相关的命令" class="headerlink" title="关于容器相关的命令"></a>关于容器相关的命令</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最新指定数量的容器的状态</span></span><br><span class="line">docker ps -n 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止容器</span></span><br><span class="line">docker stop &lt;container id&gt;/&lt;container name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对终止运行的容器重启, 容器id通过docker ps查询</span></span><br><span class="line">docker start &lt;container id&gt;/&lt;container name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志</span></span><br><span class="line">docker logs &lt;container id&gt;/&lt;container name</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="在容器中安装必备软件"><a href="#在容器中安装必备软件" class="headerlink" title="在容器中安装必备软件"></a>在容器中安装必备软件</h3><pre><code>启动容器以后，说明了运行了一个镜像实例，比如ubuntu:18.04镜像生成的test容器。这个容器目前有了ubuntu操作系统的文件管理功能，内存管理功能，进程调度等功能。现在还需要拥有python3, pip 环境, apt工具包。

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -t -p 8000:5000 --name unbuntu:18.04</span><br><span class="line"><span class="comment"># 下载apt工具包</span></span><br><span class="line">docker <span class="built_in">exec</span> demo apt update</span><br><span class="line">docker <span class="built_in">exec</span> apt -y install python3 python3-pip</span><br><span class="line"><span class="comment"># 安装flask库</span></span><br><span class="line">docker <span class="built_in">exec</span> demo pip3 install flask</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="在容器中运行程序"><a href="#在容器中运行程序" class="headerlink" title="在容器中运行程序"></a>在容器中运行程序</h3><pre><code>上面说过，使用docker的目的就是软件应用带环境安装。现在环境好了，需要运行软件应用

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo 容器中创建/code目录</span></span><br><span class="line">docker <span class="built_in">exec</span> demo mkdir /code</span><br><span class="line"><span class="comment"># cp参数把当前文件夹的a.py拷贝到demo容器的/code/a.py</span></span><br><span class="line">docker cp a.py demo:/code/a.py</span><br><span class="line"><span class="comment"># 运行demo容器中的a.py</span></span><br><span class="line">docker <span class="built_in">exec</span> demo python3 /code/a.py</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="用脚本的方式配置容器，然后运行脚本配置并开启新容器"><a href="#用脚本的方式配置容器，然后运行脚本配置并开启新容器" class="headerlink" title="用脚本的方式配置容器，然后运行脚本配置并开启新容器"></a>用脚本的方式配置容器，然后运行脚本配置并开启新容器</h3><pre><code>之前的一系列命令有些繁琐, 其实更好的方式是在宿主机写脚本，然后cp到docker容器中直接运行.
具体操作看实例操作
</code></pre>
<h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><ol>
<li>在当前目录下创建a.py文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from Docker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认端口5000</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
<li>在当前目录下创建install.sh文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install.sh</span></span><br><span class="line">apt update</span><br><span class="line">apt -y install python3 python3-pip</span><br><span class="line">pip3 install flask</span><br></pre></td></tr></table></figure></li>
<li>在当前目录下创建run.sh文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run.sh</span></span><br><span class="line"><span class="built_in">cd</span> /code</span><br><span class="line">python3 a.py</span><br></pre></td></tr></table></figure></li>
<li>打开终端，输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -t -p 8000:5000 --name unbuntu:18.04</span><br><span class="line"><span class="comment"># demo 容器中创建/code目录</span></span><br><span class="line">docker <span class="built_in">exec</span> demo mkdir /code</span><br><span class="line">docker cp install.sh <span class="string">&quot;demo:/code/install.sh&quot;</span></span><br><span class="line">docker cp run.sh <span class="string">&quot;demo:/code/run.sh&quot;</span></span><br><span class="line">docker cp a.py <span class="string">&quot;demo:/code/a.py&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> demo bash /code/install.sh</span><br><span class="line">docker <span class="built_in">exec</span> demo bash /code/run.sh</span><br></pre></td></tr></table></figure></li>
<li>打开浏览器输入：localhost:8000/</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker教程系列一</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/docker/">docker</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/docker/">docker</a></span><div class="content"><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li>
<li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li>
</ul>
<h2 id="docker概念篇"><a href="#docker概念篇" class="headerlink" title="docker概念篇"></a>docker概念篇</h2><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>官方解释：通过对应用的封装、分发、部署、运行 生命周期进行管理，达到应用组件级别的“一次封装，到处运行”。<br>大白话：在以前一个软件应用在不同机器上运行，都需要对操作系统设置，各种库和组装单独下载，配置好环境变量。才能运行的起来。这种模式很不好，首先老旧的模块和当前环境不兼容就”gg思密达了”. 于是就有了软件应用带环境安装的解决方案。然后就出现了<code>虚拟机的方案</code>。但是虚拟机<strong>资源占用多</strong>，<strong>冗余步骤多</strong>，<strong>启动慢</strong>。既然虚拟机方案不好，那么革命的变更就出现了<code>linux容器方案</code>。关于<code>linux容器方案</code>的介绍:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux 容器不是模拟一个完整的操作系统，而是对进程(一个正在运行的应用)进行隔离。</span><br><span class="line">在正常进程的外面套了一个容器。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。另外容器也属于一个进程。</span><br></pre></td></tr></table></figure>
<p>具有<strong>启动快</strong>，<strong>占用资源少</strong>，<strong>体积小</strong>。docker属于<code>linux容器</code>的一种封装。是目前最流行的<code>linux容器方案</code>。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="centOs系统"><a href="#centOs系统" class="headerlink" title="centOs系统:"></a>centOs系统:</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 添加docker稳定版本的yum软件源</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">// 安装docker</span><br><span class="line">sudo yum install -y docker-ce</span><br><span class="line"></span><br><span class="line">// 确定docker服务启动正常</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h4 id="macOs系统"><a href="#macOs系统" class="headerlink" title="macOs系统:"></a>macOs系统:</h4><p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/macos-docker-install.html">参考macos系统docker的安装</a></p>
<h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p><a target="_blank" rel="noopener" href="https://hub.docker.com/editions/community/docker-ce-desktop-mac">docker安装官网</a></p>
<h3 id="docker镜像-docker-image"><a href="#docker镜像-docker-image" class="headerlink" title="docker镜像(docker image)"></a>docker镜像(docker image)</h3><p>Docker把应用程序及其依赖，打包在image文件里面。docker image 一个只读的模板, 创建Docker容器的基础。镜像相当于光盘，光盘里存储的数据是只读的，不会被更改</p>
<h3 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h3><p>容器是从镜像创建的应用运行实例, 一个镜像可以生成多个容器，每个容器之间，容器与宿主机之间都是相互隔离的，容器可以快速方便的运行，也可以方便的删除</p>
<h3 id="docker的优势"><a href="#docker的优势" class="headerlink" title="docker的优势"></a>docker的优势</h3><ol>
<li><p>同一环境，标准化部署 ubntu centos 等服务器的安装运行环境是不一样的<br>要使用某些新版的软件需要自行编译，非常繁琐</p>
</li>
<li><p>解决复杂的依赖问题<br>比如两个微服务 2个不同的依赖互相冲突</p>
</li>
<li><p>隔离应用的运行环境<br>比如redis获取服务器权限的漏洞</p>
</li>
<li><p>轻量级的虚拟环境，相比虚拟机而言开销小速度快</p>
</li>
<li><p>统一的服务管理<br> 不同的服务有不同的管理工具和方式<br> 如果使用了docker则统一用docker管理</p>
</li>
<li><p>dockerhub 上有许多高价值的镜像可以直接使用</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/16/react%E7%9A%84hooks%E6%95%99%E7%A8%8B/">react的hooks教程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/">前端笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/react/">react</a></span><div class="content"><h2 id="这是一篇react的hooks教程"><a href="#这是一篇react的hooks教程" class="headerlink" title="这是一篇react的hooks教程"></a>这是一篇react的hooks教程</h2><p>另外欢迎大家访问<a href="https://chenwoyao.github.io/categories/">我的博客</a></p>
<h2 id="react-hooks-与-class-Component-的区别"><a href="#react-hooks-与-class-Component-的区别" class="headerlink" title="react hooks 与 class Component 的区别"></a><code>react hooks</code> 与 <code>class Component</code> 的区别</h2><ul>
<li>写法更加简洁，不再需要写冗长的生命周期函数</li>
<li><code>class Componet hoc</code> 的阅读让人看起来不易理解, 在组件之间复用状态逻辑很难.</li>
</ul>
<h2 id="hooks-使用规则"><a href="#hooks-使用规则" class="headerlink" title="hooks 使用规则"></a><code>hooks</code> 使用规则</h2><ul>
<li>只能在<strong>函数最外层</strong>调用 Hook。不要在循环、条件判断或者子函数中调用。</li>
<li>只能在<strong>React的函数组件中调用</strong>Hook。不要在其他JavaScript函数中调用。除了自定义的hook以外</li>
</ul>
<h2 id="react-hooks-常见的api使用"><a href="#react-hooks-常见的api使用" class="headerlink" title="react hooks 常见的api使用"></a><code>react hooks</code> 常见的api使用</h2><h3 id="useState-用法"><a href="#useState-用法" class="headerlink" title="useState 用法"></a><code>useState</code> 用法</h3><blockquote>
<p>identity: <code>const [state, setState] = useState(initialState)</code></p>
</blockquote>
<p><code>useState</code>的作用是在react函数组件中添加state的hook。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line">function Count() &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - count &lt;&#x3D;&gt; this.state.count, setCount &lt;&#x3D;&gt; this.setState</span><br><span class="line">        - setCount 支持两种写法 setCount(count + 1) or setCount(preState &#x3D;&gt; preState + 1)</span><br><span class="line">        第一种写法是一种异步机制，会将短时间内的多个setCount合并成一个方法，第二种写法是为了不使用第一种的合并机制。</span><br><span class="line">    *&#x2F;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    return &lt;div onClick&#x3D;&#123;setCount(pre &#x3D;&gt; pre + 1)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="useEffect-用法"><a href="#useEffect-用法" class="headerlink" title="useEffect 用法"></a><code>useEffect</code> 用法</h3><blockquote>
<p>identity: <code>useEffect(callBack:clearCallBack, [deps])</code></p>
</blockquote>
<p><code>useEffect</code>的作用是在函数组件中执行副作用操作, 等价于在ComponetDidMount，ComponentDidUpdate, ComponentWillUnmount 三个函数的组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - useEffect接受一个callBack参数和数组参数</span><br><span class="line">        - 数组中的值作为依赖，数组中的值发生变化的时候，callBack会重新调用。等价于ComponentDidUpdate</span><br><span class="line">        - callBack可以return一个clearCallBack,在组件卸载的时候调用clearCallBack。等价于ComponentWillUnmount</span><br><span class="line">        - useEffect默认会在render流程执行完以后，在调用callBack。等价于ComponetDidMount</span><br><span class="line">    *&#x2F;</span><br><span class="line">    const [isonline, setIsOnline] &#x3D; useState(false);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [isonline])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useContext-用法"><a href="#useContext-用法" class="headerlink" title="useContext 用法"></a><code>useContext</code> 用法</h3><p><code>useContext</code>的作用是接受一个context对象，并返回该context的当前值。主要用于深层级的组件通讯。需要和React.createContext配合使用<br>context的值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt;的 value prop决定。另外value的值更新会引起调用了uesContext的组件重新渲染。</p>
<blockquote>
<p>注意调用useContext的组件即使用了React.memo进行声明，也会重新渲染。因此需要使用<a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/15156">memoization</a>来进行优化.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext, Children, useContext, useMemo &#125; from &#39;react&#39;</span><br><span class="line">const GlobalContext &#x3D; React.createContext()</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">    const data &#x3D; useContext(GlobalContext)</span><br><span class="line">    &#x2F;&#x2F; memoization 写法</span><br><span class="line">    return useMemo(() &#x3D;&gt; &#123;</span><br><span class="line">        return &lt;div&gt;&#123;data.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;, [data.name])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Parent() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;Parent&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;GlobalContext.Provider value&#x3D;&#123;&#123;name: &#39;woyao&#39;&#125;&#125;&gt;</span><br><span class="line">                &lt;Child &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;GlobalContext.Provider&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="useRef-用法"><a href="#useRef-用法" class="headerlink" title="useRef 用法"></a><code>useRef</code> 用法</h3><p><code>useRef</code>返回一个可变的ref对象，<code>ref.current</code>在组件内是一个全局常量。相当于在组件外写了一个全局常量。也就是说每次重新渲染函数组件时，返回的ref对象都是同一个。 常用于<em>访问Dom</em>,<em>当做全局变量</em>。</p>
<blockquote>
<p><em>访问 Dom</em></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef &#125; from &#39;react&#39;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    const inputElement &#x3D; useRef(null)</span><br><span class="line">    const btnClick &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class="line">        inputElement.current.focus()</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &lt;input ref&#x3D;&#123;inputElement&#125; &#x2F;&gt;</span><br><span class="line">            &lt;button ref&#x3D;&#123;btn&#125; onClick&#x3D;&#123;btnClick&#125;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>当做全局变量</em></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef, useEffect, useState &#125; from &#39;react&#39;</span><br><span class="line">function usePrevious(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 每次重新渲染，都会执行useRef,</span><br><span class="line">    const ref &#x3D; useRef()</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - 不设置依赖，每次reRender都会重新执行</span><br><span class="line">        - 能够返回上一次渲染之前value是什么值</span><br><span class="line">        - 注意是先执行return, 在执行useEffect</span><br><span class="line">    *&#x2F;</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        ref.current &#x3D; value</span><br><span class="line">    &#125;)</span><br><span class="line">    return ref.current</span><br><span class="line">&#125;</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0)</span><br><span class="line">    const preCount &#x3D; usePrevious(count)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;previous: &#123;preCount&#125; &lt;&#x2F;p&gt;</span><br><span class="line">            &lt;p&gt;now: &#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useImperativeHandle-用法"><a href="#useImperativeHandle-用法" class="headerlink" title="useImperativeHandle 用法"></a><code>useImperativeHandle</code> 用法</h3><blockquote>
<p>identity: <code>useImperativeHandle(ref, createHandle, [deps])</code></p>
</blockquote>
<p><code>useImperativeHandle</code>可以让你在使用<code>ref</code>时自定义暴露给父组件的实例值, 与<code>forwardRef</code>一起使用. 让你能够父组件调用子组件的方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef, useImperativeHandle, forwardRef &#125; from &#39;react&#39;</span><br><span class="line">function MyInput(props, ref) &#123;</span><br><span class="line">    const inputRef &#x3D; useRef()</span><br><span class="line">    const childFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;hh&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        ref: ref实例</span><br><span class="line">        createHandle: 给ref实例绑上方法</span><br><span class="line">        [dps]: 当deps发生变化的时候, createHandle 重新执行</span><br><span class="line">    *&#x2F;</span><br><span class="line">    useImperativeHandle(ref, () &#x3D;&gt; (&#123;</span><br><span class="line">        focus: () &#x3D;&gt; &#123;</span><br><span class="line">            inputRef.current.focus()</span><br><span class="line">        &#125;,</span><br><span class="line">        childFunc</span><br><span class="line">    &#125;))</span><br><span class="line">    return &lt;input ref&#x3D;&#123;inputRef&#125; &#x2F;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    MyInput &#x3D; forwardRef(MyInput)</span><br><span class="line"></span><br><span class="line">    function App() &#123;</span><br><span class="line">        const myInputCoponent &#x3D; useRef()</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;MyInput ref&#x3D;&#123;myInputCoponent&#125; &#x2F;&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; myInputCoponent.current.childFunc() &#125;&#125;&gt; focus now &lt;&#x2F;button&gt;</span><br><span class="line">            &lt;&#x2F;&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="useReducer-用法"><a href="#useReducer-用法" class="headerlink" title="useReducer 用法"></a><code>useReducer</code> 用法</h3><blockquote>
<p>identity: <code>const [state, dispatch] = useReducer(reducer, initialArg, init)</code></p>
</blockquote>
<p><code>useReducer</code>是useState的替代方案，接受一个形如(state, action) =&gt; newState 的 reducer, 并返回<br>当前的state以及其配套的dispatch方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const initialState &#x3D; &#123;count: 0&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;increment&#39;:</span><br><span class="line">            return &#123;count: state.count + 1&#125;;</span><br><span class="line">        case &#39;decrement&#39;:</span><br><span class="line">            return &#123;count: state.count - 1&#125;;</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, initialState);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            Count: &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="useMemo-用法"><a href="#useMemo-用法" class="headerlink" title="useMemo 用法"></a><code>useMemo</code> 用法</h3><blockquote>
<p>identity: <code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b])</code><br>newRenderTemplate = useMemo(() =&gt; renderTemplate(), [deps])</p>
</blockquote>
<p><code>useMemo</code>是减少组件渲染次数，优化组件性能的hook, 传入<code>useMemo</code>的函数会在渲染期间执行，请不要再函数<br>内部执行与渲染无关的操作，其实也就是只有依赖项发生变化才会生成新的memoizedValue。这样就减少了不必要的<br>渲染。一般用在组件中进行解耦操作，与这个逻辑渲染相关的逻辑发生变化就重新渲染，而不相关的就不会重新渲染。<br>大白话就是有一个count逻辑相关的渲染，还有一个和name相关的逻辑渲染。不要因为name的state属性变化导致<br>count的渲染函数也重新执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useMemo &#125; from &#39;react&#39;</span><br><span class="line">const log &#x3D; console.log.bind(console)</span><br><span class="line"></span><br><span class="line">function Child(props) &#123;</span><br><span class="line">    log(&#39;child render&#39;)</span><br><span class="line">    const [count, SetCount] &#x3D; useState(0)</span><br><span class="line">    const renderCountTemplate &#x3D; (count) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;count render&#39;)</span><br><span class="line">        return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            child, &#123;props.name&#125;</span><br><span class="line">            &#123;&#x2F;*</span><br><span class="line">                - 使用useMemo防止了不必要的渲染更新，不会因为与当前父组件的props发生变化就会重新对renderCountTemplate进行执行。</span><br><span class="line">            *&#x2F;&#125;</span><br><span class="line">            &#123; useMemo(() &#x3D;&gt; renderCountTemplate(count), [count])&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Child组件优化：组件内 prop，state 的值发生变化才会重新渲染。防止了父组件的更新，子组件也进行不必要的更新</span><br><span class="line">Child &#x3D; React.memo(Child)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">    log(&#39;parent render&#39;)</span><br><span class="line">    const [name, SetName] &#x3D; useState(&#39;&#39;)</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;parent, &#123;name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;input onChange&#x3D;&#123;(event) &#x3D;&gt; SetName(event.target.value)&#125; &#x2F;&gt;</span><br><span class="line">            &lt;Child name&#x3D;&#123;name&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="useCallback-用法"><a href="#useCallback-用法" class="headerlink" title="useCallback 用法"></a><code>useCallback</code> 用法</h3><blockquote>
<p>identity: <code>const memoizedCallback = useCallback(() =&gt; &#123; doSomething(a, b); &#125;, [a, b]);</code></p>
</blockquote>
<p><code>useCallback</code>是减少组件渲染次数，优化组件性能的hook, 与<code>useMemo</code>类似。回调函数仅在某个依赖项改变时才会更新<br>常用在对事件函数中匿名函数的处理。当然能用到useMemo的地方，useCallback也可以用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useCallback, useState &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">const [ count, setCount ] &#x3D; useState(0)</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    &lt;!--</span><br><span class="line">        - 防止了每次count发生变化，导致的重新渲染，都需要重新生成一个新的匿名函数</span><br><span class="line">        - 也就是说 () &#x3D;&gt; &#123;setCount(count + 1)&#125; 这个匿名函数不需要再从新的内存空间中创建</span><br><span class="line">     --&gt;</span><br><span class="line">    return &lt;div onClick&#x3D;&#123;useCallback(() &#x3D;&gt; setCount(count+1), [])&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useLayoutEffect-用法"><a href="#useLayoutEffect-用法" class="headerlink" title="useLayoutEffect 用法"></a><code>useLayoutEffect</code> 用法</h3><p><code>useLayoutEffect</code> 官方解释说它会在所有的DOM变更之后同步调用effect，可能<code>useEffect</code>是在所有的DOM变更之后异步调用effect吧.</p>
<ul>
<li>可以使用它来读取 DOM 布局并同步触发重渲染</li>
<li>在浏览器执行绘制之前，<code>useLayoutEffect</code>内部的更新计划将被同步刷新。</li>
<li>这么说吧，我也不太<code>useLayoutEffect</code>的区别。有下面一段代码可以参考一下。估计在使用<code>useEffect</code>的时候带来了页面的抖动问题的时候就使用<code>useLayoutEffect</code>。网上的解释:layout会在组件树构建完毕或者刷新完毕后同步立刻执行。effect会等其他js代码执行完毕后执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (count &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      const randomNum &#x3D; 10 + Math.random()*200</span><br><span class="line">      setCount(10 + Math.random()*200);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>效果如下:<br><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0dcc15419be9?imageslim" alt="结果"></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (count &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      const randomNum &#x3D; 10 + Math.random()*200</span><br><span class="line">      setCount(10 + Math.random()*200);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>效果如下:<br><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0dca05c0fa6e?imageslim" alt="结果"></p>
</blockquote>
</li>
</ul>
<h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><ul>
<li><a href="#useDidUpdate">useDidUpdate</a></li>
<li><a href="#useGlobalReduxHook">useGlobalReduxHook</a></li>
</ul>
<div id="useDidUpdate"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个ComponentDidUpdate的简易实现</span><br><span class="line">import &#123; useEffect, useRef &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">function useDidUpdate(cb, deps&#x3D;[]) &#123;</span><br><span class="line">  const didMount &#x3D; useRef(false)</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (!didMount.current) &#123;</span><br><span class="line">      didMount.current &#x3D; true</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, deps)</span><br><span class="line"></span><br><span class="line">  return didMount.current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="useGlobalReduxHook"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个redux的简易实现</span><br><span class="line">import React, &#123; useContext, useReducer &#125; from &#39;react&#39;</span><br><span class="line">const initState &#x3D; &#123; count: 0 &#125;</span><br><span class="line">const Store &#x3D; React.createContext(initStore)</span><br><span class="line">const MapActionReducer &#x3D; &#123;</span><br><span class="line">    [&#39;ADD&#39;](state, action) &#123;</span><br><span class="line">        return &#123;...state, count: action.payload&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reducer &#x3D; (initState, action) &#x3D;&gt; &#123;</span><br><span class="line">    return MapActionReducer[action.type](initState, action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function useGlobalReduxHook(Component) &#123;</span><br><span class="line">    &#x2F;&#x2F; dispatch触发state发生变化，会重新执行渲染</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, Store)</span><br><span class="line">    return (</span><br><span class="line">        &lt;Store.Provider value&#x3D;&#123;state, dispatch&#125; &#x2F;&gt;</span><br><span class="line">            &lt;Component &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Store.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/14/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/">markdown语法教程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/markdown%E8%AF%AD%E6%B3%95/">markdown语法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/markdown/">markdown</a></span><div class="content"><h1 id="这是一篇markdwon语法教程"><a href="#这是一篇markdwon语法教程" class="headerlink" title="这是一篇markdwon语法教程"></a>这是一篇markdwon语法教程</h1><p>另外欢迎大家访问<a href="https://chenwoyao.github.io/categories/">我的博客</a></p>
<h1 id="关于markdown"><a href="#关于markdown" class="headerlink" title="关于markdown"></a>关于markdown</h1><p>markdown 是一种文本，类似于html， 比起html文本，语法标签更少，很容易上手写作</p>
<h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 标题1</span></span><br><span class="line"><span class="section">## 标题2</span></span><br><span class="line"><span class="section">### 标题3</span></span><br><span class="line"><span class="section">#### 标题4</span></span><br><span class="line"><span class="section">##### 标题5</span></span><br><span class="line"><span class="section">###### 标题6</span></span><br><span class="line">快捷键: h1 + tap</span><br></pre></td></tr></table></figure>

<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">有序列表:</span><br><span class="line"><span class="bullet">1.</span> list1</span><br><span class="line"><span class="bullet">2.</span> list2</span><br><span class="line"></span><br><span class="line">无序列表:</span><br><span class="line"><span class="bullet">-</span> list1</span><br><span class="line"><span class="bullet">*</span> list2</span><br><span class="line"><span class="bullet">    -</span> list3</span><br><span class="line"><span class="bullet">    -</span> list4</span><br><span class="line"></span><br><span class="line">任务列表：</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成任务1</span><br><span class="line"><span class="bullet">-</span> [x] 已完成任务1</span><br><span class="line"></span><br><span class="line">引用列表:</span><br><span class="line"><span class="quote">&gt; ref1</span></span><br><span class="line"><span class="quote">&gt; ref2</span></span><br></pre></td></tr></table></figure>

<h2 id="文字样式语法"><a href="#文字样式语法" class="headerlink" title="文字样式语法"></a>文字样式语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**加粗** [快捷键：Ctrl+B]</span><br><span class="line">__加粗2__</span><br><span class="line"></span><br><span class="line">_倾斜_</span><br><span class="line">*倾斜*</span><br><span class="line"></span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>

<h2 id="图片显示或者链接显示"><a href="#图片显示或者链接显示" class="headerlink" title="图片显示或者链接显示"></a>图片显示或者链接显示</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">链接语法：</span><br><span class="line">[<span class="string">我的github</span>](<span class="link">https://github.com/ChenWoyao</span>)</span><br><span class="line"></span><br><span class="line">图片语法：</span><br><span class="line">![<span class="string">alt帅哥</span>](<span class="link">./static/img/bg.png</span>)</span><br></pre></td></tr></table></figure>

<h2 id="表格语法"><a href="#表格语法" class="headerlink" title="表格语法"></a>表格语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|	th1	|	th2	|	th3	|</span><br><span class="line">|--	|--	|--	|</span><br><span class="line">|	td1	|	td2	|	td3	|</span><br><span class="line">|	td1	|	td2	|   td3	|</span><br></pre></td></tr></table></figure>

<h2 id="代码块语法"><a href="#代码块语法" class="headerlink" title="代码块语法"></a>代码块语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">表示一个代码片段：</span><br><span class="line"><span class="code">`from urllib import parse`</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span>from urllib import parse<span class="xml"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">表示一段代码块：(diff, js, php, sh 等语法都支持)</span><br><span class="line"><span class="code">``` js</span></span><br><span class="line"><span class="code">    data = &#123;</span></span><br><span class="line"><span class="code">        &#x27;a&#x27;: &#x27;test&#x27;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">` ``</span></span><br><span class="line"><span class="code">&lt;pre&gt;</span></span><br><span class="line"><span class="code">    data = &#123;</span></span><br><span class="line"><span class="code">        &#x27;a&#x27;: &#x27;test&#x27;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&lt;/pre&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释--&gt;</span><br><span class="line">快捷键: cmd + /</span><br></pre></td></tr></table></figure>

<h2 id="目录与锚点"><a href="#目录与锚点" class="headerlink" title="目录与锚点"></a>目录与锚点</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">展示目录树的写法：</span><br><span class="line">├── [<span class="string">README.md</span>](<span class="link">#readme</span>)</span><br><span class="line">├── [<span class="string">build</span>](<span class="link">#build</span>)</span><br><span class="line">│ ├── [<span class="string">webpack.base.js</span>](<span class="link">#webpack-base</span>)</span><br><span class="line">│ ├── [<span class="string">webpack.client.js</span>](<span class="link">#webpack-client</span>)</span><br><span class="line">│ └── [<span class="string">webpack.server.js</span>](<span class="link">#webpack-server</span>)</span><br><span class="line">├── [<span class="string">package-lock.json</span>](<span class="link">#package-lock</span>)</span><br><span class="line">├── [<span class="string">package.json</span>](<span class="link">#package.json</span>)</span><br><span class="line">└── [<span class="string">src</span>](<span class="link">#src</span>)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [<span class="string">README.md</span>](<span class="link">#readme</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">build</span>](<span class="link">#build</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.base.js</span>](<span class="link">#webpack-base</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.client.js</span>](<span class="link">#webpack-client</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.server.js</span>](<span class="link">#webpack-server</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">package-lock.json</span>](<span class="link">#package-lock</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">package.json</span>](<span class="link">#package.json</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">src</span>](<span class="link">#src</span>)</span><br><span class="line"></span><br><span class="line">对应的锚点dom:</span><br><span class="line"><span class="section">## readme</span></span><br><span class="line"><span class="section">## build</span></span><br><span class="line"><span class="section">### webpack-base</span></span><br><span class="line"><span class="section">### webpack-client</span></span><br><span class="line"><span class="section">### webpack-server</span></span><br><span class="line"><span class="section">## ackage-lock</span></span><br><span class="line"><span class="section">## package.json</span></span><br><span class="line"><span class="section">## src</span></span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;readme&quot;</span>&gt;</span></span> readme <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span> build <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">------------- 【快捷键：hr后敲Tab】</span><br><span class="line">*************</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\sum<span class="emphasis">_&#123;i=1&#125;^n a_</span>i=0$$</span><br><span class="line"></span><br><span class="line">$$f(x<span class="emphasis">_1,x_</span>x,\ldots,x<span class="emphasis">_n) = x_</span>1^2 + x<span class="emphasis">_2^2 + \cdots + x_</span>n^2$$</span><br><span class="line"></span><br><span class="line">$$\sum^&#123;j-1&#125;<span class="emphasis">_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_</span>&#123;kj&#125; z<span class="emphasis">_k&#125;$$</span></span><br></pre></td></tr></table></figure>

</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2021 By woyao</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>