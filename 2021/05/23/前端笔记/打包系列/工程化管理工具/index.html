<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《打包系列|工程化管理工具篇》"><meta name="keywords" content="打包系列"><meta name="author" content="woyao"><meta name="copyright" content="woyao"><title>《打包系列|工程化管理工具篇》 | woyao的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Epackage-json"><span class="toc-number">1.1.</span> <span class="toc-text">关于package.json</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#npm"><span class="toc-number">2.</span> <span class="toc-text">npm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#npm%E7%9A%84%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">npm的安装机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">npm缓存机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.</span> <span class="toc-text">npm常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npx%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">npx的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8nvm-%E7%AE%A1%E7%90%86-node%E7%89%88%E6%9C%AC"><span class="toc-number">2.5.</span> <span class="toc-text">使用nvm 管理 node版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8nrm%E5%88%87%E6%8D%A2npm-%E6%BA%90"><span class="toc-number">2.6.</span> <span class="toc-text">使用nrm切换npm 源</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#yarn"><span class="toc-number">3.</span> <span class="toc-text">yarn</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Eyarn%E7%9A%84%E9%94%81%E6%96%87%E4%BB%B6yarn-lock"><span class="toc-number">3.1.</span> <span class="toc-text">关于yarn的锁文件yarn.lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yarn%E7%9A%84%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">yarn的安装机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%8C%85"><span class="toc-number">3.2.1.</span> <span class="toc-text">检测包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%8C%85"><span class="toc-number">3.2.2.</span> <span class="toc-text">解析包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8C%85"><span class="toc-number">3.2.3.</span> <span class="toc-text">获取包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%8C%85"><span class="toc-number">3.2.4.</span> <span class="toc-text">链接包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%8C%85"><span class="toc-number">3.2.5.</span> <span class="toc-text">构建包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yarn%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.</span> <span class="toc-text">yarn的常用命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">关于包管理工具的扁平化机制</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://0.gravatar.com/avatar/0e261cd9b93afcd1c13b39d5ba7d6e2d"></div><div class="author-info__name text-center">woyao</div><div class="author-info__description text-center">分享，交流，学习，成长</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/ChenWoyao">follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">47</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">woyao的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/categories">目录</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/projects">项目实战</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/about">关于作者</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">《打包系列|工程化管理工具篇》</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/"> 打包系列</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span></span></div><div class="article-container" id="post-content"><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>前端工程化离不开<code>npm</code>或者<code>Yarn</code> 这些管理工具。npm或Yarn 在工程项目中，除了负责依赖的安装和维护以外，还能通过 <code>npm scripts</code> 串联起各个职能部分，让独立的环节自动运转起来。另外在使用管理工具的时候会遇到一些问题如下:</p>
<ul>
<li><p>项目依赖出现问题时，删除大法好，即删除 node_modules 和 lockfiles，再重新 install，这样操作是否存在风险</p>
<blockquote>
<p>重新安装可能会改变依赖版本, 是有风险的<br>因为删除lock文件以后, 模块的安装顺序可能影响 node_modules 内的文件结构<br>insatll命令执行的时候，获取依赖包的顺序不一样，可能导致扁平化机制生成的依赖树不一样</p>
</blockquote>
</li>
<li><p>我们的应用依赖了公共库 A 和公共库 B，同时公共库 A 也依赖了公共库 B，那么公共库 B 会被多次安装或重复打包吗</p>
<blockquote>
<p>看版本范围是否在一个范围内，同一个版本范围，不会重复。</p>
</blockquote>
</li>
<li><p>一个项目中，既有人用 npm，也有人用 Yarn，这会引发什么问题</p>
<blockquote>
<p>lock文件不同，可能会存在冲突，导致最终安装版本不一致。</p>
</blockquote>
</li>
<li><p>我们是否应该提交 lockfiles 文件到项目仓库呢</p>
<blockquote>
<p>如果开发一个应用，建议把 package-lock.json 文件提交到代码版本仓库。这样可以保证项目组成员、运维部署成员或者 CI 系统，在执行 npm install 后，能得到完全一致的依赖安装内容。</p>
<p>如果你的目标是开发一个给外部使用的库，那就要谨慎考虑了，因为库项目一般是被其他项目依赖的，在<br>不使用 package-lock.json 的情况下，就可以复用主项目已经加载过的包，减少依赖重复和体积</p>
<p>因此，一个推荐的做法是：把 package-lock.json 一起提交到代码库中，不需要 ignore。但是执行 npm publish 命令，发布一个库的时候，它应该被忽略而不是直接发布出去</p>
</blockquote>
</li>
<li><p>为什么单一的 package.json 不能确定唯一的依赖树</p>
<blockquote>
<p>不同版本的 npm 的安装依赖策略和算法不同；</p>
<p>npm install 将根据 package.json 中的 semver-range version 更新依赖，某些依赖项自上次安装以来，可能已发布了新版本。</p>
</blockquote>
</li>
<li><p>为什么有时候可以离线安装一些包</p>
<blockquote>
<p>因为包管理工具的缓存机制</p>
</blockquote>
</li>
</ul>
<p>另外很多时候我们在配置package.json中除了<code>scripts</code>属性的配置，其他的配置也会有些陌生，npm和yarn的一些操作也不太懂.</p>
<h2 id="关于package-json"><a href="#关于package-json" class="headerlink" title="关于package.json"></a>关于package.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: &#x27;woyao_cli&#x27;,</span><br><span class="line">  <span class="comment">// 执行脚本命令</span></span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当不配置 homepage 属性，build 打包之后的文件资源应用路径默认是 /</span></span><br><span class="line">  <span class="comment">// 当你设置了 homepage 属性后, 打包后的资源路径就会加上 homepage 的地址</span></span><br><span class="line">  <span class="comment">// 相当于output的publicPath</span></span><br><span class="line">  homepage: &#x27;/&#x27;,</span><br><span class="line">  <span class="comment">// bin的作用，它是一个命令名和本地文件名的映射。</span></span><br><span class="line">  <span class="comment">// 在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin</span></span><br><span class="line">  <span class="comment">// 如果是本地安装，会链接到./node_modules/.bin/</span></span><br><span class="line">  <span class="comment">// 通俗点理解如果我们是全局安装我们就可以在全局命令行中执行bin指向的这个文件</span></span><br><span class="line">  <span class="comment">// 本地安装我们只能在在当前工程目录的命令行中执行bin指向的该文件。</span></span><br><span class="line">  <span class="comment">// 其实做的事情就是在node_modules/bin文件夹下加入一个命令名, 命令名会映射到我们bin指向的文件</span></span><br><span class="line">  <span class="comment">// 请确保你的bin指向的文件里面最开头写上 #!/usr/bin/env node</span></span><br><span class="line">  <span class="comment">// 这样才能保证该文件的执行环境是在node中，否则你还得这么写 node woyao_cli xxx</span></span><br><span class="line">  <span class="comment">// 确保环境以后你就可以这么写woyao_cli xxx</span></span><br><span class="line">  <span class="comment">// 命令名的配置如果是单一文件，默认就是package.json中的name字段</span></span><br><span class="line">  <span class="comment">// 当然也可以自己设置: &#123;&quot;bin&quot;: &#123;&quot;woyao_cli&quot;: &#x27;index.js&#x27;&#125;&#125;</span></span><br><span class="line">  <span class="comment">// 这样在别的机器中全局安装我们这个项目包的时候</span></span><br><span class="line">  bin: &#x27;index.js&#x27;,</span><br><span class="line">  <span class="comment">// 代码入口</span></span><br><span class="line">  <span class="comment">// 再写公共库的时候这个配置项很重要</span></span><br><span class="line">  <span class="comment">// 比如我们打包后的文件放在dist文件下，包名叫做instance</span></span><br><span class="line">  <span class="comment">// 别的业务项目要引用我们的包需要这样require(&#x27;instance/dist/inddex.js&#x27;)</span></span><br><span class="line">  <span class="comment">// 如果指定main:&#x27;dist/index.js&#x27;,那么就可以直接require(&#x27;instance&#x27;)了</span></span><br><span class="line">  main: &#x27;index.js&#x27;,</span><br><span class="line">  <span class="comment">// 代码运行时所需要的依赖</span></span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;core-js&quot;: &quot;^3.6.5&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^3.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发依赖，就是那些只在开发过程中需要，而运行时不需要的依赖</span></span><br><span class="line">  <span class="comment">// 也就是说打包过程要用到的依赖，打包以后你就不再要用到了</span></span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;eslint&quot;: &quot;^6.7.2&quot;,</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^7.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 可选依赖，这种依赖即便安装失败，Yarn也会认为整个依赖安装过程是成功的</span></span><br><span class="line">  &quot;optionalDependences&quot;: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 注意:</span></span><br><span class="line"><span class="comment">并不是只有在 dependencies 中的模块才会被一起打包，</span></span><br><span class="line"><span class="comment">而在 devDependencies 中的依赖一定不会被打包。</span></span><br><span class="line"><span class="comment">实际上，依赖是否被打包，完全取决于项目里是否被引入了该模块。</span></span><br><span class="line"><span class="comment">dependencies 和 devDependencies 在业务中更多的只是一个规范作用，</span></span><br><span class="line"><span class="comment">我们自己的应用项目中，使用 npm install 命令安装依赖时，</span></span><br><span class="line"><span class="comment">dependencies 和 devDependencies 内容都会被下载。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><h2 id="npm的安装机制"><a href="#npm的安装机制" class="headerlink" title="npm的安装机制"></a><strong>npm的安装机制</strong></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1e95cc2637e4212900e939d41d3c8b6~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><strong>注意</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1. 这里的config配置(npm配置)是指&#96;.npmrc文件&#96;</span><br><span class="line">(项目级的 .npmrc 文件&gt; 用户级的 .npmrc 文件&gt; 全局级的</span><br><span class="line">.npmrc 文件 &gt; npm 内置的 .npmrc 文件)。</span><br><span class="line"></span><br><span class="line">2. 构建依赖树时，当前依赖项目不管其是直接依赖还是子依赖的依赖，</span><br><span class="line">都应该按照扁平化原则，优先将其放置在 node_modules 根目录.</span><br><span class="line">在这个过程中，遇到相同模块就判断已放置在依赖树中的模块版本是否符合新模块的版本范围，</span><br><span class="line">如果符合则跳过；不符合则在当前模块的 node_modules 下放置该模块</span><br><span class="line">3. 依赖关系:</span><br><span class="line">并不是所有的子依赖都有 dependencies 属性，</span><br><span class="line">只有子依赖的依赖和当前已安装在根目录的 node_modules 中的依赖冲突之后，</span><br><span class="line">才会有这个属性</span><br><span class="line"></span><br><span class="line"> &quot;@babel&#x2F;helper-annotate-as-pure&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;7.12.13&quot;,</span><br><span class="line">      &quot;resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;@babel&#x2F;helper-annotate-as-pure&#x2F;download&#x2F;@babel&#x2F;helper-annotate-as-pure-7.12.13.tgz&quot;,</span><br><span class="line">      &quot;integrity&quot;: &quot;sha1-D1jobfxLs7H819uAZXDhd9Q5tqs&#x3D;&quot;,</span><br><span class="line">      &quot;dev&quot;: true,</span><br><span class="line">      &quot;requires&quot;: &#123;</span><br><span class="line">        &quot;@babel&#x2F;types&quot;: &quot;^7.12.13&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;@babel&#x2F;generator&quot;: &#123;</span><br><span class="line">          &quot;version&quot;: &quot;7.2.0&quot;,</span><br><span class="line">          &quot;resolved&quot;: &quot;http:&#x2F;&#x2F;www.npm.com&#x2F;@babel%2fgenerator&#x2F;-&#x2F;generator-7.2.0.tgz&quot;,</span><br><span class="line">          &quot;integrity&quot;: &quot;sha1-6vOCH6AwHZ1K74jmPUvMGbc7oWw&#x3D;&quot;,</span><br><span class="line">          &quot;dev&quot;: true,</span><br><span class="line">          &quot;requires&quot;: &#123;</span><br><span class="line">            &quot;@babel&#x2F;types&quot;: &quot;^7.2.0&quot;,</span><br><span class="line">            &quot;jsesc&quot;: &quot;^2.5.1&quot;,</span><br><span class="line">            &quot;lodash&quot;: &quot;^4.17.10&quot;,</span><br><span class="line">            &quot;source-map&quot;: &quot;^0.5.0&quot;,</span><br><span class="line">            &quot;trim-right&quot;: &quot;^1.0.1&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">	    &#x2F;&#x2F; ...</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="npm缓存机制"><a href="#npm缓存机制" class="headerlink" title="npm缓存机制"></a><strong>npm缓存机制</strong></h2><p>对于一个依赖包的同一版本进行本地化缓存，是当代依赖包管理工具的一个常见设计。<br>通过<code>npm config get cache</code>可以获得npm缓存配置的路径, 比如:<strong><code>/Users/chen/.npm</code></strong><br>切换到缓存配置的路径以后，可以看到一个<code>_cacache文件夹</code>。该文件夹存放依赖包的缓存。<br>当然你可以通过<code> npm cache clean --force</code>清空缓存。打开_cacache文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cache文件夹下的目录文件:</span><br><span class="line">  - content-v2</span><br><span class="line">    存放二进制文件，将二进制文件的扩展名改为.tgz，然后进行解压，得到的结果其实就是我们的 npm 包资源</span><br><span class="line">  - index-v5</span><br><span class="line">    缓存记录</span><br><span class="line">  - tmp</span><br></pre></td></tr></table></figure>

<p><strong><em>Npm v5+ 缓存策略如下</em></strong>:</p>
<p>当 npm install 执行时，通过pacote把相应的包解压在对应的 node_modules 下面。npm 在下载依赖时，先下载到缓存当中，再解压到项目 node_modules 下。pacote 依赖npm-registry-fetch来下载包，npm-registry-fetch 可以通过设置 cache 属性，在给定的路径下根据IETF RFC 7234生成缓存数据。</p>
<p>接着，在每次安装资源时，根据 package-lock.json 中存储的 integrity、version、name 信息生成一个唯一的 key，这个 key 能够对应到 index-v5 目录下的缓存记录。如果发现有缓存资源，就会找到 tar 包的 hash，根据 hash 再去找缓存的 tar 包，并再次通过pacote把对应的二进制文件解压到相应的项目 node_modules 下面，省去了网络下载资源的开销。</p>
<p><strong><em>npm v5 版本之前</em></strong>:</p>
<p>每个缓存的模块在 ~/.npm 文件夹中以模块名的形式直接存储，储存结构是：{cache}/{name}/{version}。</p>
<h2 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a><strong>npm常用命令</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 shell 脚本输出一个初始化的 package.json 文件</span></span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装所有依赖包</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包安装</span></span><br><span class="line">npm install [package] --save-dev</span><br><span class="line">npm install [package] --save</span><br><span class="line">npm install [package] -g</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重建</span></span><br><span class="line">npm rebuild</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除包</span></span><br><span class="line">npm uninstall [package]</span><br><span class="line">npm uninstall --save [package]</span><br><span class="line">npm uninstall --save-dev [package]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看npm镜像</span></span><br><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置npm的镜像</span></span><br><span class="line"><span class="comment">// ---官方镜像</span></span><br><span class="line">npm config set registry https:<span class="comment">//registry.npmjs.org/</span></span><br><span class="line"><span class="comment">// ---淘宝镜像</span></span><br><span class="line">npm config set registry https:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录</span></span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布个人项目到npm上</span></span><br><span class="line"><span class="comment">// 第一次发布时，需要创建用户：npm adduser</span></span><br><span class="line">npm publish</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用户</span></span><br><span class="line">npm adduse</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本</span></span><br><span class="line">npm update &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看缓存存放路径</span></span><br><span class="line">npm config get cache</span><br><span class="line"><span class="comment">// 可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</span></span><br><span class="line">npm cache clear --force</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以撤销发布自己发布过的某个版本代码。</span></span><br><span class="line">npm unpublish &lt;package&gt;@&lt;version&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除整个版本</span></span><br><span class="line">npm unpublish &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建立软链接(这个很重要)</span></span><br><span class="line"><span class="comment"> 为目标npm模块创建软链接,</span></span><br><span class="line"><span class="comment"> 将其链接到全局node模块安装路径 &quot;/xxx/lib/node_modules/&quot; 中</span></span><br><span class="line"><span class="comment"> 为目标npm模块的可执行bin文件创建软链接，</span></span><br><span class="line"><span class="comment"> 将其链接到全局node命令安装路径 &quot;/usr/local/bin/&quot; 中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">npm link</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关于<code>npm link</code> 这个命令：</strong></p>
<p>在开发公共包的时候，比如我开发了一个组件库, 现在组件库内新增了一个组件<Swiper/>,但我不能发布新版本，因为不确定这个组件的正确性。那我如何确定这个新增的组件能够在我的业务项目中使用呢？<a target="_blank" rel="noopener" href="https://github.com/ChenWoyao/baleExample/tree/master/npmLink">使用教程的代码参考</a></p>
<ol>
<li>比较笨的办法就是打包现在的组件库，然后把打包的组件库放入node_modules里面，然后在验证</li>
<li>正确的做法是通过npm link. (假设我们之前的组件库打包后叫做 <code>npm-package-ui</code>)<ol>
<li>首先我们进入我们的组件库，执行npm link(这样 npm link 通过链接目录和可执行文件，实现 npm 包命令的全局可执行)。</li>
<li>然后进入本地的业务项目，执行 <code>npm link npm-package-ui</code>. 它就会去 /usr/local/lib/node_modules/ 这个路径下寻找是否有这个包，如果有就建立软链接.</li>
<li>这样我本地的业务项目就可以和本地最新的组件库建立软链接了，然后启动程序，我就可以用新组件<Swiper/>了。不过每次npm-package-ui的更新，都需要本地业务项目重新<br>启动，才可以得到新的变化。</li>
<li>最后测试结束以后， <code>npm unlink</code>取消关联，然后测试没问题就可以发布新版本的组件库包了。</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="npx的用法"><a href="#npx的用法" class="headerlink" title="npx的用法"></a><strong>npx的用法</strong></h2><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/02/npx.html">《阮一峰npx教程》</a></p>
<ul>
<li>npx 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在，而不需要再在 package.json 中定义相关的 script。通过<code>npm install -g npx</code>命令来安装npx (需要npm V5.2+)</li>
</ul>
<p>比如之前需要这样才能执行eslint</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;eslint:init&quot;: &quot;./node_modules/.bin/eslint --init&quot;,</span><br><span class="line">    &quot;eslint:run&quot;: &quot;./node_modules/.bin/eslint yourfile.js&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>使用npx以后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx eslint --init</span><br><span class="line">npx eslint yourfile.js</span><br></pre></td></tr></table></figure>

<ul>
<li>另外除了调用项目内部模块，npx 还能避免全局安装的模块。比如，<code>create-react-app</code>这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; npx 将create-react-app下载到一个临时目录，使用以后再删除。</span><br><span class="line">&#x2F;&#x2F; 再次执行下面的命令，会重新下载create-react-app</span><br><span class="line">npx create-react-app my-react-app</span><br></pre></td></tr></table></figure>

<ul>
<li>切换node版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nvm 的命令如下</span><br><span class="line">nvm install 14.5.0</span><br><span class="line">nvm use 14.5.0</span><br><span class="line">&#x2F;&#x2F; npx 的命令如下</span><br><span class="line">npx node@14.5.0 -v</span><br></pre></td></tr></table></figure>

<h2 id="使用nvm-管理-node版本"><a href="#使用nvm-管理-node版本" class="headerlink" title="使用nvm 管理 node版本"></a>使用nvm 管理 node版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装nvm</span><br><span class="line">npm install -g nvm</span><br><span class="line">&#x2F;&#x2F; 下载具体的node包</span><br><span class="line">nvm install 14.5.0</span><br><span class="line">&#x2F;&#x2F; 切换到某个node版本包</span><br><span class="line">nvm use 14.5.0</span><br><span class="line">&#x2F;&#x2F; 查看当前所有的Node包的版本</span><br><span class="line">nvm list</span><br></pre></td></tr></table></figure>

<h2 id="使用nrm切换npm-源"><a href="#使用nrm切换npm-源" class="headerlink" title="使用nrm切换npm 源"></a>使用nrm切换npm 源</h2><p>有时候我们可能觉得切换比较麻烦，老是要<code>npm config set registry 某npm镜像url </code>. 这时候可以使用nrm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装nrm</span><br><span class="line">npm install -g nrm</span><br><span class="line">&#x2F;&#x2F; 列举可以选的源</span><br><span class="line">nrm ls</span><br><span class="line">&#x2F;&#x2F; 切换到想要的源</span><br><span class="line">nrm use taobao</span><br><span class="line">&#x2F;&#x2F; 增加源</span><br><span class="line">nrm add &lt;registry&gt; &lt;url&gt; [home]</span><br><span class="line">&#x2F;&#x2F; 删除源</span><br><span class="line">nrm del &lt;registry&gt;</span><br><span class="line">&#x2F;&#x2F; 测试某源的速度</span><br><span class="line">nrm test taobao</span><br></pre></td></tr></table></figure>

<h1 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h1><p>Yarn 是一个由 Facebook、Google、Exponent 和 Tilde 构建的新的 JavaScript 包管理器<br>下面是yarn包管理器的优点(个人倾向于使用npm):</p>
<ul>
<li><p><strong>确定性</strong>：通过 yarn.lock 等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装。（在 npm v5 之前，没有 package-lock.json 机制，只有默认并不会使用的npm-shrinkwrap.json。）</p>
</li>
<li><p>__采用模块扁平安装模式__：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（npm 目前也有相同的优化）。Yarn 在安装依赖时会自动执行 dedupe 命令</p>
</li>
<li><p>__网络性能更好__：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制。</p>
</li>
<li><p><strong>采用缓存机制</strong>: 实现了离线模式（npm 目前也有类似实现）。</p>
</li>
</ul>
<h2 id="关于yarn的锁文件yarn-lock"><a href="#关于yarn的锁文件yarn-lock" class="headerlink" title="关于yarn的锁文件yarn.lock"></a>关于yarn的锁文件yarn.lock</h2><p>区别于package-lock.json, yarn.lock 并没有使用 JSON 格式，而是采用了一种自定义的标记格式<br>另外和npm lock文件相比， yarn.lock 中子依赖的版本号不是固定版本。这就说明单独一个 yarn.lock<br>确定不了 node_modules 目录结构，还需要和 package.json 文件进行配合。</p>
<p>不管是 npm 还是 Yarn，说到底它们都是一个包管理工具，在项目中如果想进行 npm/Yarn 切换，并不是一件麻烦的事情。甚至还有一个专门的 synp 工具，它可以将 yarn.lock 转换为 package-lock.json</p>
<h2 id="yarn的安装机制"><a href="#yarn的安装机制" class="headerlink" title="yarn的安装机制"></a>yarn的安装机制</h2><p>安装过程:  检测（checking）→ 解析包（Resolving Packages） → 获取包（Fetching Packages）→ 链接包（Linking Packages）→ 构建包（Building Packages）</p>
<h3 id="检测包"><a href="#检测包" class="headerlink" title="检测包"></a>检测包</h3><p>这一步主要是检测项目中是否存在一些 npm 相关文件，比如 package-lock.json 等。如果有，会提示用户注意：这些文件的存在可能会导致冲突。在这一步骤中，也会检查系统 OS、CPU 等信息</p>
<h3 id="解析包"><a href="#解析包" class="headerlink" title="解析包"></a>解析包</h3><p>这一步会解析依赖树中每一个包的版本信息:</p>
<p>首先获取当前项目中 package.json 定义的 dependencies、devDependencies、optionalDependencies 的内容，这属于首层依赖</p>
<p>接着采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析</p>
<p>对于没有解析过的包 A，首次尝试从 yarn.lock 中获取到版本信息，并标记为已解析<br>如果在 yarn.lock 中没有找到包 A，则向 Registry 发起请求获取满足版本范围的已知最高版本的包信息，获取后将当前包标记为已解析</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e05e1d8e768b4b85b3e72f9abdc1b0e8~tplv-k3u1fbpfcp-zoom-1.image" alt="yarn解析包"></p>
<h3 id="获取包"><a href="#获取包" class="headerlink" title="获取包"></a>获取包</h3><p>这一步我们首先需要检查缓存中是否存在当前的依赖包，同时将缓存中不存在的依赖包下载到缓存目录<br>如何判断缓存中是否存在当前的依赖包？Yarn 会根据 cacheFolder+slug+node_modules+pkg.name 生成一个 path，判断系统中是否存在该 path，如果存在证明已经有缓存，不用重新下载。这个 path 也就是依赖包缓存的具体路径</p>
<p>对于没有命中缓存的包，Yarn 会维护一个 fetch 队列，按照规则进行网络请求。如果下载包地址是一个 file 协议，或者是相对路径，就说明其指向一个本地目录，此时调用 Fetch From Local 从离线缓存中获取包；否则调用 Fetch From External 获取包。最终获取结果使用 fs.createWriteStream 写入到缓存目录下<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/829905268ebc47b78543a7ab3be88b88~tplv-k3u1fbpfcp-zoom-1.image" alt="yarn获取包"></p>
<h3 id="链接包"><a href="#链接包" class="headerlink" title="链接包"></a>链接包</h3><p>将项目中的依赖复制到项目 node_modules 下，同时遵循扁平化原则。在复制依赖前，Yarn 会先解析 peerDependencies (同伴依赖，它用来告知宿主环境需要什么依赖以及依赖的版本范围 )，如果找不到符合 peerDependencies 的包，则进行 warning 提示，并最终拷贝依赖到项目中<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a69ab08ecc0340808b063b503033992d~tplv-k3u1fbpfcp-zoom-1.image" alt="yarn链接包"></p>
<h3 id="构建包"><a href="#构建包" class="headerlink" title="构建包"></a>构建包</h3><p>如果依赖包中存在二进制包需要进行编译，会在这一步进行</p>
<h2 id="yarn的常用命令"><a href="#yarn的常用命令" class="headerlink" title="yarn的常用命令"></a>yarn的常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装所有依赖包</span><br><span class="line">yarn install</span><br><span class="line">&#x2F;&#x2F; 添加某一个依赖包</span><br><span class="line">yarn add [package] -dev</span><br><span class="line">yarn add [package]</span><br><span class="line">yarn global add [package]</span><br><span class="line">&#x2F;&#x2F; 重建</span><br><span class="line">yarn install --force</span><br><span class="line">&#x2F;&#x2F; 删除包</span><br><span class="line">yarn remove [package]</span><br><span class="line">yarn global remove [package]</span><br><span class="line">&#x2F;&#x2F; 查看缓存目录</span><br><span class="line">yarn cache dir</span><br><span class="line">&#x2F;&#x2F; 清除缓存</span><br><span class="line">yarn cache clean</span><br></pre></td></tr></table></figure>



<h1 id="关于包管理工具的扁平化机制"><a href="#关于包管理工具的扁平化机制" class="headerlink" title="关于包管理工具的扁平化机制"></a>关于包管理工具的扁平化机制</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef3eaac17ef1426e9e3603a716d697b9~tplv-k3u1fbpfcp-zoom-1.image" alt="包管理工具的扁平化机制"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">woyao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://chenwoyao.github.io/2021/05/23/前端笔记/打包系列/工程化管理工具/">https://chenwoyao.github.io/2021/05/23/前端笔记/打包系列/工程化管理工具/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chenwoyao.github.io">woyao的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/">打包系列</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-607541e3279cfc8b" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/24/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AEwebpack%E5%8E%9F%E7%90%86%E7%AF%87/"><i class="fa fa-chevron-left">  </i><span>《打包系列|webpack原理篇》</span></a></div><div class="next-post pull-right"><a href="/2021/05/22/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97%E5%BA%8F%E7%AB%A0/"><span>《打包系列|序章》</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '428a1dc9101af973234b',
  clientSecret: 'c3ee519e5e2db3e4e3c0025a9b332dd76f7c29f2',
  repo: 'ChenWoyao.github.io',
  owner: 'ChenWoyao',
  admin: 'ChenWoyao',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2021 By woyao</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>