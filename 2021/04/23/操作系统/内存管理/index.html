<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="内存管理"><meta name="keywords" content="操作系统"><meta name="author" content="woyao"><meta name="copyright" content="woyao"><title>内存管理 | woyao的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">内存分配的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">单一连续存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">分区式存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.3.</span> <span class="toc-text">固定分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.4.</span> <span class="toc-text">动态分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">伙伴系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%B4%A7%E7%BC%A9%EF%BC%88%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">内存紧缩（地址变换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.7.</span> <span class="toc-text">覆盖技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.8.</span> <span class="toc-text">交换技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.2.</span> <span class="toc-text">内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">页式和段式存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">页式存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">页式管理的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">段式存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.2.5.</span> <span class="toc-text">题目</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://0.gravatar.com/avatar/0e261cd9b93afcd1c13b39d5ba7d6e2d"></div><div class="author-info__name text-center">woyao</div><div class="author-info__description text-center">分享，交流，学习，成长</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/ChenWoyao">follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">54</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">woyao的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/categories">目录</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/projects">项目实战</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/about">关于作者</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">内存管理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"> 操作系统</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 8 分钟</span></span></div><div class="article-container" id="post-content"><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要包括虚地址、地址变换、内存分配和回收、内存扩充、内存共享和保护等功能。</span><br><span class="line">连续分配是指为一个用户程序分配连续的内存空间。连续分配有单一连续存储管理和分区式储管理两种方式</span><br></pre></td></tr></table></figure>

<h2 id="内存分配的方式"><a href="#内存分配的方式" class="headerlink" title="内存分配的方式"></a>内存分配的方式</h2><h3 id="单一连续存储管理"><a href="#单一连续存储管理" class="headerlink" title="单一连续存储管理"></a>单一连续存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。</span><br><span class="line">其特点是，最简单，适用于单用户、单任务的操作系统。</span><br><span class="line">CP／M和 DOS 2．0以下就是采用此种方式。这种方式的最大优点就是易于管理。</span><br></pre></td></tr></table></figure>

<h3 id="分区式存储管理"><a href="#分区式存储管理" class="headerlink" title="分区式存储管理"></a>分区式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分区式存储管理是把内存分为一些大小相等或不等的分区，</span><br><span class="line">操作系统占用其中一个分区，其余的分区由应用程序使用，</span><br><span class="line">每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，</span><br><span class="line">但难以进行内存分区的共享。</span><br></pre></td></tr></table></figure>

<h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">固定式分区的特点是把内存划分为若干个固定大小的连续分区。</span><br><span class="line">分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：</span><br></pre></td></tr></table></figure>

<h3 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，</span><br><span class="line">则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，</span><br><span class="line">而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。</span><br><span class="line">动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。</span><br><span class="line"></span><br><span class="line">最先适配法(nrst-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。</span><br><span class="line">该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。</span><br><span class="line"></span><br><span class="line">下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后&#123;区时再从头开始&#125;，</span><br><span class="line">找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。</span><br><span class="line"></span><br><span class="line">最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。</span><br><span class="line">从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。</span><br><span class="line"></span><br><span class="line">最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，</span><br><span class="line">找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。</span><br></pre></td></tr></table></figure>

<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">固定分区和动态分区的折中方法</span><br><span class="line">当需要为进程分配一个长度为n的存储空间时:</span><br><span class="line">首先计算一个 i 值，使 2 ^ (i－1) &lt; n ≤ 2 ^ i，</span><br><span class="line">然后在空闲分区大小为2 ^ i的空闲分区链表中查找。</span><br><span class="line">若找到，即把该空闲分区分配给进程。</span><br><span class="line">否则，表明长度为2 ^ i的空闲分区已经耗尽，则在分区大小为2 ^ (i ＋ 1)的空闲分区链表中寻找。</span><br><span class="line">若存在 2 ^ (i ＋ 1)的一个空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙伴，其中的一个分区用于配，</span><br><span class="line">而把另一个加入分区大小为2 ^ i的空闲分区链表中。</span><br><span class="line">若大小为2 ^ (i ＋ 1)的空闲分区也不存在，则需要查找大小为2 ^ (i ＋ 2)的空闲分区， 若找到则对其进行两次分割：</span><br><span class="line">第一次，将其分割为大小为 2 ^ (i ＋ 1)的两个分区，一个用于分配，一个加入到大小为 2^(i ＋ 1)的空闲分区链表中；</span><br><span class="line">第二次，将第一次用于分配的空闲区分割为 2^i的两个分区，一个用于分配，一个加入到大小为 2^i的空闲分区链表中。</span><br><span class="line">若仍然找不到，则继续查找大小为 2 ^ (i ＋ 3)的空闲分区，以此类推。</span><br></pre></td></tr></table></figure>

<h3 id="内存紧缩（地址变换）"><a href="#内存紧缩（地址变换）" class="headerlink" title="内存紧缩（地址变换）"></a>内存紧缩（地址变换）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将各个占用分区向内存一端移动, 然后将各个空闲分区合并成为一个空闲分区。</span><br></pre></td></tr></table></figure>

<h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引入覆盖 (overlay)技术的目标是在较小的可用内存中运行较大的程序。</span><br><span class="line">这种技术常用于多道程序系统之中，与分区式存储管理配合使用。</span><br></pre></td></tr></table></figure>

<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交换 (swapping)技术在多个程序并发执行时，可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程），</span><br><span class="line">或读人保存在外存中而处于就绪状态的程序。交换单位为整个进程的地址空间。交换技术常用于多道程序系统或小型分时系统中，</span><br><span class="line">因为这些系统大多采用分区存储管理方式。与分区式存储管理配合使用又称作“对换”或“滚进／滚出” (roll-in／roll-out)。</span><br><span class="line">暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），</span><br><span class="line">而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，</span><br><span class="line">并将该进程送到就绪队列（换入swap in）。</span><br></pre></td></tr></table></figure>

<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="页式和段式存储管理"><a href="#页式和段式存储管理" class="headerlink" title="页式和段式存储管理"></a>页式和段式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">地址空间：将源程序经过编译后得到的目标程序，</span><br><span class="line">存在于它所限定的地址范围内，这个范围称为地址空间。地址空间是逻辑地址的集合。</span><br><span class="line"></span><br><span class="line">存储空间：指主存中一系列存储信息的物理单元的集合，</span><br><span class="line">这些单元的编号称为物理地址存储空间是物理地址的集合。</span><br><span class="line"></span><br><span class="line">根据分配时所采用的基本单位不同，可将离散分配的管理方式分为以下三种：</span><br><span class="line">页式存储管理、段式存储管理和段页式存储管理。其中段页式存储管理是前两种结合的产物。</span><br></pre></td></tr></table></figure>

<h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">将程序的逻辑地址空间划分为固定大小的页(page)，</span><br><span class="line">而物理内存划分为同样大小的页框(page frame)。</span><br><span class="line">程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。</span><br><span class="line">该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。</span><br><span class="line">在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）</span><br><span class="line"></span><br><span class="line">没有外碎片，每个内碎片不超过页</span><br><span class="line">一个程序不必连续存放。</span><br><span class="line">便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。</span><br></pre></td></tr></table></figure>

<h3 id="页式管理的数据结构"><a href="#页式管理的数据结构" class="headerlink" title="页式管理的数据结构"></a>页式管理的数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在页式系统中，指令所给出的地址分为两部分：逻辑页号和页内地址。</span><br><span class="line">原理：</span><br><span class="line">CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，</span><br><span class="line">将物理页框号与页内地址相加形成物理地址</span><br><span class="line">逻辑页号，页内偏移地址－&gt;查进程页表，得物理页号－&gt;物理地址</span><br><span class="line"></span><br><span class="line">若给定一个逻辑地址为A，页面大小为L，则</span><br><span class="line">页号P&#x3D;INT[A&#x2F;L]，页内地址W&#x3D;A  MOD  L</span><br><span class="line">物理地址：物理块号 * 页面大小+ 页内偏移&#x3D; 28683</span><br></pre></td></tr></table></figure>

<h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">页面是主存物理空间中划分出来的等长的固定区域。分页方式的优点是页长固定，因而便于构造页表、易于管理，且不存在外碎片。</span><br><span class="line">但分页方式的缺点是页长与程序的逻辑大小不相关。例如，某个时刻一个子程序可能有一部分在主存中，另一部分则在辅存中。</span><br><span class="line">这不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。</span><br><span class="line"></span><br><span class="line">另一种划分可寻址的存储空间的方法称为分段。段是按照程序的自然分界划分的长度可以动态改变的区域。</span><br><span class="line">通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。</span><br><span class="line"></span><br><span class="line">作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例程序段、数据段等。每个段都从0开始编址，</span><br><span class="line">并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。</span><br><span class="line">整个作业的地址空间是二维的。</span><br><span class="line"></span><br><span class="line">每个程序设置一个段表，段表的每一个表项对应一个段，每个表项至少包括三个字段：</span><br><span class="line">有效位（指明该段是否已经调入主存）、段起址(该段在实存中的首地址)和段长（记录该段的实际长度）。</span><br><span class="line"></span><br><span class="line">绝对地址&#x3D;根据段号找到段表中的起始地址+段内地址 (如果段内地址超过限长则产生“地址越界”程序性中断事件达到存储保护)</span><br></pre></td></tr></table></figure>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">已知逻辑空间地址为2^m个字节（也就是说逻辑地址的长度是m位），</span><br><span class="line">已知页大小是2^n字节。那么一共可以有2^(m-n)个页。</span><br><span class="line">因此页码部分会占m-n位，之后的n位，用来存储页偏移。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举个例子， 页大小为4B，而逻辑内存为32B（8页），</span><br><span class="line">逻辑地址0的页号为0，页号0对应帧5，</span><br><span class="line">因此逻辑地址映射为物理地址5*4+0&#x3D;20。逻辑地址3映射物理地址5*4+3&#x3D;23。</span><br><span class="line">逻辑地址13(4*3+1，页号为3，偏移为1，因为帧号为5)，映射到物理地址21。</span><br><span class="line">13 &#x2F; 4 &#x3D; 3</span><br><span class="line">13 mod 4 &#x3D; 1</span><br><span class="line">5 * 4 + 1 &#x3D; 21</span><br><span class="line"></span><br><span class="line">页式的逻辑地址是连续的，段式的逻辑地址可以不连续</span><br><span class="line">页式的地址是一维的，段式的地址是二维的</span><br><span class="line">分页是操作系统进行的，分段是用户确定的</span><br><span class="line"></span><br><span class="line">段页式管理中，地址映像表是每个进程一张段表，每个段一张页表</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">woyao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://chenwoyao.github.io/2021/04/23/操作系统/内存管理/">https://chenwoyao.github.io/2021/04/23/操作系统/内存管理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chenwoyao.github.io">woyao的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-607541e3279cfc8b" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"><i class="fa fa-chevron-left">  </i><span>文件管理</span></a></div><div class="next-post pull-right"><a href="/2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/"><span>进程和线程和协程</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '428a1dc9101af973234b',
  clientSecret: 'c3ee519e5e2db3e4e3c0025a9b332dd76f7c29f2',
  repo: 'ChenWoyao.github.io',
  owner: 'ChenWoyao',
  admin: 'ChenWoyao',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2021 By woyao</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>