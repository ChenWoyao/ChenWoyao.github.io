<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker教程系列六</title>
      <link href="2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/"/>
      <url>2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="#readme">docker概念</a></li><li><a href="#build">手动从镜像运行一个容器</a></li><li><a href="#build">使用dockerfile打包镜像</a></li><li><a href="#build">使用compose部署多容器应用</a></li><li><a href="#build">给docker加上数据持久</a></li><li><a href="#build">docker持续集成和部署</a></li><li><a href="#build">docker在服务器部署</a></li></ul><h2 id="docker在服务器部署"><a href="#docker在服务器部署" class="headerlink" title="docker在服务器部署"></a>docker在服务器部署</h2>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列五</title>
      <link href="2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/"/>
      <url>2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="#readme">docker概念</a></li><li><a href="#build">手动从镜像运行一个容器</a></li><li><a href="#build">使用dockerfile打包镜像</a></li><li><a href="#build">使用compose部署多容器应用</a></li><li><a href="#build">给docker加上数据持久</a></li><li><a href="#build">docker持续集成和部署</a></li><li><a href="#build">docker在服务器部署</a></li></ul><h2 id="给docker加上数据持久"><a href="#给docker加上数据持久" class="headerlink" title="给docker加上数据持久"></a>给docker加上数据持久</h2>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列四</title>
      <link href="2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/"/>
      <url>2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="#readme">docker概念</a></li><li><a href="#build">手动从镜像运行一个容器</a></li><li><a href="#build">使用dockerfile打包镜像</a></li><li><a href="#build">使用compose部署多容器应用</a></li><li><a href="#build">给docker加上数据持久</a></li><li><a href="#build">docker持续集成和部署</a></li><li><a href="#build">docker在服务器部署</a></li></ul><h2 id="使用compose部署多容器应用"><a href="#使用compose部署多容器应用" class="headerlink" title="使用compose部署多容器应用"></a>使用compose部署多容器应用</h2><h3 id="compose介绍"><a href="#compose介绍" class="headerlink" title="compose介绍"></a>compose介绍</h3><h3 id="compose安装"><a href="#compose安装" class="headerlink" title="compose安装"></a>compose安装</h3><h3 id="compose使用"><a href="#compose使用" class="headerlink" title="compose使用"></a>compose使用</h3><h3 id="compose详解"><a href="#compose详解" class="headerlink" title="compose详解"></a>compose详解</h3><h3 id="重新构建镜像"><a href="#重新构建镜像" class="headerlink" title="重新构建镜像"></a>重新构建镜像</h3><h3 id="开发期间使用共享目录"><a href="#开发期间使用共享目录" class="headerlink" title="开发期间使用共享目录"></a>开发期间使用共享目录</h3><h3 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h3>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列三</title>
      <link href="2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/"/>
      <url>2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="#readme">docker概念</a></li><li><a href="#build">手动从镜像运行一个容器</a></li><li><a href="#build">使用dockerfile打包镜像</a></li><li><a href="#build">使用compose部署多容器应用</a></li><li><a href="#build">给docker加上数据持久</a></li><li><a href="#build">docker持续集成和部署</a></li><li><a href="#build">docker在服务器部署</a></li></ul><h2 id="使用dockerfile打包镜像"><a href="#使用dockerfile打包镜像" class="headerlink" title="使用dockerfile打包镜像"></a>使用dockerfile打包镜像</h2><pre><code>上一篇文章，我们实现了在一个基础的ubuntu镜像中运行我们的程序。但是运行程序的过程手动执行行命令式一件很麻烦的事情。接下来我们又把执行的命令协程了脚本，提高了一定的效率。但是如果要启动多个容器，我们的自制脚本每次都要重新安装配置一次这个过程是很耗时的。有没有更简单的办法呢？有的下面介绍dockerfile.</code></pre><h3 id="dockerfile介绍"><a href="#dockerfile介绍" class="headerlink" title="dockerfile介绍"></a>dockerfile介绍</h3><pre><code>docker 可以让我们自行编写配置文件（名为Dockerfile）来构建一个镜像,这样我们就可以轻松地从自定义构建的镜像中启动多个容器, 所以在实际使用中，我们会把整个程序打包成一个新的docker. 也就是说把所得配置操作，启动运行操作都写到自己的自定义的镜像配置文件中，这样生成的镜像实例(容器)只管运行就好了。不需要额外配置</code></pre><h3 id="关于镜像相关的命令"><a href="#关于镜像相关的命令" class="headerlink" title="关于镜像相关的命令"></a>关于镜像相关的命令</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用下面的命令查看本机存储的镜像 (包括下载的和构建的)</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker image rm &lt;webimage&gt;</span><br><span class="line">or</span><br><span class="line">docker rmi -f &lt;webimage&gt;</span><br><span class="line"><span class="comment"># 构建镜像, -t表示镜像的名字和标签，.代表当前的工作目录</span></span><br><span class="line">docker build -t webimage .</span><br></pre></td></tr></table></figure></code></pre><h3 id="使用dockerfile构建的镜像启动容器"><a href="#使用dockerfile构建的镜像启动容器" class="headerlink" title="使用dockerfile构建的镜像启动容器"></a>使用dockerfile构建的镜像启动容器</h3><pre><code>下面是对dockerfile文件中内容的解释<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在dockerfile文件中 #是注释</span></span><br><span class="line"><span class="comment"># FROM用于指定构建镜像使用的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN 用于在构建镜像的时候在镜像中执行命令</span></span><br><span class="line"><span class="comment"># 这里我们安装python3 和 flask web 框架</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip2 insatll flask</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY 相当于命令的 docker cp</span></span><br><span class="line"><span class="comment"># 把本机当前目录下的app.py文件拷贝到镜像的 /code/app.py</span></span><br><span class="line"><span class="comment"># 和docker cp 不同的是， COPY 会自动创建镜像中不存在的目录, 比如/code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR 用于指定从镜像启动的容器内的工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 用于指定容器运行后要执行的命令和参数列表</span></span><br><span class="line"><span class="comment"># 这样从本镜像启动容器后会自动执行 python3 app.py 这个命令</span></span><br><span class="line"><span class="comment"># 由于我们已经用WORDKDIR指定了容器的工作目录</span></span><br><span class="line"><span class="comment"># 所以以下的命令都是在 /code 下执行的</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><ol><li>当前目录下创建app.py文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from Dockerfile&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li>当前目录下创建Dockerfile文件<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install flask</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为使用了docker build -t webimage .</span></span><br><span class="line"><span class="comment"># 指明了镜像的工作目录是当前目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li>打开终端输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令中参数 -t webimage 指定了镜像的名字为 webimage</span></span><br><span class="line"><span class="comment"># 这个名字可以用于在之后从镜像启动容器</span></span><br><span class="line"><span class="comment"># 最后那个 . 用来指定构建镜像时候的工作目录为本机当前目录</span></span><br><span class="line">docker build -t webimage .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用下面的命令查看本机存储的镜像 (包括下载的和构建的)</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -p 8000:5000 --name demo webimage</span><br></pre></td></tr></table></figure></li><li>在浏览器输入: localhost:8000</li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列二</title>
      <link href="2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/"/>
      <url>2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="#readme">docker概念</a></li><li><a href="#build">手动从镜像运行一个容器</a></li><li><a href="#build">使用dockerfile打包镜像</a></li><li><a href="#build">使用compose部署多容器应用</a></li><li><a href="#build">给docker加上数据持久</a></li><li><a href="#build">docker持续集成和部署</a></li><li><a href="#build">docker在服务器部署</a></li></ul><h2 id="手动从镜像运行一个容器"><a href="#手动从镜像运行一个容器" class="headerlink" title="手动从镜像运行一个容器"></a>手动从镜像运行一个容器</h2><h3 id="手动启动一个容器"><a href="#手动启动一个容器" class="headerlink" title="手动启动一个容器"></a>手动启动一个容器</h3><pre><code>手动在本地电脑的docker容器中运行一个web应用<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令启动一个docker容器</span></span><br><span class="line">docker run -d -t -p 8000:5000 --name demo ubuntu:18.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这条命令的解释</span></span><br><span class="line">-d 的意思是让容器在后台运行</span><br><span class="line">-t 极少能用到，用于让一个空白的Ubuntu镜像在后台运行</span><br><span class="line">-p 用于指定端口映射，表示在本机访问8000会被自动转到容器中5000端口</span><br><span class="line">   必须保证本机没有其他应用程序占用了8000端口，否则这里会失败</span><br><span class="line">--name demo 制定了容器的名字是demo</span><br><span class="line">ubuntu:18.04 是启动容器时用的镜像名, docker会自动从镜像服务器去下载这个镜像</span><br></pre></td></tr></table></figure></code></pre><h3 id="启动容器常见的问题"><a href="#启动容器常见的问题" class="headerlink" title="启动容器常见的问题"></a>启动容器常见的问题</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个端口为3456的进程</span></span><br><span class="line">docker run -t -d -p 3456:5000 --name <span class="built_in">test</span> ubuntu:18.04</span><br><span class="line"><span class="comment"># 报错1，端口被占用，删除test容器来不安比3456端口的占用</span></span><br><span class="line">docker rm -f <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 报错2，名字已存在, 那么改名字, 也可以用上面的删除容器命令</span></span><br><span class="line">docker run -t -d -p 3456:5000 --name test1 ubuntu:18.04</span><br></pre></td></tr></table></figure></code></pre><h3 id="关于容器相关的命令"><a href="#关于容器相关的命令" class="headerlink" title="关于容器相关的命令"></a>关于容器相关的命令</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最新指定数量的容器的状态</span></span><br><span class="line">docker ps -n 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止容器</span></span><br><span class="line">docker stop &lt;container id&gt;/&lt;container name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对终止运行的容器重启, 容器id通过docker ps查询</span></span><br><span class="line">docker start &lt;container id&gt;/&lt;container name&gt;</span><br></pre></td></tr></table></figure></code></pre><h3 id="在容器中安装必备软件"><a href="#在容器中安装必备软件" class="headerlink" title="在容器中安装必备软件"></a>在容器中安装必备软件</h3><pre><code>启动容器以后，说明了运行了一个镜像实例，比如ubuntu:18.04镜像生成的test容器。这个容器目前有了ubuntu操作系统的文件管理功能，内存管理功能，进程调度等功能。现在还需要拥有python3, pip 环境, apt工具包。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -t -p 8000:5000 --name unbuntu:18.04</span><br><span class="line"><span class="comment"># 下载apt工具包</span></span><br><span class="line">docker <span class="built_in">exec</span> demo apt update</span><br><span class="line">docker <span class="built_in">exec</span> apt -y install python3 python3-pip</span><br><span class="line"><span class="comment"># 安装flask库</span></span><br><span class="line">docker <span class="built_in">exec</span> demo pip3 install flask</span><br></pre></td></tr></table></figure></code></pre><h3 id="在容器中运行程序"><a href="#在容器中运行程序" class="headerlink" title="在容器中运行程序"></a>在容器中运行程序</h3><pre><code>上面说过，使用docker的目的就是软件应用带环境安装。现在环境好了，需要运行软件应用<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo 容器中创建/code目录</span></span><br><span class="line">docker <span class="built_in">exec</span> demo mkdir /code</span><br><span class="line"><span class="comment"># cp参数把当前文件夹的a.py拷贝到demo容器的/code/a.py</span></span><br><span class="line">docker cp a.py demo:/code/a.py</span><br><span class="line"><span class="comment"># 运行demo容器中的a.py</span></span><br><span class="line">docker <span class="built_in">exec</span> demo python3 /code/a.py</span><br></pre></td></tr></table></figure></code></pre><h3 id="用脚本的方式配置容器，然后运行脚本配置并开启新容器"><a href="#用脚本的方式配置容器，然后运行脚本配置并开启新容器" class="headerlink" title="用脚本的方式配置容器，然后运行脚本配置并开启新容器"></a>用脚本的方式配置容器，然后运行脚本配置并开启新容器</h3><pre><code>之前的一系列命令有些繁琐, 其实更好的方式是在宿主机写脚本，然后cp到docker容器中直接运行.具体操作看实例操作</code></pre><h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><ol><li>在当前目录下创建a.py文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from Docker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认端口5000</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li>在当前目录下创建install.sh文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install.sh</span></span><br><span class="line">apt update</span><br><span class="line">apt -y install python3 python3-pip</span><br><span class="line">pip3 install flask</span><br></pre></td></tr></table></figure></li><li>在当前目录下创建run.sh文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run.sh</span></span><br><span class="line"><span class="built_in">cd</span> /code</span><br><span class="line">python3 a.py</span><br></pre></td></tr></table></figure></li><li>打开终端，输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -t -p 8000:5000 --name unbuntu:18.04</span><br><span class="line"><span class="comment"># demo 容器中创建/code目录</span></span><br><span class="line">docker <span class="built_in">exec</span> demo mkdir /code</span><br><span class="line">docker cp install.sh <span class="string">&quot;demo:/code/install.sh&quot;</span></span><br><span class="line">docker cp run.sh <span class="string">&quot;demo:/code/run.sh&quot;</span></span><br><span class="line">docker cp a.py <span class="string">&quot;demo:/code/a.py&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> demo bash /code/install.sh</span><br><span class="line">docker <span class="built_in">exec</span> demo bash /code/run.sh</span><br></pre></td></tr></table></figure></li><li>打开浏览器输入：localhost:8000/</li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列一</title>
      <link href="2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/"/>
      <url>2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="#readme">docker概念</a></li><li><a href="#build">手动从镜像运行一个容器</a></li><li><a href="#build">使用dockerfile打包镜像</a></li><li><a href="#build">使用compose部署多容器应用</a></li><li><a href="#build">给docker加上数据持久</a></li><li><a href="#build">docker持续集成和部署</a></li><li><a href="#build">docker在服务器部署</a></li></ul><h2 id="docker概念篇"><a href="#docker概念篇" class="headerlink" title="docker概念篇"></a>docker概念篇</h2><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>官方解释：通过对应用的封装、分发、部署、运行 生命周期进行管理，达到应用组件级别的“一次封装，到处运行”。<br>大白话：在以前一个软件应用在不同机器上运行，都需要对操作系统设置，各种库和组装单独下载，配置好环境变量。才能运行的起来。这种模式很不好，首先老旧的模块和当前环境不兼容就”gg思密达了”. 于是就有了软件应用带环境安装的解决方案。然后就出现了<code>虚拟机的方案</code>。但是虚拟机<strong>资源占用多</strong>，<strong>冗余步骤多</strong>，<strong>启动慢</strong>。既然虚拟机方案不好，那么革命的变更就出现了<code>linux容器方案</code>。关于<code>linux容器方案</code>的介绍:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux 容器不是模拟一个完整的操作系统，而是对进程(一个正在运行的应用)进行隔离。</span><br><span class="line">在正常进程的外面套了一个容器。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。另外容器也属于一个进程。</span><br></pre></td></tr></table></figure><p>具有<strong>启动快</strong>，<strong>占用资源少</strong>，<strong>体积小</strong>。docker属于<code>linux容器</code>的一种封装。是目前最流行的<code>linux容器方案</code>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="centOs系统"><a href="#centOs系统" class="headerlink" title="centOs系统:"></a>centOs系统:</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 添加docker稳定版本的yum软件源</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">// 安装docker</span><br><span class="line">sudo yum install -y docker-ce</span><br><span class="line"></span><br><span class="line">// 确定docker服务启动正常</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h4 id="macOs系统"><a href="#macOs系统" class="headerlink" title="macOs系统:"></a>macOs系统:</h4><p><a href="https://www.runoob.com/docker/macos-docker-install.html">参考macos系统docker的安装</a></p><h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p><a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac">docker安装官网</a></p><h3 id="docker镜像-docker-image"><a href="#docker镜像-docker-image" class="headerlink" title="docker镜像(docker image)"></a>docker镜像(docker image)</h3><p>Docker把应用程序及其依赖，打包在image文件里面。docker image 一个只读的模板, 创建Docker容器的基础。镜像相当于光盘，光盘里存储的数据是只读的，不会被更改</p><h3 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h3><p>容器是从镜像创建的应用运行实例, 一个镜像可以生成多个容器，每个容器之间，容器与宿主机之间都是相互隔离的，容器可以快速方便的运行，也可以方便的删除</p><h3 id="docker的优势"><a href="#docker的优势" class="headerlink" title="docker的优势"></a>docker的优势</h3><ol><li><p>同一环境，标准化部署 ubntu centos 等服务器的安装运行环境是不一样的<br>要使用某些新版的软件需要自行编译，非常繁琐</p></li><li><p>解决复杂的依赖问题<br>比如两个微服务 2个不同的依赖互相冲突</p></li><li><p>隔离应用的运行环境<br>比如redis获取服务器权限的漏洞</p></li><li><p>轻量级的虚拟环境，相比虚拟机而言开销小速度快</p></li><li><p>统一的服务管理<br> 不同的服务有不同的管理工具和方式<br> 如果使用了docker则统一用docker管理</p></li><li><p>dockerhub 上有许多高价值的镜像可以直接使用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react的hooks教程</title>
      <link href="2021/04/16/react%E7%9A%84hooks%E6%95%99%E7%A8%8B/"/>
      <url>2021/04/16/react%E7%9A%84hooks%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="这是一篇react的hooks教程"><a href="#这是一篇react的hooks教程" class="headerlink" title="这是一篇react的hooks教程"></a>这是一篇react的hooks教程</h2><p>另外欢迎大家访问<a href="https://chenwoyao.github.io/categories/">我的博客</a></p><h2 id="react-hooks-与-class-Component-的区别"><a href="#react-hooks-与-class-Component-的区别" class="headerlink" title="react hooks 与 class Component 的区别"></a><code>react hooks</code> 与 <code>class Component</code> 的区别</h2><ul><li>写法更加简洁，不再需要写冗长的生命周期函数</li><li><code>class Componet hoc</code> 的阅读让人看起来不易理解, 在组件之间复用状态逻辑很难.</li></ul><h2 id="hooks-使用规则"><a href="#hooks-使用规则" class="headerlink" title="hooks 使用规则"></a><code>hooks</code> 使用规则</h2><ul><li>只能在<strong>函数最外层</strong>调用 Hook。不要在循环、条件判断或者子函数中调用。</li><li>只能在<strong>React的函数组件中调用</strong>Hook。不要在其他JavaScript函数中调用。除了自定义的hook以外</li></ul><h2 id="react-hooks-常见的api使用"><a href="#react-hooks-常见的api使用" class="headerlink" title="react hooks 常见的api使用"></a><code>react hooks</code> 常见的api使用</h2><h3 id="useState-用法"><a href="#useState-用法" class="headerlink" title="useState 用法"></a><code>useState</code> 用法</h3><blockquote><p>identity: <code>const [state, setState] = useState(initialState)</code></p></blockquote><p><code>useState</code>的作用是在react函数组件中添加state的hook。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line">function Count() &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - count &lt;&#x3D;&gt; this.state.count, setCount &lt;&#x3D;&gt; this.setState</span><br><span class="line">        - setCount 支持两种写法 setCount(count + 1) or setCount(preState &#x3D;&gt; preState + 1)</span><br><span class="line">        第一种写法是一种异步机制，会将短时间内的多个setCount合并成一个方法，第二种写法是为了不使用第一种的合并机制。</span><br><span class="line">    *&#x2F;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    return &lt;div onClick&#x3D;&#123;setCount(pre &#x3D;&gt; pre + 1)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useEffect-用法"><a href="#useEffect-用法" class="headerlink" title="useEffect 用法"></a><code>useEffect</code> 用法</h3><blockquote><p>identity: <code>useEffect(callBack:clearCallBack, [deps])</code></p></blockquote><p><code>useEffect</code>的作用是在函数组件中执行副作用操作, 等价于在ComponetDidMount，ComponentDidUpdate, ComponentWillUnmount 三个函数的组合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - useEffect接受一个callBack参数和数组参数</span><br><span class="line">        - 数组中的值作为依赖，数组中的值发生变化的时候，callBack会重新调用。等价于ComponentDidUpdate</span><br><span class="line">        - callBack可以return一个clearCallBack,在组件卸载的时候调用clearCallBack。等价于ComponentWillUnmount</span><br><span class="line">        - useEffect默认会在render流程执行完以后，在调用callBack。等价于ComponetDidMount</span><br><span class="line">    *&#x2F;</span><br><span class="line">    const [isonline, setIsOnline] &#x3D; useState(false);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [isonline])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useContext-用法"><a href="#useContext-用法" class="headerlink" title="useContext 用法"></a><code>useContext</code> 用法</h3><p><code>useContext</code>的作用是接受一个context对象，并返回该context的当前值。主要用于深层级的组件通讯。需要和React.createContext配合使用<br>context的值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt;的 value prop决定。另外value的值更新会引起调用了uesContext的组件重新渲染。</p><blockquote><p>注意调用useContext的组件即使用了React.memo进行声明，也会重新渲染。因此需要使用<a href="https://github.com/facebook/react/issues/15156">memoization</a>来进行优化.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext, Children, useContext, useMemo &#125; from &#39;react&#39;</span><br><span class="line">const GlobalContext &#x3D; React.createContext()</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">    const data &#x3D; useContext(GlobalContext)</span><br><span class="line">    &#x2F;&#x2F; memoization 写法</span><br><span class="line">    return useMemo(() &#x3D;&gt; &#123;</span><br><span class="line">        return &lt;div&gt;&#123;data.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;, [data.name])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Parent() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;Parent&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;GlobalContext.Provider value&#x3D;&#123;&#123;name: &#39;woyao&#39;&#125;&#125;&gt;</span><br><span class="line">                &lt;Child &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;GlobalContext.Provider&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="useRef-用法"><a href="#useRef-用法" class="headerlink" title="useRef 用法"></a><code>useRef</code> 用法</h3><p><code>useRef</code>返回一个可变的ref对象，<code>ref.current</code>在组件内是一个全局常量。相当于在组件外写了一个全局常量。也就是说每次重新渲染函数组件时，返回的ref对象都是同一个。 常用于<em>访问Dom</em>,<em>当做全局变量</em>。</p><blockquote><p><em>访问 Dom</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef &#125; from &#39;react&#39;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    const inputElement &#x3D; useRef(null)</span><br><span class="line">    const btnClick &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class="line">        inputElement.current.focus()</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &lt;input ref&#x3D;&#123;inputElement&#125; &#x2F;&gt;</span><br><span class="line">            &lt;button ref&#x3D;&#123;btn&#125; onClick&#x3D;&#123;btnClick&#125;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><em>当做全局变量</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef, useEffect, useState &#125; from &#39;react&#39;</span><br><span class="line">function usePrevious(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 每次重新渲染，都会执行useRef,</span><br><span class="line">    const ref &#x3D; useRef()</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - 不设置依赖，每次reRender都会重新执行</span><br><span class="line">        - 能够返回上一次渲染之前value是什么值</span><br><span class="line">        - 注意是先执行return, 在执行useEffect</span><br><span class="line">    *&#x2F;</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        ref.current &#x3D; value</span><br><span class="line">    &#125;)</span><br><span class="line">    return ref.current</span><br><span class="line">&#125;</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0)</span><br><span class="line">    const preCount &#x3D; usePrevious(count)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;previous: &#123;preCount&#125; &lt;&#x2F;p&gt;</span><br><span class="line">            &lt;p&gt;now: &#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useImperativeHandle-用法"><a href="#useImperativeHandle-用法" class="headerlink" title="useImperativeHandle 用法"></a><code>useImperativeHandle</code> 用法</h3><blockquote><p>identity: <code>useImperativeHandle(ref, createHandle, [deps])</code></p></blockquote><p><code>useImperativeHandle</code>可以让你在使用<code>ref</code>时自定义暴露给父组件的实例值, 与<code>forwardRef</code>一起使用. 让你能够父组件调用子组件的方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef, useImperativeHandle, forwardRef &#125; from &#39;react&#39;</span><br><span class="line">function MyInput(props, ref) &#123;</span><br><span class="line">    const inputRef &#x3D; useRef()</span><br><span class="line">    const childFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;hh&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        ref: ref实例</span><br><span class="line">        createHandle: 给ref实例绑上方法</span><br><span class="line">        [dps]: 当deps发生变化的时候, createHandle 重新执行</span><br><span class="line">    *&#x2F;</span><br><span class="line">    useImperativeHandle(ref, () &#x3D;&gt; (&#123;</span><br><span class="line">        focus: () &#x3D;&gt; &#123;</span><br><span class="line">            inputRef.current.focus()</span><br><span class="line">        &#125;,</span><br><span class="line">        childFunc</span><br><span class="line">    &#125;))</span><br><span class="line">    return &lt;input ref&#x3D;&#123;inputRef&#125; &#x2F;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    MyInput &#x3D; forwardRef(MyInput)</span><br><span class="line"></span><br><span class="line">    function App() &#123;</span><br><span class="line">        const myInputCoponent &#x3D; useRef()</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;MyInput ref&#x3D;&#123;myInputCoponent&#125; &#x2F;&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; myInputCoponent.current.childFunc() &#125;&#125;&gt; focus now &lt;&#x2F;button&gt;</span><br><span class="line">            &lt;&#x2F;&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="useReducer-用法"><a href="#useReducer-用法" class="headerlink" title="useReducer 用法"></a><code>useReducer</code> 用法</h3><blockquote><p>identity: <code>const [state, dispatch] = useReducer(reducer, initialArg, init)</code></p></blockquote><p><code>useReducer</code>是useState的替代方案，接受一个形如(state, action) =&gt; newState 的 reducer, 并返回<br>当前的state以及其配套的dispatch方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const initialState &#x3D; &#123;count: 0&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;increment&#39;:</span><br><span class="line">            return &#123;count: state.count + 1&#125;;</span><br><span class="line">        case &#39;decrement&#39;:</span><br><span class="line">            return &#123;count: state.count - 1&#125;;</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, initialState);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            Count: &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useMemo-用法"><a href="#useMemo-用法" class="headerlink" title="useMemo 用法"></a><code>useMemo</code> 用法</h3><blockquote><p>identity: <code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b])</code><br>newRenderTemplate = useMemo(() =&gt; renderTemplate(), [deps])</p></blockquote><p><code>useMemo</code>是减少组件渲染次数，优化组件性能的hook, 传入<code>useMemo</code>的函数会在渲染期间执行，请不要再函数<br>内部执行与渲染无关的操作，其实也就是只有依赖项发生变化才会生成新的memoizedValue。这样就减少了不必要的<br>渲染。一般用在组件中进行解耦操作，与这个逻辑渲染相关的逻辑发生变化就重新渲染，而不相关的就不会重新渲染。<br>大白话就是有一个count逻辑相关的渲染，还有一个和name相关的逻辑渲染。不要因为name的state属性变化导致<br>count的渲染函数也重新执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useMemo &#125; from &#39;react&#39;</span><br><span class="line">const log &#x3D; console.log.bind(console)</span><br><span class="line"></span><br><span class="line">function Child(props) &#123;</span><br><span class="line">    log(&#39;child render&#39;)</span><br><span class="line">    const [count, SetCount] &#x3D; useState(0)</span><br><span class="line">    const renderCountTemplate &#x3D; (count) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;count render&#39;)</span><br><span class="line">        return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            child, &#123;props.name&#125;</span><br><span class="line">            &#123;&#x2F;*</span><br><span class="line">                - 使用useMemo防止了不必要的渲染更新，不会因为与当前父组件的props发生变化就会重新对renderCountTemplate进行执行。</span><br><span class="line">            *&#x2F;&#125;</span><br><span class="line">            &#123; useMemo(() &#x3D;&gt; renderCountTemplate(count), [count])&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Child组件优化：组件内 prop，state 的值发生变化才会重新渲染。防止了父组件的更新，子组件也进行不必要的更新</span><br><span class="line">Child &#x3D; React.memo(Child)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">    log(&#39;parent render&#39;)</span><br><span class="line">    const [name, SetName] &#x3D; useState(&#39;&#39;)</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;parent, &#123;name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;input onChange&#x3D;&#123;(event) &#x3D;&gt; SetName(event.target.value)&#125; &#x2F;&gt;</span><br><span class="line">            &lt;Child name&#x3D;&#123;name&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useCallback-用法"><a href="#useCallback-用法" class="headerlink" title="useCallback 用法"></a><code>useCallback</code> 用法</h3><blockquote><p>identity: <code>const memoizedCallback = useCallback(() =&gt; &#123; doSomething(a, b); &#125;, [a, b]);</code></p></blockquote><p><code>useCallback</code>是减少组件渲染次数，优化组件性能的hook, 与<code>useMemo</code>类似。回调函数仅在某个依赖项改变时才会更新<br>常用在对事件函数中匿名函数的处理。当然能用到useMemo的地方，useCallback也可以用到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useCallback, useState &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">const [ count, setCount ] &#x3D; useState(0)</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    &lt;!--</span><br><span class="line">        - 防止了每次count发生变化，导致的重新渲染，都需要重新生成一个新的匿名函数</span><br><span class="line">        - 也就是说 () &#x3D;&gt; &#123;setCount(count + 1)&#125; 这个匿名函数不需要再从新的内存空间中创建</span><br><span class="line">     --&gt;</span><br><span class="line">    return &lt;div onClick&#x3D;&#123;useCallback(() &#x3D;&gt; setCount(count+1), [])&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useLayoutEffect-用法"><a href="#useLayoutEffect-用法" class="headerlink" title="useLayoutEffect 用法"></a><code>useLayoutEffect</code> 用法</h3><p><code>useLayoutEffect</code> 官方解释说它会在所有的DOM变更之后同步调用effect，可能<code>useEffect</code>是在所有的DOM变更之后异步调用effect吧.</p><ul><li>可以使用它来读取 DOM 布局并同步触发重渲染</li><li>在浏览器执行绘制之前，<code>useLayoutEffect</code>内部的更新计划将被同步刷新。</li><li>这么说吧，我也不太<code>useLayoutEffect</code>的区别。有下面一段代码可以参考一下。估计在使用<code>useEffect</code>的时候带来了页面的抖动问题的时候就使用<code>useLayoutEffect</code>。网上的解释:layout会在组件树构建完毕或者刷新完毕后同步立刻执行。effect会等其他js代码执行完毕后执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (count &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      const randomNum &#x3D; 10 + Math.random()*200</span><br><span class="line">      setCount(10 + Math.random()*200);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>效果如下:<br><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0dcc15419be9?imageslim" alt="结果"></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (count &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      const randomNum &#x3D; 10 + Math.random()*200</span><br><span class="line">      setCount(10 + Math.random()*200);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>效果如下:<br><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0dca05c0fa6e?imageslim" alt="结果"></p></blockquote></li></ul><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><ul><li><a href="#useDidUpdate">useDidUpdate</a></li><li><a href="#useGlobalReduxHook">useGlobalReduxHook</a></li></ul><div id="useDidUpdate"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个ComponentDidUpdate的简易实现</span><br><span class="line">import &#123; useEffect, useRef &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">function useDidUpdate(cb, deps&#x3D;[]) &#123;</span><br><span class="line">  const didMount &#x3D; useRef(false)</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (!didMount.current) &#123;</span><br><span class="line">      didMount.current &#x3D; true</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, deps)</span><br><span class="line"></span><br><span class="line">  return didMount.current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="useGlobalReduxHook"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个redux的简易实现</span><br><span class="line">import React, &#123; useContext, useReducer &#125; from &#39;react&#39;</span><br><span class="line">const initState &#x3D; &#123; count: 0 &#125;</span><br><span class="line">const Store &#x3D; React.createContext(initStore)</span><br><span class="line">const MapActionReducer &#x3D; &#123;</span><br><span class="line">    [&#39;ADD&#39;](state, action) &#123;</span><br><span class="line">        return &#123;...state, count: action.payload&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reducer &#x3D; (initState, action) &#x3D;&gt; &#123;</span><br><span class="line">    return MapActionReducer[action.type](initState, action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function useGlobalReduxHook(Component) &#123;</span><br><span class="line">    &#x2F;&#x2F; dispatch触发state发生变化，会重新执行渲染</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, Store)</span><br><span class="line">    return (</span><br><span class="line">        &lt;Store.Provider value&#x3D;&#123;state, dispatch&#125; &#x2F;&gt;</span><br><span class="line">            &lt;Component &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Store.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法教程</title>
      <link href="2021/04/14/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/"/>
      <url>2021/04/14/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="这是一篇markdwon语法教程"><a href="#这是一篇markdwon语法教程" class="headerlink" title="这是一篇markdwon语法教程"></a>这是一篇markdwon语法教程</h1><p>另外欢迎大家访问<a href="https://chenwoyao.github.io/categories/">我的博客</a></p><h1 id="关于markdown"><a href="#关于markdown" class="headerlink" title="关于markdown"></a>关于markdown</h1><p>markdown 是一种文本，类似于html， 比起html文本，语法标签更少，很容易上手写作</p><h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 标题1</span></span><br><span class="line"><span class="section">## 标题2</span></span><br><span class="line"><span class="section">### 标题3</span></span><br><span class="line"><span class="section">#### 标题4</span></span><br><span class="line"><span class="section">##### 标题5</span></span><br><span class="line"><span class="section">###### 标题6</span></span><br><span class="line">快捷键: h1 + tap</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">有序列表:</span><br><span class="line"><span class="bullet">1.</span> list1</span><br><span class="line"><span class="bullet">2.</span> list2</span><br><span class="line"></span><br><span class="line">无序列表:</span><br><span class="line"><span class="bullet">-</span> list1</span><br><span class="line"><span class="bullet">*</span> list2</span><br><span class="line"><span class="bullet">    -</span> list3</span><br><span class="line"><span class="bullet">    -</span> list4</span><br><span class="line"></span><br><span class="line">任务列表：</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成任务1</span><br><span class="line"><span class="bullet">-</span> [x] 已完成任务1</span><br><span class="line"></span><br><span class="line">引用列表:</span><br><span class="line"><span class="quote">&gt; ref1</span></span><br><span class="line"><span class="quote">&gt; ref2</span></span><br></pre></td></tr></table></figure><h2 id="文字样式语法"><a href="#文字样式语法" class="headerlink" title="文字样式语法"></a>文字样式语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**加粗** [快捷键：Ctrl+B]</span><br><span class="line">__加粗2__</span><br><span class="line"></span><br><span class="line">_倾斜_</span><br><span class="line">*倾斜*</span><br><span class="line"></span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><h2 id="图片显示或者链接显示"><a href="#图片显示或者链接显示" class="headerlink" title="图片显示或者链接显示"></a>图片显示或者链接显示</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">链接语法：</span><br><span class="line">[<span class="string">我的github</span>](<span class="link">https://github.com/ChenWoyao</span>)</span><br><span class="line"></span><br><span class="line">图片语法：</span><br><span class="line">![<span class="string">alt帅哥</span>](<span class="link">./static/img/bg.png</span>)</span><br></pre></td></tr></table></figure><h2 id="表格语法"><a href="#表格语法" class="headerlink" title="表格语法"></a>表格语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|th1|th2|th3|</span><br><span class="line">|--|--|--|</span><br><span class="line">|td1|td2|td3|</span><br><span class="line">|td1|td2|   td3|</span><br></pre></td></tr></table></figure><h2 id="代码块语法"><a href="#代码块语法" class="headerlink" title="代码块语法"></a>代码块语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">表示一个代码片段：</span><br><span class="line"><span class="code">`from urllib import parse`</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span>from urllib import parse<span class="xml"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">表示一段代码块：(diff, js, php, sh 等语法都支持)</span><br><span class="line"><span class="code">``` js</span></span><br><span class="line"><span class="code">    data = &#123;</span></span><br><span class="line"><span class="code">        &#x27;a&#x27;: &#x27;test&#x27;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">` ``</span></span><br><span class="line"><span class="code">&lt;pre&gt;</span></span><br><span class="line"><span class="code">    data = &#123;</span></span><br><span class="line"><span class="code">        &#x27;a&#x27;: &#x27;test&#x27;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&lt;/pre&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释--&gt;</span><br><span class="line">快捷键: cmd + /</span><br></pre></td></tr></table></figure><h2 id="目录与锚点"><a href="#目录与锚点" class="headerlink" title="目录与锚点"></a>目录与锚点</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">展示目录树的写法：</span><br><span class="line">├── [<span class="string">README.md</span>](<span class="link">#readme</span>)</span><br><span class="line">├── [<span class="string">build</span>](<span class="link">#build</span>)</span><br><span class="line">│ ├── [<span class="string">webpack.base.js</span>](<span class="link">#webpack-base</span>)</span><br><span class="line">│ ├── [<span class="string">webpack.client.js</span>](<span class="link">#webpack-client</span>)</span><br><span class="line">│ └── [<span class="string">webpack.server.js</span>](<span class="link">#webpack-server</span>)</span><br><span class="line">├── [<span class="string">package-lock.json</span>](<span class="link">#package-lock</span>)</span><br><span class="line">├── [<span class="string">package.json</span>](<span class="link">#package.json</span>)</span><br><span class="line">└── [<span class="string">src</span>](<span class="link">#src</span>)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [<span class="string">README.md</span>](<span class="link">#readme</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">build</span>](<span class="link">#build</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.base.js</span>](<span class="link">#webpack-base</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.client.js</span>](<span class="link">#webpack-client</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.server.js</span>](<span class="link">#webpack-server</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">package-lock.json</span>](<span class="link">#package-lock</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">package.json</span>](<span class="link">#package.json</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">src</span>](<span class="link">#src</span>)</span><br><span class="line"></span><br><span class="line">对应的锚点dom:</span><br><span class="line"><span class="section">## readme</span></span><br><span class="line"><span class="section">## build</span></span><br><span class="line"><span class="section">### webpack-base</span></span><br><span class="line"><span class="section">### webpack-client</span></span><br><span class="line"><span class="section">### webpack-server</span></span><br><span class="line"><span class="section">## ackage-lock</span></span><br><span class="line"><span class="section">## package.json</span></span><br><span class="line"><span class="section">## src</span></span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;readme&quot;</span>&gt;</span></span> readme <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span> build <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">------------- 【快捷键：hr后敲Tab】</span><br><span class="line">*************</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\sum<span class="emphasis">_&#123;i=1&#125;^n a_</span>i=0$$</span><br><span class="line"></span><br><span class="line">$$f(x<span class="emphasis">_1,x_</span>x,\ldots,x<span class="emphasis">_n) = x_</span>1^2 + x<span class="emphasis">_2^2 + \cdots + x_</span>n^2$$</span><br><span class="line"></span><br><span class="line">$$\sum^&#123;j-1&#125;<span class="emphasis">_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_</span>&#123;kj&#125; z<span class="emphasis">_k&#125;$$</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> markdown语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
