<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二进制算法</title>
      <link href="2021/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95/"/>
      <url>2021/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>^</code>: 两位相同为0，两位不同为1<br><code>&amp;</code>: 两位全为1则为1，否则为0<br><code>|</code>: 两位中有一位有1则为1，否则为0<br><code>&gt;&gt;</code>: 右移操作相当于除2<br><code>&lt;&lt;</code>: 左移操作相当于乘2</p><h1 id="十进制小数转换为二进制小数规定"><a href="#十进制小数转换为二进制小数规定" class="headerlink" title="十进制小数转换为二进制小数规定"></a>十进制小数转换为二进制小数规定</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 整数部分: 除2取余，逆序排列</span><br><span class="line">## 小数部分: 乘2取整，顺序排列</span><br><span class="line">例子: 173.8125</span><br><span class="line">173 &#x3D;&gt; 101011101</span><br><span class="line">0.8125 &#x3D;&gt; 0.1101</span><br><span class="line">0.8125 * 2 &#x3D; 1.6250(取1) &#x3D;&gt; 0.625 * 2 &#x3D;&gt; 1.2500(取1) &#x3D;&gt; 0.25 * 2 &#x3D;&gt; 0.5(取0) &#x3D;&gt; 0.5 * 2 &#x3D; 1.0(取1)</span><br></pre></td></tr></table></figure><h1 id="负数的二进制表示方法"><a href="#负数的二进制表示方法" class="headerlink" title="负数的二进制表示方法"></a>负数的二进制表示方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">负数以源码的补码表示</span><br><span class="line">负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1</span><br><span class="line">例：-10</span><br><span class="line">       &#x3D;&gt; 10000000 00000000 00000000 00001010 -10的源码</span><br><span class="line">       &#x3D;&gt; 11111111 11111111 11111111 11110101 -10的反码</span><br><span class="line">       &#x3D;&gt; 11111111 11111111 11111111 11110110 -10的反码加一</span><br></pre></td></tr></table></figure><h1 id="左移和右移运算-gt-gt-lt-lt"><a href="#左移和右移运算-gt-gt-lt-lt" class="headerlink" title="左移和右移运算 (&gt;&gt;, &lt;&lt;)"></a>左移和右移运算 (&gt;&gt;, &lt;&lt;)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 二进制的左移: m左移n位，最左边的n位被丢弃，右边补上n个0</span><br><span class="line">&#x2F;&#x2F; 二进制的右移：m右移n位，最右边的n位被丢弃，</span><br><span class="line">&#x2F;&#x2F; 如果数字是一个无符号数值，则用0填补最左边的n位，如果是负数，最左边补n个1</span><br><span class="line">00001010 &gt;&gt; 2 &#x3D;&gt; 00000010</span><br><span class="line">10001010 &gt;&gt; 3 &#x3D;&gt; 11110001</span><br></pre></td></tr></table></figure><h1 id="异或运算符（-）的操作"><a href="#异或运算符（-）的操作" class="headerlink" title="异或运算符（^）的操作"></a>异或运算符（^）的操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使特定位翻转</span><br><span class="line">与0相异或, 保留原值</span><br></pre></td></tr></table></figure><h1 id="无符号右移运算符（-gt-gt-gt-）"><a href="#无符号右移运算符（-gt-gt-gt-）" class="headerlink" title="无符号右移运算符（&gt;&gt;&gt;）"></a>无符号右移运算符（&gt;&gt;&gt;）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运算符把 expression1 的各个位向右移 expression2 指定的位数。右移后左边空出的位用零来填充。移出右边的位被丢弃</span><br></pre></td></tr></table></figure><h1 id="js中操作符的妙用"><a href="#js中操作符的妙用" class="headerlink" title="js中操作符的妙用"></a>js中操作符的妙用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1. 使用&amp;运算符判断一个数的奇偶</span><br><span class="line">例子： 2 &amp; 1 &#x2F;&#x2F; 0</span><br><span class="line">2. 使用~, &gt;&gt;, &lt;&lt;, &gt;&gt;&gt;, |来取整</span><br><span class="line">例子： 6.83 &gt;&gt; 0 &#x2F;&#x2F; 6</span><br><span class="line">3. 使用^来完成值交换</span><br><span class="line">例子： var a &#x3D; 5</span><br><span class="line">      var b &#x3D; 8</span><br><span class="line">      a ^&#x3D; b</span><br><span class="line">      b ^&#x3D; a</span><br><span class="line">      a ^&#x3D; b</span><br><span class="line">      console.log(a)   &#x2F;&#x2F; 8</span><br><span class="line">      console.log(b)   &#x2F;&#x2F; 5</span><br><span class="line">4. 使用&amp;, &gt;&gt;, | 来完成rgb值和16进制颜色值之间的转换</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">    #ffffff rgb(255, 255, 255)</span><br><span class="line">    8位表示一个色度</span><br><span class="line">    function hexToRGB(hex) &#123;</span><br><span class="line">        var hexx &#x3D; hex.replace(&#39;#&#39;, &#39;0x&#39;)</span><br><span class="line">        var r &#x3D; hexx &gt;&gt; 16</span><br><span class="line">        var g &#x3D; hexx &gt;&gt; 8 &amp; 0xff  &#x2F;&#x2F; 去掉r 00 00 ff ff  &amp; 00 00 00 ff</span><br><span class="line">        var b &#x3D; hexx &amp; 0xff      &#x2F;&#x2F; 去掉r, g &#x2F;&#x2F; 00 ff ff ff ff &amp; 00 00 00 ff</span><br><span class="line">        return &#96;rgb($&#123;r&#125;, $&#123;g&#125;, $&#123;b&#125;)&#96;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function RGBToHex(rgb) &#123;</span><br><span class="line">        var rgbArr &#x3D; rgb.split(&#x2F;[^\d]+&#x2F;)</span><br><span class="line">        var color &#x3D; rgbArr[1]&lt;&lt;16 | rgbArr[2]&lt;&lt;8 | rgbArr[3]</span><br><span class="line">        return &#39;#&#39;+ color.toString(16)</span><br><span class="line">    &#125;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">5: (A|B|C|D) &amp; D &#x3D; D, 这个可以检测一个集合中是否有该值存在。</span><br></pre></td></tr></table></figure><h1 id="常见的算法题"><a href="#常见的算法题" class="headerlink" title="常见的算法题"></a>常见的算法题</h1><h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p><a href="https://leetcode-cn.com/problems/hamming-distance/">题目来源</a></p><blockquote><p>思路:<br>xor操作后，右移记录1的个数，右移为0就结束了循环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hammingDistance = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> xor = x ^ y, count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (xor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xor &amp; <span class="number">1</span>) count++</span><br><span class="line">        xor &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h2><p><a href="https://leetcode-cn.com/problems/counting-bits/">题目来源</a></p><blockquote><p>思路:<br>奇数最后一位为1，偶数最后一位为0.<br>所以偶数的右移1位，1的个数不变。<br>奇数右移1位，1个个数减一。<br>因此得出：<br>如果 xx 是偶数，bit[x] = bit[x / 2]<br>如果 xx 是奇数，bit[x] = bit[x / 2] + 1<br>=&gt;<br>bix[x] = bit[x &gt;&gt; 1] + (x &amp; 1)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countBits = <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(num + <span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        result[i] = result[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><p><a href="https://leetcode-cn.com/problems/single-number/">题目来源</a></p><blockquote><p>思路:<br>因为其他的元素都出现过两次，那么两个相同元素进行异或就是0<br>然后0 ^ 只出现一次的数字值不会变: 0000000 ^ 0110101 = 0110101</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleNumber = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc ^= num, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="关于队列"><a href="#关于队列" class="headerlink" title="关于队列"></a>关于队列</h1><p>是一种先进先出的数据结构，在js中删除用shift，添加用push<br>因为队列的数据结构实现过于节点我就不写了</p><h1 id="关于栈"><a href="#关于栈" class="headerlink" title="关于栈"></a>关于栈</h1><p>是一种后进先出的数据结构，在js中删除用pop，添加用push<br>因为栈的数据结构实现过于节点我就不写了</p><h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><blockquote><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">题目来源</a><br>[[5, 0]]-&gt; [[5, 0], [null], [5, 2],  null, [4, 4],  [7, 1]]<br>-&gt; [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4],  [7, 1]]</p></blockquote><p>pepole = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>=&gt; 先h排序, 再k排序<br>=&gt; [[4, 4], [5, 2], [5, 0], [6, 1], [7, 1], [7, 0]]<br>7个人没有排序<br>=&gt; [null, null, null, null, null, null]<br>h:4的person前面有比我高的有4个，那么我肯定是是未排坑位的第四个坑<br>=&gt; [null, null, null, null, [4, 4], null]<br>h:5的person,前面2个比我高，那么我肯定是是未排坑位的第三个坑<br>=&gt; [[5, 0], null, [5, 2], null, [4, 4], null]<br>h:6,前面有一个人比我高， 那么我肯定是是未排坑位的第二个坑<br>=&gt; [[5, 0], null, [5, 2], null, [4, 4], null]<br>=&gt; [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]<br>思路:<br>step1: 先h排序，再k排序<br>一次遍历排序后得数组，按照它的k属性，和未排坑位，决定他的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reconstructQueue = <span class="function"><span class="params">pepole</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> people = pepole.sort(<span class="function">(<span class="params">cur, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">0</span>] - next[<span class="number">0</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> - (cur[<span class="number">1</span>] - next[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[<span class="number">0</span>] - next[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> unsorted = <span class="keyword">new</span> <span class="built_in">Array</span>(people.length).fill(<span class="literal">null</span>)</span><br><span class="line">    pepole.forEach(<span class="function"><span class="params">person</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> [height, position] = person.slice()</span><br><span class="line">        <span class="comment">// log(&#x27;height, position&#x27;, height, position)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; unsorted.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!unsorted[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">                    unsorted[i] = person</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                position -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// log(&#x27;unsorted&#x27;, unsorted)</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> unsorted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h2 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h2><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h2 id="去出重复字母"><a href="#去出重复字母" class="headerlink" title="去出重复字母"></a>去出重复字母</h2><h2 id="用栈实现队列，用队列实现栈"><a href="#用栈实现队列，用队列实现栈" class="headerlink" title="用栈实现队列，用队列实现栈"></a>用栈实现队列，用队列实现栈</h2><h2 id="合并k个排序链表"><a href="#合并k个排序链表" class="headerlink" title="合并k个排序链表"></a>合并k个排序链表</h2><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组和堆</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E5%92%8C%E5%A0%86/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E5%92%8C%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><blockquote><p><a href="https://leetcode-cn.com/problems/rotate-image/">题目来源</a><br>思路:<br>matrix = Array.from(new Array(m), (item) =&gt; new Array(n).fill(0))<br>所谓的原地右旋: 列-&gt;行 对应的 x : y -&gt; y : x 但是值确倒叙了<br>(0, 2) -&gt; (1, 2) -&gt; (2, 2)  =&gt;  (2, 0) -&gt; (2, 1) -&gt; (2, 2)<br>3 -&gt; 6 -&gt; 9 =&gt; 9 -&gt; 6 -&gt; 3 =&gt; (0, 2) === (2, 2) 所以应该是 x : y -&gt; y : (n - x - 1)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">const</span> matrix_new = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix_new[j][n - i - <span class="number">1</span>] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[i][j] = matrix_new[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h2><blockquote><p><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">题目来源</a><br>思路:<br>遍历数组中每一项，然后在对自己遍历一次求乘积. 然而哈哈哈，超时了。 n * n的算法复杂度都不让通过。想想也是要不太简单了。因此面试的时候如果遇到一个题目觉得太简单，一定要想一想是不是踩坑了^_^<br>正解:</p><ol><li>初始化两个空数组 L 和 R。对于给定索引 i，L[i] 代表的是 i 左侧所有数字的乘积，R[i] 代表的是 i 右侧所有数字的乘积。</li><li>我们需要用两个循环来填充 L 和 R 数组的值。对于数组 L，L[0] 应该是 1，因为第一个元素的左边没有元素。对于其他元素：L[i] = L[i-1] * nums[i-1]。<br>同理，对于数组 R，R[length-1] 应为 1。length 指的是输入数组的大小。其他元素：R[i] = R[i+1] * nums[i+1]。</li><li>当 R 和 L 数组填充完成，我们只需要在输入数组上迭代，且索引 i 处的值为：L[i] * R[i]。</li><li>总结，庶竭驽钝。</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> productExceptSelf = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> L = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length)</span><br><span class="line">    <span class="keyword">const</span> R = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length)</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">            L[i] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L[i] = L[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = R.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === R.length - <span class="number">1</span>) &#123;</span><br><span class="line">            R[i] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            R[i] = R[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        result[i] = L[i] * R[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><blockquote><p><a href="https://leetcode-cn.com/problems/3sum/">题目来源</a><br>思路：</p></blockquote><ol><li>排序</li><li>两数之和就是用集合，三数之和就是对剩余数组做2数之和，用一个指针指向剩余数组左边，一个指针指向剩余数组右边<br>(遍历的时候不需要对大于0的项进行处理)</li><li>左指针每次右移遇到重复的数字继续右移，左移遇到重复的继续左移<br>nums = [-1, 0, 1, 2, -1, -4]<br>// sort<br>nums = [-4, -1, -1, 0, 1, 2]<br>//<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> L = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> R = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.push([nums[i], nums[L], nums[R]]);</span><br><span class="line">                <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L + <span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R - <span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">                L++;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><h2 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h2><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h2><h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><h2 id="和为S的连续正整数序列"><a href="#和为S的连续正整数序列" class="headerlink" title="和为S的连续正整数序列"></a>和为S的连续正整数序列</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="关于树结构的基本知识"><a href="#关于树结构的基本知识" class="headerlink" title="关于树结构的基本知识"></a>关于树结构的基本知识</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">树中节点数 &#x3D; 总分叉数 + 1</span><br><span class="line">叶子节点的度数为0, 度就是指该节点的直接子节点有几个</span><br><span class="line">树的存储结构：&#123;</span><br><span class="line">    双亲表示法：</span><br><span class="line">    孩子表示法：</span><br><span class="line">    孩子兄弟表示法:</span><br><span class="line">&#125;</span><br><span class="line">完全二叉树：从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</span><br><span class="line"></span><br><span class="line">二叉树第i层最多有2^(i-1)个节点</span><br><span class="line">二叉树深度为k最多有2^k-1个节点</span><br><span class="line">二叉树的终端结点数为n1，度数为2的结点数为n2, 则n1 &#x3D; n2 + 1</span><br><span class="line">完全二叉树的结点数为n,则深度为lg2(n)+1</span><br></pre></td></tr></table></figure><h1 id="二叉树相关的题目"><a href="#二叉树相关的题目" class="headerlink" title="二叉树相关的题目"></a>二叉树相关的题目</h1><h1 id="二叉搜索树相关的题目"><a href="#二叉搜索树相关的题目" class="headerlink" title="二叉搜索树相关的题目"></a>二叉搜索树相关的题目</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>若它的左子树不为空，则左子树上所有节点的值均小于它的根结构的值<br>若它的右子树不为空，则右子树上所有节点的值均大于它的根结构的值<br>它左，右子树也分别是二叉排序树</p><p>二叉搜索树的中序遍历是一个有序数组</p><h1 id="平衡二叉树-AVL-相关的题目"><a href="#平衡二叉树-AVL-相关的题目" class="headerlink" title="平衡二叉树(AVL)相关的题目"></a>平衡二叉树(AVL)相关的题目</h1><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>是一种二叉搜索树，其中每一个节点的左子树和右子树的高度差至多等于1<br>也就是说二叉树上所有节点的平衡因子(BF:节点的左子树深度减去节点右子树深度)只可能是-1，0，1.</p><h2 id="AVL的结构代码"><a href="#AVL的结构代码" class="headerlink" title="AVL的结构代码"></a>AVL的结构代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class BitNode &#123;</span><br><span class="line">    construct(data, lchild, rchild) &#123;</span><br><span class="line">        this.bf &#x3D; 0 &#x2F;&#x2F; 节点的平衡因子</span><br><span class="line">        this.data &#x3D; data</span><br><span class="line">        this.lchild &#x3D; (lchild &#x3D;&#x3D;&#x3D; undefined ? lchild : null)</span><br><span class="line">        this.rightchild &#x3D; (rchild &#x3D;&#x3D;&#x3D; undefined ? rchild : null)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对以p为根的二叉排序树右旋操作，1. 平衡因子大于1需要右旋， 2. 使得平衡因子变成负数</span><br><span class="line">    R_Rotate(p) &#123;</span><br><span class="line">        &#x2F;&#x2F; p的左节点</span><br><span class="line">        const l &#x3D; p.lchild</span><br><span class="line">        &#x2F;&#x2F; 将原来p左节点的右子树变成p的左子树</span><br><span class="line">        p.lchild &#x3D; l.rchild</span><br><span class="line">        &#x2F;&#x2F; 旋转后原来p的左节点的右节点变成p</span><br><span class="line">        l.rchild &#x3D; p</span><br><span class="line">        &#x2F;&#x2F; p指向新的节点</span><br><span class="line">        p &#x3D; l</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 左旋操作</span><br><span class="line">    L_Rotate(p) &#123;</span><br><span class="line">        const r &#x3D; p.rchild</span><br><span class="line">        p.rchild &#x3D; r.lchild</span><br><span class="line">        r.lchild &#x3D; p</span><br><span class="line">        p &#x3D; r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将一颗二叉搜索树变成AVL的过程"><a href="#将一颗二叉搜索树变成AVL的过程" class="headerlink" title="将一颗二叉搜索树变成AVL的过程"></a>将一颗二叉搜索树变成AVL的过程</h2><p><img src="http://121.5.231.10:3000/alogrithm/avl/avl1.png" alt="avl1"><br><img src="http://121.5.231.10:3000/alogrithm/avl/avl2.png" alt="avl1"><br><img src="http://121.5.231.10:3000/alogrithm/avl/avl3.png" alt="avl1"><br><img src="http://121.5.231.10:3000/alogrithm/avl/avl4.png" alt="avl1"></p><h1 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h1><p>树节点的结构代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.left = (left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line">    <span class="built_in">this</span>.val = (val === <span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="built_in">this</span>.right = (right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">    <span class="built_in">this</span>.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> root = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">const</span> levels = [[root]]</span><br><span class="line">        <span class="keyword">let</span> result = [root]</span><br><span class="line">        <span class="keyword">while</span> (levels.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> level = levels.pop()</span><br><span class="line">            <span class="keyword">const</span> ans = []</span><br><span class="line">            <span class="keyword">while</span> (level.length) &#123;</span><br><span class="line">                <span class="keyword">const</span> node = level.pop()</span><br><span class="line">                node.left &amp;&amp; ans.push(node.left)</span><br><span class="line">                node.right &amp;&amp; ans.push(node.right)</span><br><span class="line">            &#125;</span><br><span class="line">            ans.length &amp;&amp; levels.push(ans) &amp;&amp; (result = result.concat(ans.slice()))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.reduce(<span class="function">(<span class="params">acc, node</span>) =&gt;</span></span><br><span class="line">            acc.concat([node ? node.val : <span class="string">&#x27;null&#x27;</span>]),</span><br><span class="line">            [])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><blockquote><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">题目来源</a><br>思路:<br>节点root1存在 &amp; 节点root2存在 =&gt; 两个相加<br>节点root1存在 | 节点root2存在 =&gt; root1 | root2<br>否则 =&gt; null</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeTrees = <span class="function">(<span class="params">root1, root2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> val = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root1 &amp;&amp; root2) &#123;</span><br><span class="line">        val = root1.val + root2.val</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1 || root2) &#123;</span><br><span class="line">        val = (root1 &amp;&amp; root1.val) || (root2 &amp;&amp; root2.val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">    <span class="keyword">const</span> root1l = root1 ? root1.left : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> root1r = root1 ? root1.right : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> root2l = root2 ? root2.left : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> root2r = root2 ? root2.right : <span class="literal">null</span></span><br><span class="line">    node.left = mergeTrees(root1l, root2l)</span><br><span class="line">    node.right = mergeTrees(root1r, root2r)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">题目来源</a><br>思路:<br>就是求一颗树的镜像<br>节点root存在左子树，将其左子树变成节点的右子树<br>节点root存在右子树，将其右子树变成节点的左子树</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invertTree = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || (!root.left &amp;&amp; !root.right)) <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">const</span> lchild = root.left</span><br><span class="line">    <span class="keyword">const</span> rchild = root.right</span><br><span class="line">    root.left = rchild</span><br><span class="line">    root.right = lchild</span><br><span class="line">    root.left &amp;&amp; invertTree(root.left)</span><br><span class="line">    root.right &amp;&amp; invertTree(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><blockquote><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">题目来源</a><br>思路:</p><ol><li>dfs深度遍历每条路径即可</li><li>层次遍历</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxDepth = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">const</span> goLevel = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">        path.push(node.val)</span><br><span class="line">        <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">            result = <span class="built_in">Math</span>.max(result, path.length)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一步往左走</span></span><br><span class="line">        node.left &amp;&amp; goLevel(node.left)</span><br><span class="line">        <span class="comment">// 本次的结果</span></span><br><span class="line">        node.left &amp;&amp; path.pop()</span><br><span class="line">        <span class="comment">// 下一步往右走</span></span><br><span class="line">        node.right &amp;&amp; goLevel(node.right)</span><br><span class="line">        <span class="comment">// 本次的结果</span></span><br><span class="line">        node.right &amp;&amp; path.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    goLevel(root)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><blockquote><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">题目来源</a><br>思路：<br>下一步按照有左选左，没左选右，并记录本次没有左选择的结果，没左没右就结束。<br>depth0:  有左选左，没左选右, 并记录<br>depth1:  有左选左，没左选右, 并记录<br>  .<br>  .<br>no choice: 结束</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderTraversal = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 本次决定下一步选择走左</span></span><br><span class="line">        node.left &amp;&amp; dfs(node.left)</span><br><span class="line">        path.push(node.val)</span><br><span class="line">        <span class="comment">// 本次决定下一步选择走右</span></span><br><span class="line">        node.right &amp;&amp; dfs(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><blockquote><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">题目来源</a><br>思路：<br>对每个节点做了如下处理：左子树变成右子树，右子树变成转变后右子树的最右节点, 该节点的左子树为空</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> searize = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">const</span> lchild = node.left</span><br><span class="line">        <span class="keyword">const</span> rchild = node.right</span><br><span class="line">        node.right = lchild</span><br><span class="line">        node.left = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">let</span> p = node</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right === <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line">            p = p.right</span><br><span class="line">        &#125;</span><br><span class="line">        p.right = rchild</span><br><span class="line">        searize(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">    searize(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从前序和中序遍历序列构造二叉树"><a href="#从前序和中序遍历序列构造二叉树" class="headerlink" title="从前序和中序遍历序列构造二叉树"></a>从前序和中序遍历序列构造二叉树</h2><blockquote><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">题目来源</a><br>思路: 分治法，拆拆拆。<br>前序可以得出数组首元素是根元素<br>中序可以得到左子树和右子树</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildTree = <span class="function">(<span class="params">preorder, inorder</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> nodeVal = preorder[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> index = inorder.indexOf(nodeVal)</span><br><span class="line">    inorder.indexOf(nodeVal)</span><br><span class="line">    node = <span class="keyword">new</span> TreeNode(nodeVal)</span><br><span class="line">    node.left = buildTree(preorder.slice(<span class="number">1</span>, index + <span class="number">1</span>), inorder.slice(<span class="number">0</span>, index))</span><br><span class="line">    node.right = buildTree(preorder.slice(index + <span class="number">1</span>), inorder.slice(index + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><blockquote><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">题目来源</a><br>思路1：<br>dfs的回溯能求出所有的组合然后对搜有的组合进行判断是否是二叉搜索树，这种显然很耗时间<br>而且特别复杂，在这里总结出了如果有很多种选择的可能，或者逻辑点很多的不要使用回溯，会头痛死<br>思路二:<br>看了官方的动态规划，嗐，感慨还是动态规划好。不要有了新欢就忘了旧爱…..<br>定义公式：<br>G(n): 长度为n的序列能构成的不同二叉搜索树的个数。<br>F(i,n): 以i为根，序列长度为n的不同二叉搜索树个数(1 &lt;= i &lt;= n)<br>则:<br>G(n) = F(1, n) + …. + F(n, n)<br>依次遍历{1..n},当以作为根节点时候将1…(i - 1)作为左子树，i + 1…n 作为右子树<br>其中: G(0)=1, G(1)=1<br>这个遍历的时候有F(i, n) = 左:G(i - 1) * 右: G(n - i)<br>因为：G(n) = F(1, n) + …. + F(n, n)， F(i, n) = G(i - 1) * G(n - i)<br>所以: G(n) = G(1 - 1) * G(n - 1) + … + G(n - 1) * G(0)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numTrees = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> G = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="number">0</span></span><br><span class="line">    G[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    G[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="comment">// 长度为i的集合 = 以j为根长度为i的总集合</span></span><br><span class="line">            <span class="comment">// G[i] = G[i] + F(j, i)</span></span><br><span class="line">            G[i] = G[i] + G[j - <span class="number">1</span>] * G[i - j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="二叉搜索树的第k个节点"><a href="#二叉搜索树的第k个节点" class="headerlink" title="二叉搜索树的第k个节点"></a>二叉搜索树的第k个节点</h2><h2 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h2><h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><h2 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h2><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><h2 id="二叉搜索树与查找表"><a href="#二叉搜索树与查找表" class="headerlink" title="二叉搜索树与查找表"></a>二叉搜索树与查找表</h2><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>思路:<br>每一次循环可以保证将一个最大的数放置末尾（一次至少能排一个）<br>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; list.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[i] &gt; list[j]) &#123;</span><br><span class="line">                [list[i], list[j]] = [list[j], list[i]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>思路:<br>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中<br>从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序<br>最开始已排序好的数组中只有一个元素</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> value = list[i]</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; list[j]) &#123;</span><br><span class="line">                list[j + <span class="number">1</span>] = list[j]</span><br><span class="line">                list[j] = value</span><br><span class="line">            &#125;</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>思路:<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。<br>相比于之前的插入排序的优化是减少了插入的移动次数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shellSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = list.length, gap = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 动态定义间隔序列</span></span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后还是做了间隔为1的插入排序，只是这个时候再插入基本不需要怎么移动了</span></span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 插入排序</span></span><br><span class="line">            temp = list[i]</span><br><span class="line">            <span class="keyword">let</span> j = i - gap</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list[j] &gt; temp) &#123;</span><br><span class="line">                    list[j + gap] = list[j]</span><br><span class="line">                    list[j] = temp</span><br><span class="line">                &#125;</span><br><span class="line">                j -= gap</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>思路:<br>一次遍历，每次确立第i位的元素是什么</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; list.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[j] &lt; list[i]) &#123;</span><br><span class="line">                [list[i], list[j]] = [list[j], list[i]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>思路:<br>从数列中挑出一个元素，称为 “基准”（pivot）<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面<br>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> mid = list[<span class="built_in">Math</span>.floor(list.length / <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">const</span> left = list.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item &lt;= mid &amp;&amp; index !== <span class="built_in">Math</span>.floor(list.length / <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">const</span> right = list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; mid)</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([mid]).concat(quickSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>思路:<br>一种分治法，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>, result = []</span><br><span class="line">        <span class="keyword">while</span> ((i &lt; left.length) &amp;&amp; (j &lt; right.length)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class="line">                result.push(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.concat(left.slice(i)).concat(right.slice(j))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list.length &lt; <span class="number">2</span>) <span class="keyword">return</span> list</span><br><span class="line">    <span class="comment">// 分成小问题,拆到只剩两个最小的序列</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(list.length / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> left = mergeSort(list.slice(<span class="number">0</span>, mid))</span><br><span class="line">    <span class="keyword">let</span> right = mergeSort(list.slice(mid))</span><br><span class="line">    <span class="comment">// 治</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>思路:<br>将数组变成大顶堆以后，只需要每次将堆首和末尾的最后一个元素交换，即可排序</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆调整</span></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function">(<span class="params">arr, i, len</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> root = i, left = <span class="number">2</span> * i + <span class="number">1</span>, right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[right]) &#123;</span><br><span class="line">        root = left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[root]) &#123;</span><br><span class="line">        root = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root !== i) &#123;</span><br><span class="line">        [arr[i], arr[root]] = [arr[root], arr[i]]</span><br><span class="line">        heapify(arr, root)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建大顶堆</span></span><br><span class="line"><span class="keyword">const</span> buildHeap = <span class="function">(<span class="params">arr, len</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从i=len/2开始，是因为大于len/2没有左和右节点</span></span><br><span class="line">    <span class="comment">// 另外需要从len / 2层往上走才行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i, len)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heapSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = list.length</span><br><span class="line">    buildHeap(list, len)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = list.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        [list[i], list[<span class="number">0</span>]] = [list[<span class="number">0</span>], list[i]]</span><br><span class="line">        len -= <span class="number">1</span></span><br><span class="line">        buildHeap(list, i, len)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表的结构"><a href="#链表的结构" class="headerlink" title="链表的结构"></a>链表的结构</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = (val === <span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="built_in">this</span>.next = (next === <span class="literal">undefined</span> ? <span class="literal">null</span> : next)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> stack = [<span class="built_in">this</span>.val]</span><br><span class="line">        <span class="keyword">let</span> p = <span class="built_in">this</span>.next</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            stack.push(p.val)</span><br><span class="line">            p = p.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><blockquote><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目来源</a><br>思路1: 分治法<br>对两个节点做如下处理</p><ol><li>当前节点变成下一个节点的下一节点</li><li>当前节点的next是null<br>思路2: 正常的迭代方法<br>依次遍历每个节点，对每个节点作如下处理<br>next = cur.next<br>cur.next = pre<br>pre = cur<br>cur = next</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="params">head</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head</span><br><span class="line">    <span class="comment">// 遍历到链表只有一个节点以后回退，也就是说下一步只剩一个节点就要回退了</span></span><br><span class="line">    <span class="keyword">let</span> p = reverseList(head.next)</span><br><span class="line">    <span class="comment">// 当前节点变成队尾</span></span><br><span class="line">    head.next.next = head</span><br><span class="line">    <span class="comment">// 当前节点的next是null</span></span><br><span class="line">    head.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseList1 = <span class="function"><span class="params">head</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = head, pre = <span class="literal">null</span>, next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        next = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><blockquote><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">题目来源</a><br>思路1：通过next创建一个新的链表，然后新链表与老链表做一一映射关系。f(old[n]) = f(new[n])<br>其实就是用一个映射表存储他们的映射关系就好，然后遍历映射表做处理即可</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">val, next, random</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    <span class="built_in">this</span>.next = next;</span><br><span class="line">    <span class="built_in">this</span>.random = random;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copyRandomList = <span class="function"><span class="params">head</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">let</span> p = head, pre = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// create new list and handle map for old list and new list</span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(p.val)</span><br><span class="line">        map.set(p, node)</span><br><span class="line">        pre &amp;&amp; (pre.next = node)</span><br><span class="line">        pre = node</span><br><span class="line">        p = p.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// log(&#x27;new list&#x27;, map.get(head))</span></span><br><span class="line">    <span class="comment">// traverse map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [oldNode, newNode] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">        <span class="keyword">let</span> key = oldNode.random</span><br><span class="line">        <span class="keyword">let</span> findNode = map.get(key)</span><br><span class="line">        newNode.random = findNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><blockquote><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">题目来源</a><br>思路：<br>两个都有序的话就很好弄了，两个一起遍历，一次比较</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeTwoLists = <span class="function">(<span class="params">l1, l2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> ListNode(<span class="built_in">Math</span>.min(l1.val, l2.val))</span><br><span class="line">        pre &amp;&amp; (pre.next = node)</span><br><span class="line">        !pre &amp;&amp; (head = node)</span><br><span class="line">        pre = node</span><br><span class="line">        l1.val &lt; l2.val ? (l1 = l1.next) : (l2 = l2.next)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pre) <span class="keyword">return</span> l1</span><br><span class="line">        pre.next = l1</span><br><span class="line">        pre = pre.next</span><br><span class="line">        l1 = l1.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pre) <span class="keyword">return</span> l2</span><br><span class="line">        pre.next = l2</span><br><span class="line">        pre = pre.next</span><br><span class="line">        l2 = l2.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表倒数第k个节点"><a href="#链表倒数第k个节点" class="headerlink" title="链表倒数第k个节点"></a>链表倒数第k个节点</h2><blockquote><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">题目来源</a><br>思路：<br>经典的双指针问题</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getKthFromEnd = <span class="function">(<span class="params">head, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head, slow = head</span><br><span class="line">    <span class="comment">// fast先跑</span></span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        fast = fast.next</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一起跑</span></span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        fast = fast.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="画圈中剩下的最后的数字"><a href="#画圈中剩下的最后的数字" class="headerlink" title="画圈中剩下的最后的数字"></a>画圈中剩下的最后的数字</h2><blockquote><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">题目来源</a><br>思路: 使用链表模拟即可<br>0-&gt;1-&gt;2-&gt;3-&gt;4 m = 2<br>1<br>3<br>0<br>4</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会超时</span></span><br><span class="line"><span class="keyword">const</span> lastRemaining1 = <span class="function">(<span class="params">n, m</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// create list ring</span></span><br><span class="line">    <span class="keyword">while</span> (start !== n) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> ListNode(start)</span><br><span class="line">        pre &amp;&amp; (pre.next = node)</span><br><span class="line">        !pre &amp;&amp; (head = node)</span><br><span class="line">        pre = node</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = head</span><br><span class="line">    <span class="comment">// 当只剩一个节点的时候，head === pre</span></span><br><span class="line">    <span class="comment">// count % m === 0 就说明要删除</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (head !== pre) &#123;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (count % m === <span class="number">0</span>) &#123;</span><br><span class="line">            pre.next = head.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = pre.next</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表1"><a href="#环形链表1" class="headerlink" title="环形链表1"></a>环形链表1</h2><blockquote><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">题目来源</a><br>思路：快慢指针，能相遇就是环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会超时</span></span><br><span class="line"><span class="keyword">const</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">let</span> slow = head</span><br><span class="line">    <span class="keyword">let</span> quick = head.next</span><br><span class="line">    <span class="keyword">while</span> ((quick !== slow)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!quick || !slow || !quick.next) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next</span><br><span class="line">        quick = quick.next.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (quick === slow) &#123;</span><br><span class="line">        result = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表2"><a href="#环形链表2" class="headerlink" title="环形链表2"></a>环形链表2</h2><blockquote><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">题目来源</a><br>思路：在这里快慢指针需要进行数学分析一般来说阻碍比较大<br>这里需要使用集合存储节点，当存在一个节点的下一个节点再集合里面说明是环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> detectCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> pos</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.has(head)) &#123;</span><br><span class="line">            pos = head</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(head)</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h1><p>从n个不同元素中，任取m个不同的元素按照一定的顺序排成一列,叫做从n个不同元素中取出m个元素的一个排列. 从n个不同元素中取出m(m≤n）个元素的所有排列的个数，叫做从n个不同元素中取出m个元素的排列数，用符号<code>A(n, m)</code>表示，此外规定<code>0! = 1</code><br><img src="https://bkimg.cdn.bcebos.com/formula/ac0926e610dce08b12a0c0c42b835cb0.svg" alt="计算公式"></p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>从n个不同元素中，任取m(m≤n）个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m≤n）个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。用符号<code>C(n,m)</code> 表示<code>C(n,m)=C(n,n-m)</code><br><img src="https://bkimg.cdn.bcebos.com/formula/620a7d43cbc2c75ca47802b017929910.svg" alt="计算公式"></p><h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><blockquote><p><a href="https://leetcode-cn.com/problems/subsets/">题目来源</a><br>思路:<br>深度:    选择<br>depth0: [1], []<br>depth1: [2], []<br>depth2: [3], []<br>depth3: back</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subsets = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="comment">// 当前路径</span></span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">depth</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 走到第nums.length的时候就不需要往下走了</span></span><br><span class="line">        <span class="keyword">if</span> (depth === nums.length) &#123;</span><br><span class="line">            result.push(path.slice())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 采用当前节点值并往下走</span></span><br><span class="line">        path.push(nums[depth])</span><br><span class="line">        dfs(depth + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 不采用当前值并往下走</span></span><br><span class="line">        path.pop()</span><br><span class="line">        dfs(depth + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><blockquote><p><a href="https://leetcode-cn.com/problems/permutations/">题目来源</a><br>思路:<br>[1, 2, 3] -&gt; [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]<br>深度:      选择:<br>depth0: [[1], [2], [3]] intersection used[]<br>depth1: [[1], [2], [3]] intersection used[choice1]<br>depth2: [[1], [2], [3]] intersection used[choice1, choice2]<br>depth3: 结束</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permute = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> used = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">depth</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth === nums.length) &#123;</span><br><span class="line">            result.push(path.slice())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used.has(i)) &#123;</span><br><span class="line">                used.add(i)</span><br><span class="line">                path.push(nums[i])</span><br><span class="line">                dfs(depth + <span class="number">1</span>)</span><br><span class="line">                used.delete(i)</span><br><span class="line">                path.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><blockquote><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">题目来源</a><br>思路:<br>n = 3 [“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>depth0:<br>        =&gt; 左 &amp;&amp; (left &lt; n) 或者 右 &amp;&amp; (right &lt; left)<br>depth1:<br>        =&gt; 左 &amp;&amp; (left &lt; n) 或者 右 &amp;&amp; (right &lt; left)<br>depth2:<br>        =&gt; 左 &amp;&amp; (left &lt; n) 或者 右 &amp;&amp; (right &lt; left)<br>  .<br>  .<br>  .<br>depth2n:  结束</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generateParenthesis = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function"><span class="params">depth</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth === <span class="number">2</span> * n) &#123;</span><br><span class="line">            result.push(path.slice().join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">            path.push(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            left++</span><br><span class="line">            dfs(depth + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">            left--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">            right++</span><br><span class="line">            path.push(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            dfs(depth + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><blockquote><p><a href="https://leetcode-cn.com/problems/combination-sum/">题目来源</a><br>思路:<br>candidates = [2,3,6,7], target = 7, result = [[7], [2,2,3]]<br>candidates = [2,3,5], target = 8, result = [[2,2,2,2],[2,3,3],[3,5]]<br>depth0: choice in candidates<br>depth1: choice in candidates<br>  .<br>  .<br>depth sum &gt; target: back</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combinationSum = <span class="function">(<span class="params">candidates, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">depth</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> cp = path.slice()</span><br><span class="line">        <span class="keyword">const</span> sum = cp.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc + item, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            result.push(cp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            path.push(candidates[i])</span><br><span class="line">            dfs(depth + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">return</span> result.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val = item.sort().join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (!set.has(val)) &#123;</span><br><span class="line">            set.add(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>(<a href="https://leetcode-cn.com/problems/restore-ip-addresses/">https://leetcode-cn.com/problems/restore-ip-addresses/</a>)</p><h2 id="图像渲染"><a href="#图像渲染" class="headerlink" title="图像渲染"></a>图像渲染</h2><p>(<a href="https://leetcode-cn.com/problems/flood-fill/">https://leetcode-cn.com/problems/flood-fill/</a>)</p><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p>(<a href="https://leetcode-cn.com/problems/word-search/">https://leetcode-cn.com/problems/word-search/</a>)</p><h2 id="复原IP地址-1"><a href="#复原IP地址-1" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>(<a href="https://leetcode-cn.com/problems/restore-ip-addresses/">https://leetcode-cn.com/problems/restore-ip-addresses/</a>)</p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>(<a href="https://leetcode-cn.com/problems/n-queens/">https://leetcode-cn.com/problems/n-queens/</a>)</p><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>(<a href="https://leetcode-cn.com/problems/number-of-islands/">https://leetcode-cn.com/problems/number-of-islands/</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ensure = <span class="function"><span class="keyword">function</span>(<span class="params">condition, message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">        log(<span class="string">&#x27;*** 测试失败&#x27;</span>, message)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log(<span class="string">&#x27;+++ 测试成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = []</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">101</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">hash</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> val = s[i]</span><br><span class="line">            <span class="keyword">let</span> v = val.charCodeAt(<span class="number">0</span>)</span><br><span class="line">            v = v * <span class="number">10</span> ** i</span><br><span class="line">            r += v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">index</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> l = <span class="built_in">this</span>.hash(s)</span><br><span class="line">        <span class="keyword">let</span> i = l % <span class="built_in">this</span>.size</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">this</span>.index(key)</span><br><span class="line">        <span class="keyword">let</span> tag = <span class="built_in">this</span>.data[index]</span><br><span class="line">        <span class="keyword">let</span> ans = []</span><br><span class="line">        <span class="keyword">if</span> (tag === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            ans.push([key, value])</span><br><span class="line">            <span class="built_in">this</span>.data[index] = ans</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">let</span> status = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">for</span> (i; i &lt; tag.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> k = t[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> (k === key) &#123;</span><br><span class="line">                    t[<span class="number">1</span>] = value</span><br><span class="line">                    status = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!status &amp;&amp; i === tag.length) &#123;</span><br><span class="line">                tag.push([key, value])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = value</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">this</span>.index(key)</span><br><span class="line">        <span class="keyword">let</span> tags = <span class="built_in">this</span>.data[index]</span><br><span class="line">        <span class="keyword">if</span> (tags === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> tag <span class="keyword">of</span> tags) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag[<span class="number">0</span>] === key) &#123;</span><br><span class="line">                result = tag[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">this</span>.index(key)</span><br><span class="line">        <span class="keyword">let</span> tags = <span class="built_in">this</span>.data[index]</span><br><span class="line">        <span class="keyword">if</span> (tags === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> tag <span class="keyword">of</span> tags) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tag[<span class="number">0</span>] === key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><h2 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h2><h2 id="宝石与石头"><a href="#宝石与石头" class="headerlink" title="宝石与石头"></a>宝石与石头</h2>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><h2 id="搜索二维矩阵II"><a href="#搜索二维矩阵II" class="headerlink" title="搜索二维矩阵II"></a>搜索二维矩阵II</h2><h2 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h2><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><h2 id="最小k个数"><a href="#最小k个数" class="headerlink" title="最小k个数"></a>最小k个数</h2><h2 id="排序矩阵查找"><a href="#排序矩阵查找" class="headerlink" title="排序矩阵查找"></a>排序矩阵查找</h2><h2 id="漂亮数组"><a href="#漂亮数组" class="headerlink" title="漂亮数组"></a>漂亮数组</h2><h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><h2 id="为运算表达式设计优先级"><a href="#为运算表达式设计优先级" class="headerlink" title="为运算表达式设计优先级"></a>为运算表达式设计优先级</h2>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><blockquote><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">题目来源</a><br>思路：<br>dp(i)(j) 从左上角到(i, j)位置的最小路径<br>// 当只能竖着走的时候<br>dp(i)(0) = dp(i-1)(0) + grid[i][0]<br>// 当只能横着走的时候<br>dp(0)(i) = dp(0)(i-1) + grid[0][i]<br>// 当上一步可以通过向右或者向下到当前(i, j)位置的时候<br>dp(i)(j) = Math.min(dp(i-1)(j), dp(i)(j-1)) + grid[i][j]</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> minPathSum = <span class="function"><span class="params">grid</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid === <span class="literal">null</span> || grid.length === <span class="number">0</span> || grid[<span class="number">0</span>].length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> rows = grid.length</span><br><span class="line">    <span class="keyword">const</span> cols = grid[<span class="number">0</span>].length</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(rows), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(cols).fill(<span class="number">0</span>))</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; cols; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[rows - <span class="number">1</span>][cols - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h2 id="最长上升子序列-1"><a href="#最长上升子序列-1" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全简介</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="说说什么是SQL注入？如何防止SQL注入？"><a href="#说说什么是SQL注入？如何防止SQL注入？" class="headerlink" title="说说什么是SQL注入？如何防止SQL注入？"></a>说说什么是SQL注入？如何防止SQL注入？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">就是通过把&#96;SQL&#96;命令插入到&#96;Web&#96;表单递交或输入域名或页面请求的查询字符串，</span><br><span class="line">最终达到欺骗服务器执行恶意的SQL命令。</span><br><span class="line">因此永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。</span><br><span class="line">所谓的参数化查询（Parameterized Query 或 Parameterized Statement）是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数 (Parameter) 来给值。</span><br></pre></td></tr></table></figure><h1 id="说说XSS的原理及防范"><a href="#说说XSS的原理及防范" class="headerlink" title="说说XSS的原理及防范?"></a>说说XSS的原理及防范?</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击指的是攻击者往Web页面里插入恶意&#96;html&#96;标签或者javascript代码。</span><br><span class="line">因此代码里用户输入的地方和变量都需要仔细检查长度和对&quot;&lt;&quot;、&quot;&quot;&gt;&quot;、&quot;;&quot;、&quot;’&quot;等字符做过滤；</span><br><span class="line">其次任何内容写到页面之前都必须加以&#96;encode&#96;，避免不小心把&#96;html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS攻击。</span><br></pre></td></tr></table></figure><h1 id="跨站请求伪造-csrf"><a href="#跨站请求伪造-csrf" class="headerlink" title="跨站请求伪造 csrf"></a>跨站请求伪造 csrf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">攻击者盗用了你的身份，以你的名义发送恶意请求。</span><br><span class="line">要完成一次CSRF攻击，受害者必须依次完成两个步骤：</span><br><span class="line">a、登录受信任网站A，并在本地生成Cookie。</span><br><span class="line">b、在不登出A的情况下，访问危险网站B。</span><br><span class="line"></span><br><span class="line">网站A ：为恶意网站。</span><br><span class="line">网站B ：用户已登录的网站。</span><br><span class="line">当用户访问 A站 时，A站 私自访问 B站 的操作链接，模拟用户操作。</span><br><span class="line">设B站有一个删除评论的链接：http:&#x2F;&#x2F;b.com&#x2F;comment&#x2F;?type&#x3D;delete&amp;id&#x3D;81723</span><br><span class="line">A站 直接访问该链接，就能删除用户在 B站 的评论。</span><br><span class="line"></span><br><span class="line">解决办法: 使用验证码验证身份</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输层协议简介</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="tcp协议"><a href="#tcp协议" class="headerlink" title="tcp协议"></a>tcp协议</h1><p>该协议的作用是保证数据通信的完整性和可靠性，防止丢包。<br>特点如下:<br><strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>面向字节流的</strong>、<strong>有流量控制</strong>、<strong>阻塞控制</strong>、<strong>负载较高</strong></p><h1 id="upd协议"><a href="#upd协议" class="headerlink" title="upd协议"></a>upd协议</h1><p><strong>面向无连接的</strong>、<strong>不可靠的</strong>、<strong>面向数据报的</strong>、<strong>无流量控制</strong>、<strong>无阻塞控制</strong>、<strong>负载相对较低</strong></p><h1 id="tcp与udp的区别"><a href="#tcp与udp的区别" class="headerlink" title="tcp与udp的区别"></a>tcp与udp的区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）TCP协议在传送数据段的时候要给段标号；UDP协议不</span><br><span class="line">（2）TCP协议可靠；UDP协议不可靠</span><br><span class="line">（3）TCP协议是面向连接；UDP协议采用无连接</span><br><span class="line">（4）TCP协议负载较高，采用虚电路；UDP采用无连接</span><br><span class="line">（5）TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</span><br><span class="line">（6）TCP协议采用窗口技术和流控制</span><br></pre></td></tr></table></figure><h2 id="tcp的流量控制"><a href="#tcp的流量控制" class="headerlink" title="tcp的流量控制"></a>tcp的流量控制</h2><p>为了提高信道的利用率TCP协议不使用停止等待协议，而是使用滑动窗口协议(连续ARQ协议)<br>意思就是可以连续发出若干个分组然后等待确认,而不是发送一个分组就停止并等待该分组的确认。<br>而所谓流量控制就是让发送端发送的数据过多或者数据发送速率过快，接收端来不及处理，则会造成数据在接收端的丢弃。<br>利用滑动窗口（零窗口，坚持定时器）机制就可以实施流量控制。<br>关于滑动窗口机制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">接收端可以用大小为0的窗口(目前不能在接受数据了)通知发送端停止发送数据流。</span><br><span class="line">但是如果下一次窗口不为0的应答在传输过程丢失，发送者一直等待下去</span><br><span class="line">而接收者以为发送者已经收到该应答等待接收新数据，这样双方就相互等待，从而产生死锁。</span><br><span class="line">所以还需要用定时器机制处理，每当发送者收到一个零窗口的应答后就启动该计时器</span><br><span class="line">发送端定时发送探测报文段，接收端应答不为0，就继续定时发送，直到接收端缓存不为空。</span><br></pre></td></tr></table></figure><h2 id="tcp的阻塞控制"><a href="#tcp的阻塞控制" class="headerlink" title="tcp的阻塞控制"></a>tcp的阻塞控制</h2><p>为什么会产生TCP的阻塞呢, 其实就是发送端发送的报文速度要比接收端处理数据速率大。<br>TCP对于阻塞控制一共有四种算法，分别是<strong>慢开始</strong>，<strong>阻塞避免</strong>，<strong>快重传</strong>，<strong>快恢复</strong>四种算法。<br>由于需要考虑拥塞控制和流量控制两个方面的内容, 因此TCP的真正的发送窗口=min(rwnd, cwnd)(接受窗口, 拥塞窗口)</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>怎么知道接收方线路的理想速率是多少呢，需要慢启动慢慢试<br>始的时候，发送得较慢，然后根据丢包的情况调整速率，如果不丢包，就加快发送速度；如果丢包，就降低发送速度。</p><h3 id="阻塞避免"><a href="#阻塞避免" class="headerlink" title="阻塞避免"></a>阻塞避免</h3><p>到达阈值以后，加法增加。<br>从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，<br>但是cwnd不能一直这样无限增长下去，一定需要某个限制。<br>TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。<br>拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。<br>此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，<br>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p><p><img src="http://121.5.231.10:3000/computerNetwork/%E9%98%BB%E5%A1%9E%E6%9C%BA%E5%88%B6.jpg" alt="阻塞避免的图片"></p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>收到三次同样的ack以后，立即发送该syn报文，并启用快恢复<br>ack是指：一个确认消息，携带了期待要收到下一个数据包的编号和接收方的接收窗口的剩余容量<br><img src="http://121.5.231.10:3000/computerNetwork/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg" alt="快重传"></p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>如果发送方设置定时器超时，那么很可能是网络出现了拥塞，<br>致使TCP报文段在网络中的某处被丢弃。在这种情况下<br>开始门限值减半，然后使用阻塞避免的增加法</p><h2 id="面向连接的-tcp的三次握手）"><a href="#面向连接的-tcp的三次握手）" class="headerlink" title="面向连接的(tcp的三次握手）"></a>面向连接的(tcp的三次握手）</h2><p>序列号:seq, 确认号:ack, syn:报文<br>客户端发送SYN报文，置发序列号为X<br>服务端发送SYN+ACK报文，并置发序列号为Y，确认序列号X+1<br>客户端发送ACK报文，并置发序列号为Z，确认号Y+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一次握手：建立连接时，客户端A发送SYN包(SYN&#x3D;j)到服务器B，并进入SYN_SEND状态，等待服务器B确认。</span><br><span class="line"></span><br><span class="line">第二次握手：服务器B收到SYN包，必须确认客户A的SYN(ACK&#x3D;j+1)，同时自己也发送一个SYN包(SYN&#x3D;k)，即SYN+ACK包，此时服务器B进入SYN_RECV状态</span><br><span class="line"></span><br><span class="line">第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK(ACK&#x3D;k+1)，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</span><br></pre></td></tr></table></figure><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>主动发送Fin+Ack报文，并置发序列号为X<br>被发送方发送ACK报文，并只发送序列号为Z，确认号X+1<br>被动方发送Fin+Ack报文，并只发送序列号Y，确认号为X<br>主动发发送ack报文，并只发送序列号X，确认号Y</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一次挥手:客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送(报文段4)。[A告诉B我要和你断开连接了]</span><br><span class="line">第二次挥手: 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1(报文段5)。和SYN一样，一个FIN将占用一个序号。 [B发送发可能还有数据没有发送完给A，把剩余的数据发送出去]</span><br><span class="line">第三次挥手: 与客户端A的连接，发送一个FIN给客户端A(报文段6)。 [B发送方告诉A我要断开和你的连接了]</span><br><span class="line">第四次挥手: CK报文确认，并将确认序号设置为收到序号加1(报文段7)。 [A告诉B我收到了你要和我断开连接的消息]</span><br></pre></td></tr></table></figure><h2 id="为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"><a href="#为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？" class="headerlink" title="为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"></a>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h2><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，<br>它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。<br>但关闭连接时，当收到对方的FIN报文通知时，<br><code>它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了</code><br>所以你可能未必会马上会关闭SOCKET, 以及你可能还需要发送一些数据给对方之后，<br>再发送FIN报文给对方来表示你同意现在可以关闭连接了，<br>所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层协议简介</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="ARP（地址解析协议）"><a href="#ARP（地址解析协议）" class="headerlink" title="ARP（地址解析协议）"></a>ARP（地址解析协议）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。</span><br><span class="line">ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，</span><br><span class="line">在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个&quot;广播&quot;地址。</span><br><span class="line">它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。</span><br><span class="line">如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</span><br><span class="line">总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，</span><br><span class="line">可以把数据包发送到任意一台主机之上了。</span><br></pre></td></tr></table></figure><h1 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从Mac地址定位到IP地址的一种协议</span><br></pre></td></tr></table></figure><h1 id="广播和多播"><a href="#广播和多播" class="headerlink" title="广播和多播"></a>广播和多播</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">广播：主机号全为1或0，广播中又有直接广播</span><br><span class="line">网络地址192.168.0.0&#x2F;24 -&gt; 192.168.1.255&#x2F;24目标发送IP包</span><br><span class="line">收到这个包的路由器将数据发送给192.168.1.0&#x2F;24</span><br><span class="line">使得192.168.1.1-192.168.1.254的主机都能就收到这个包</span><br><span class="line">广播会带来不必要的流量，而且不能穿透路由，不能再其他网段发送数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多播：使用D类地址</span><br><span class="line">224.0.0.0-239.255.255.255</span><br></pre></td></tr></table></figure><h1 id="子网，子网掩码"><a href="#子网，子网掩码" class="headerlink" title="子网，子网掩码"></a>子网，子网掩码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip地址 + 子网掩码 &#x3D; 网络地址</span><br></pre></td></tr></table></figure><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">面向无连接的，</span><br><span class="line">ip负责把数据发送给目标主机，tcp负责保证对端主机收到数据</span><br></pre></td></tr></table></figure><h2 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP地址是一个32位的二进制数，由四个八位字段组成。每个IP地址包括两部分：一部分为网络标识，一部分为主机标识。  </span><br><span class="line">IP又分为4大类，A类地址，B类地址，C类地址，D类地址</span><br></pre></td></tr></table></figure><h3 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h3><p>A类地址前8位为网络标识。后24位为主机标识。网段与主机数的计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">根据规定，A类地址的网络标识必须以“0”开头。</span><br><span class="line">那么其网段数应该为0XXXXXXX．YYYYYYYY．YYYYYYYY．YYYYYYYY即后面有七位数字，因为是二进制数，</span><br><span class="line">所以网段数应该为： 2^7，即2的7次幂个网段，等于128，即网段应该是0—127之间。</span><br><span class="line">而网络空间计算都必须“减2”，这是因为要扣除两个保留地址：二进制数里全是“0”和全是“1”的要保留。“0”做为网络号，“1”做为广播号。所以A类地址的网段为1—126. A类主机数计算： </span><br><span class="line">因为后面24位是主机标识，所以主机数应该是2^24，即2的24次幂 2^24&#x3D;16777216，扣除两个保留地址后，主机最大数应该是16777214个。</span><br><span class="line">综上所述，A类IP地址范围应该是：1.0.0.1~126.255.255.254  </span><br></pre></td></tr></table></figure><h3 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h3><p>A类地址前16位为网络标识。后16位为主机标识。网段与主机数的计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">根据规定，B类地址的网络标识必须以“10”开头。</span><br><span class="line">那么其网段数应该为10XXXXXX．XXXXXXXX．YYYYYYYY．YYYYYYYY即后面有14位数字，</span><br><span class="line">因为是二进制数，所以网段数应该为： </span><br><span class="line">2^14，即2的14次幂个网段，等于16384，扣除两个全“0”，全“1”的保留地址，所以B类网络可以有16382个网段。 </span><br><span class="line">而转换成十进制后， IP地址的第一个小数点前的数字区间应该是多少呢？因为第一段是10XXXXXX，所以应该是2^6个，</span><br><span class="line">即2的6次幂，等于64个。127是被保留网段暂不使用。</span><br><span class="line">B类网段应该是从128开始，所以128+64-1&#x3D;191.即十进制IP的第一段数字是在128—191之间。 </span><br><span class="line">B类主机数计算： </span><br><span class="line">因为后面16位是主机标识，所以主机数应该是2^16，即2的16次幂 2^16&#x3D;65536，扣除两个保留地址后，主机最大数应该是65534个。  </span><br><span class="line">综上所述，B类IP地址范围应该是：128.0.0.1~191.255.255.254  </span><br></pre></td></tr></table></figure><h3 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h3><p>A类地址前24位为网络标识。后8位为主机标识。网段与主机数的计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">根据规定，C类地址的网络标识必须以“110”开头。那么其网段数应该为110XXXXX．XXXXXXXX．XXXXXXXX．YYYYYYYY即后面有21位数字，因为是二进制数，所以网段数应该为： </span><br><span class="line">2^21，即2的21次幂个网段，等于2097152，扣除两个全“0”，全“1”的保留地址，所以B类网络可以有2097150个网段。 </span><br><span class="line">而转换成十进制后，IP地址的第一个小数点前的数字区间应该是多少呢？因为第一段是110XXXXX，所以应该是2^5个，即2的5次幂，等于32个。C类网段应该是从192开始</span><br><span class="line"></span><br><span class="line">所以192+32-1&#x3D;223。也就是说，十进制IP的第一位在192和223之间。C类主机计数：</span><br><span class="line">因为最后的8位是主机标识，所以主机的数目应该是2^8，也就是说，2的8次方是2^8&#x3D;256。扣除两个保留地址后，主机的最大数量应为254个。</span><br><span class="line">综上所述，C类IP地址范围应为192.0.0.1~223.255.255.254。</span><br></pre></td></tr></table></figure><h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址:"></a>私有地址:</h3><p>私有ip属于非注册地址，专门为组织机构内部使用。RFC1918定义了私有IP地址范围：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A: 10.0.0.0~10.255.255.255 即10.0.0.0&#x2F;8</span><br><span class="line">B: 172.16.0.0~172.31.255.255即172.16.0.0&#x2F;12</span><br><span class="line">C:192.168.0.0~192.168.255.255 即192.168.0.0&#x2F;16</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层协议简介</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>为用户提供服务通信活动</p><h1 id="常见的协议：http-websocket-dns，-smtp"><a href="#常见的协议：http-websocket-dns，-smtp" class="headerlink" title="常见的协议：http, websocket, dns， smtp"></a>常见的协议：http, websocket, dns， smtp</h1><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>特点: <strong>简单快速</strong>,<strong>灵活</strong>,<strong>无连接(链接一次就会断掉)</strong>,<strong>无状态(不能区分两边连接者的身份)</strong><br>一个请求的过程:域名解析-&gt;发起tcp三次握手-&gt;发送http请求-&gt;服务器响应http请求-&gt;浏览器解析响应<br>关于http协议是无状态协议是因为对于事务处理没有记忆能力。<br>缺少状态意味着如果后续处理需要前面的信息.所以需要通过Cookie或者session保存信息<br>相对于<code>http1.0</code>关于<code>http1.1</code>的优点:</p><ol><li>默认是<code>Connection: keep-alive</code>不会主动关闭连接</li><li>引入了管道机制(pipelining),即在同一个TCP连接里面,客户端可以同时发送多个请求<br>不过http1版本的协议缺点也很明显：头部内容携带过多，多个消息头都是重复的，在安全上都是明文传输，</li></ol><p>相对于<code>http1</code>关于<code>http2</code>的优点:</p><ol><li>安全上更优越，内容都是二进制传输也就是帧的形式发送</li><li>一个消息的多个帧可以无序发送，传输效率更快</li><li>多路复用，可以在一个tcp链接上承载多个双向数据流<br>缺点：http2只会建立一次tcp连接，连接上出现丢包现象就需要等待重传</li></ol><p>相对于<code>http2</code>关于<code>http3</code>的优点:</p><ol><li>基于udp进行链接的，不会因为丢包发生等待重传的事情</li></ol><h2 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h2><blockquote><p><strong>请求报文格式:</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: hacker.jp</span><br><span class="line">Connection: keep-alive（持久连接，减少通讯量的开销）</span><br><span class="line">Content-Type: applicaiton&#x2F;x-ww-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br><span class="line"></span><br><span class="line">name&#x3D;ueno&amp;age&#x3D;37</span><br></pre></td></tr></table></figure><blockquote><p><strong>响应报文格式:</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 VERY OK</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line">Content-Length: 355</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>关于请求方式:</strong><br>其中get和post的区别:</p><ol><li>get的发送数据是放在url的后面的</li><li>post是有body的，参数是放在body里的</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET 请求访问已经被URI识别的资源</span><br><span class="line">POST 传输实体主体</span><br><span class="line">PUT 传输文件</span><br><span class="line">DELETE 删除文件</span><br><span class="line">HEAD 获取报文首部</span><br><span class="line">OPTIONS 查询针对请求URI指定的资源支持方法</span><br><span class="line">TRACE 追踪路径</span><br><span class="line">CONNECT 要求用隧道协议链接代理</span><br><span class="line">LINK 建立与资源之间的联系</span><br><span class="line">UNLINK 断开连接关系</span><br></pre></td></tr></table></figure><blockquote><p><strong>常见状态码:</strong></p></blockquote><table><thead><tr><th>状态码</th><th>状态名称</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>ok</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建成功,请求并创建了新的资源</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替,也就是替换成了Location字段指定的URI</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。不管原请求是什么方法，重定向请求的方法都是 GET</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。协商缓存命中返回304.所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>307 的定义实际上和 302 是一致的，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上</td></tr><tr><td>308</td><td>permanent Redirect</td><td>永久重定向，308 的定义实际上和 301 是一致的，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr></tbody></table><h2 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h2><p>上面刚说完http的状态码，就不等不说浏览器的缓存机制了</p><ul><li>浏览器在加载资源时，根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。</li><li>如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过<code>last-modified</code>和<code>etag</code>验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源</li><li>如果前面两者都没有命中，直接从服务器加载资源<blockquote><p>另外解释以下<code>expires</code>,<code>cache-control</code>,<code>etag</code>,<code>last-modified</code>.这几个字段:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># expires</span><br><span class="line">Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。</span><br><span class="line">Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</span><br><span class="line"></span><br><span class="line"># Cache-Control</span><br><span class="line">Cache-Control 出现于 HTTP &#x2F; 1.1，优先级高于 Expires ,表示的是相对时间</span><br><span class="line"></span><br><span class="line"># Last-Modified，If-Modified-Since</span><br><span class="line">Last-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），</span><br><span class="line">询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</span><br><span class="line"></span><br><span class="line"># ETag、If-None-Match</span><br><span class="line">Etag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的</span><br><span class="line">If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来</span><br><span class="line"></span><br><span class="line"># 关于etag</span><br><span class="line">当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。</span><br><span class="line"></span><br><span class="line">情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。</span><br><span class="line"></span><br><span class="line">情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间和Etag</span><br><span class="line">然后进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag判断文件内容自上一次请求之后有没有发生变化</span><br><span class="line"></span><br><span class="line">情形三：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，</span><br><span class="line">直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。</span><br><span class="line"></span><br><span class="line">情形四：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①</span><br><span class="line">① 只有get请求会被缓存，post请求不会</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="http优化："><a href="#http优化：" class="headerlink" title="http优化："></a>http优化：</h2></li></ul><ol><li>利用负载均衡优化和加速HTTP应用</li><li>利用HTTP Cache来优化网站</li></ol><h2 id="关于https"><a href="#关于https" class="headerlink" title="关于https"></a>关于https</h2><p>对称加密算法加密数据+非对称加密算法交换秘钥+数字证书验证身份<br>对称加密数据：发送发的报文通过ssl加密，接收方通过ssl套接字进行解密<br>下面是https协议的加密过程:<br><img src="http://121.5.231.10:3000/computerNetwork/https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B.png" alt="https加密过程"><br>下面是https的ssl过程:<br><img src="http://121.5.231.10:3000/computerNetwork/https%E7%9A%84ssl%E8%BF%87%E7%A8%8B.png" alt="https加密过程"></p><h2 id="https的通讯方式"><a href="#https的通讯方式" class="headerlink" title="https的通讯方式"></a>https的通讯方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">客户端发送请求</span><br><span class="line">服务端向客户端发送数字证书</span><br><span class="line">客户端验证数字证书，验证成功生成一个会话秘钥</span><br><span class="line">服务器拿到会话秘钥然后用自己的私钥解密</span><br><span class="line">客户端与服务端进行加密通讯</span><br><span class="line"></span><br><span class="line">大白话就是数字证书保证了：</span><br><span class="line">1. 客户端这边能造一个箱子然后这个箱子可以用服务端的🔑 打开也可以用自己的公钥打开。</span><br><span class="line">2. 客户端确认服务端就是自己要找的那个人，身份是对的</span><br><span class="line">其中:这个箱子就是指对数据进行加密和解密的编码算法(随机对称密钥)，这种编码算法可以对数据进行加密和解密.服务端的🔑 就是指服务端的秘钥</span><br></pre></td></tr></table></figure><h2 id="https的ssl过程"><a href="#https的ssl过程" class="headerlink" title="https的ssl过程"></a>https的ssl过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</span><br><span class="line">（2）Web服务器收到客户端请求后，会生成一对公钥和私钥，并把公钥放在证书中发给客户端浏览器。</span><br><span class="line">（3）客户端判断证书是否有效，无效弹出警告，有效生成一个随机值。并用证书的公钥对随机值进行加密</span><br><span class="line">    加密后的随机值称为密钥，发送给服务端。</span><br><span class="line">（4）Web服务器用私钥解密密钥。然后用该密钥加密数据。发送给客户端</span><br><span class="line">（5）客户端用密钥解密数据</span><br></pre></td></tr></table></figure><h2 id="关于dns解析过程"><a href="#关于dns解析过程" class="headerlink" title="关于dns解析过程"></a>关于dns解析过程</h2><p>浏览器搜索自己的dns缓存-》查询wins服务器-》进行广播查找-》读取host文件</p><h2 id="dns查询过程"><a href="#dns查询过程" class="headerlink" title="dns查询过程"></a>dns查询过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请求主机首先向本地DNS服务器查询目标域名，</span><br><span class="line">首先查看本地缓存是否有目标域名的IP地址列表</span><br><span class="line">否则查看本地DNS服务器没有目标域名的IP地址列表(即目标域名在该服务器上)</span><br><span class="line">否则本地DNS服务器向跟DNS服务器获取该域名的TLD(域名后面的后缀.cn&#x2F;.edu&#x2F;etc)的IP地址列表</span><br><span class="line">然后本地DNS服务器向TLD DNS服务器 发送查询报文</span><br><span class="line">最后获得了该域名所在的权威DNS服务器所在地址，并向它做查询，获得到该ip地址的响应报文</span><br></pre></td></tr></table></figure><h2 id="关于smtp协议"><a href="#关于smtp协议" class="headerlink" title="关于smtp协议"></a>关于smtp协议</h2><p>smtp是邮箱访问协议，它是一个推送协议，只能够进行下面的操作：</p><ol><li>将邮件从发送方的邮件服务器传输到接收方的邮件服务器</li><li>将邮件从发送方的用户代理传送到发送方的邮件服务器<br>所以当接收方的用户代理想要从接收方的邮件服务器获取邮件需要用到下面的协议<br>pop3(第三版的邮局协议) 或 imap(因特网邮件访问协议) 或 http协议</li></ol><h2 id="websocket协议"><a href="#websocket协议" class="headerlink" title="websocket协议"></a>websocket协议</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP协议通信只能由客户端发起，于是有了websocket进行p2p的模式。</span><br><span class="line">websocket协议是向网络发送报文和从网络接收报文的软件接口</span><br><span class="line">特点：</span><br><span class="line">1. 数据格式比较轻量，性能开销小，通信高效。</span><br><span class="line">2. 可以发送文本，也可以发送二进制数据。</span><br><span class="line">3. 没有同源限制，客户端可以与任意服务器通信。</span><br><span class="line">4. 协议标识符是ws（如果加密，则为wss），服务器网址就是URL。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基本概要简介</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边缘部分：互联网上的主机(端系统), 主机是为用户进行信息处理</span><br><span class="line">核心部分: 网络与连接网络的路由器,路由器是用来转发分组的</span><br><span class="line">边缘部分端系统之间的通信方式：</span><br><span class="line">1. 客户-服务器</span><br><span class="line">2. 对等连接(p2p)</span><br><span class="line">核心部分的通信方式：</span><br><span class="line">1. 电路交换: 电话机与交换机（源点直达终点）</span><br><span class="line">2. 分组交换: 运用存储转发技术，将报文分组并为每个分组加入包含控制信息的首部构成包。(将包传送到邻接点)</span><br><span class="line">3. 报文交换: 电报通讯(将报文传送到邻接点)</span><br></pre></td></tr></table></figure><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交换机有时被称为多端口网桥,应用在链路层</span><br><span class="line">基于MAC地址识别，能完成封装转发数据帧功能的网络设备。</span><br><span class="line">交换机可以“学习”MAC地址，并把其存放在内部地址表中，</span><br><span class="line">通过在数据帧的始发者和目标接收者之间建立临时的交换路径，</span><br><span class="line">使数据帧直接由源地址到达目的地址。</span><br><span class="line">因为可以同一时刻可进行多个端口对之间的数据传输，所以提高了网络带宽</span><br></pre></td></tr></table></figure><h1 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">网卡是工作在链路层的网络组件,是局域网中连接计算机和传输介质的接口</span><br><span class="line">不仅能实现与局域网传输介质之间的物理连接和电信号匹配，</span><br><span class="line">还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码</span><br><span class="line">以及数据缓存的功能等。总之将双绞线中的电信号转为二进制的数据信号</span><br></pre></td></tr></table></figure><h1 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 速率：</span><br><span class="line">&gt; 带宽：（单位时间内，某信道能通过的最大数据率）</span><br><span class="line">&gt; 吞吐量：</span><br><span class="line">&gt; 时延：(发送时延，传播时延，处理时延，排队时延)</span><br><span class="line">&gt; 时延带宽积（传播时延 * 带宽）</span><br><span class="line">&gt; 往返时间RTT</span><br><span class="line">&gt; 利用率</span><br></pre></td></tr></table></figure><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法,语义,同步</span><br></pre></td></tr></table></figure><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 应用层：为用户提供服务的通信的活动</span><br><span class="line">&gt; 传输层：处于网络连接中的两台计算机之间的数据传输</span><br><span class="line">&gt; 网络层：处理网络上的流动数据包</span><br><span class="line">&gt; 链路层：链接网络的硬件部分（操作系统，网卡，光纤）</span><br><span class="line">&gt; 物理层</span><br><span class="line">网络中数据传输的变化: http报文-&gt;用户数据报(报文段)-&gt;包-&gt;帧</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpu调度</title>
      <link href="2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cpu%E8%B0%83%E5%BA%A6/"/>
      <url>2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cpu%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="本次讲解CPU调度常见概念，CPU调度算法以及特点"><a href="#本次讲解CPU调度常见概念，CPU调度算法以及特点" class="headerlink" title="本次讲解CPU调度常见概念，CPU调度算法以及特点"></a>本次讲解CPU调度常见概念，CPU调度算法以及特点</h1><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="cpu调度决策发生的情况："><a href="#cpu调度决策发生的情况：" class="headerlink" title="cpu调度决策发生的情况："></a>cpu调度决策发生的情况：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（就绪状态 &lt;- 运行状态 &lt;-&gt; 等待状态）</span><br><span class="line">a 当一个进程从运行态到等待状态 (请求)</span><br><span class="line">b 运行状态到就绪状态 （中断）</span><br><span class="line">c 等待状态到运行态</span><br><span class="line">d 一个进程终止</span><br><span class="line"></span><br><span class="line">b&amp;c是抢占，a&amp;d是非抢占</span><br></pre></td></tr></table></figure><h2 id="调度准则："><a href="#调度准则：" class="headerlink" title="调度准则："></a>调度准则：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cpu使用率： cpu利用时间 &#x2F; 开机运行时间</span><br><span class="line">吞吐量 （单位时间内可以完成的进程数量）</span><br><span class="line">周转时间 （进程提交到完成所需要的总时间）</span><br><span class="line">等待时间 （进程在就绪队列中等待所花费的总时间）</span><br><span class="line">响应时间 （提交请求道第一响应的时间）</span><br><span class="line"></span><br><span class="line">带权周转时间是指作业周转时间与作业实际运行时间的比值</span><br><span class="line">带权周转时间 &#x3D; 作业周转时间 &#x2F; 作业实际运行时间</span><br></pre></td></tr></table></figure><h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="先到先服务（FCFS）："><a href="#先到先服务（FCFS）：" class="headerlink" title="先到先服务（FCFS）："></a>先到先服务（FCFS）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">处于就绪态的进程按先后顺序链入到就绪队列中，</span><br><span class="line">而FCFS调度算法按就绪进程进入就绪队列的先后次序选择当前最先进入就绪队列的进程来执行</span><br><span class="line">直到此进程阻塞或结束，才进行下一次的进程选择调度。</span><br><span class="line">FCFS调度算法采用的是不可抢占的调度方式，一旦一个进程占有处理机</span><br><span class="line">就一直运行下去，直到该进程完成其工作，或因等待某一事件而不能继续执行时，才释放处理机。</span><br></pre></td></tr></table></figure><h2 id="最短作业优先调度（SJF）："><a href="#最短作业优先调度（SJF）：" class="headerlink" title="最短作业优先调度（SJF）："></a>最短作业优先调度（SJF）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法</span><br><span class="line">短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，</span><br><span class="line">将它们调入内存运行。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，</span><br><span class="line">将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</span><br><span class="line"></span><br><span class="line">（1）SRTF抢占式：又称最短剩余优先，当新进来的进程的CPU区间比当前执行的进程所剩的CPU区间短，则抢占。</span><br><span class="line"></span><br><span class="line">（2）非抢占：称为下一个最短优先，因为在就绪队列中选择最短CPU区间的进程放在队头。</span><br><span class="line"></span><br><span class="line">SJF调度算法的特点是吞吐率高，平均等待时间、平均周转时间最少；但算法对长作业十分不利，也完全未考虑作业的紧迫程度。</span><br></pre></td></tr></table></figure><h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><h2 id="时间片轮转调度（RR）"><a href="#时间片轮转调度（RR）" class="headerlink" title="时间片轮转调度（RR）"></a>时间片轮转调度（RR）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">适用于分时系统，系统将所有的就绪进程按照到达时间的先后顺序排成一个队列</span><br><span class="line">进程调度程序总是选择就绪队列中第一个进程执行，即先到先服务的原则。</span><br><span class="line">但仅能运行一个时间片。在使用完第一个时间片后，即使进程并没完成其运行</span><br><span class="line">他也必须释放出处理机给下一个就绪的进程。而被捕哦多的进程返回到就绪队列</span><br><span class="line">的末尾重新排队，等待再次运行。</span><br><span class="line"></span><br><span class="line">在时间片轮转调度算法中，时间片的大小对系统性能的影响很大，如果时间足够大。</span><br><span class="line">则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大</span><br><span class="line"></span><br><span class="line">时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。</span><br><span class="line"></span><br><span class="line">时间片q &#x3D; 系统对相应时间的要求RT &#x2F; 最大进程数N</span><br><span class="line"></span><br><span class="line">（经验表明，时间片的取值，应该使得80%的进程在时间内完成所需的一次CPU运行活动。）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多级反馈队列调度（MLFQ）"><a href="#多级反馈队列调度（MLFQ）" class="headerlink" title="多级反馈队列调度（MLFQ）"></a>多级反馈队列调度（MLFQ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">设置多个就绪队列，并为各个队列赋予不同的优先级。</span><br><span class="line">第一个队列的优先级最高，第二队次之，其余队列优先级依次降低。</span><br><span class="line">仅当第1～i-1个队列均为空时，操作系统调度器才会调度第i个队列中的进程运行</span><br><span class="line">在优先级越高的队列中，每个进程的执行时间片就越小或越大</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当一个就绪进程需要链入就绪队列时，操作系统首先将它放入第一队列的末尾，</span><br><span class="line">按FCFS的原则排队等待调度。若轮到该进程执行且在一个时间片结束时尚未完成</span><br><span class="line">，则操作系统调度器便将该进程转入第二队列的末尾，再同样按先来先服务原则等待调度执行。</span><br><span class="line">如此下去，当一个长进程从第一队列降到最后一个队列后，在最后一个队列中，</span><br><span class="line">可使用FCFS或RR调度算法来运行处于此队列中的进程。</span><br><span class="line"></span><br><span class="line">如果处理机正在第i（i&gt;1）队列中为某进程服务时，</span><br><span class="line">又有新进程进入第k（k&lt;i）的队列，则新进程将抢占正在运行进程的处理机，</span><br><span class="line">即由调度程序把正在执行进程放回第i队列末尾，</span><br><span class="line">重新将处理机分配给处于第k队列的新进程。</span><br></pre></td></tr></table></figure><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">假设系统中有3个反馈队列Q1,Q2,Q3，时间片分别为2，4，8。 [1]</span><br><span class="line">设有3个作业J1,J2,J3分别在时间 0 ，1，3时刻到达。而它们所需要的CPU时间分别是3，2，1个时间片。</span><br><span class="line">1、时刻0 J1到达。于是进入到队列1 ， 运行1个时间片 ， 时间片还未到，此时J2到达。</span><br><span class="line">2、时刻1 J2到达。 由于同一队列采用先来先服务，于是J2等待。 J1在运行了1个时间片后，已经完成了在Q1中的2个时间片的限制，于是J1置于Q2等待被调度。当前处理机分配给J2。</span><br><span class="line">3、时刻2 J1进入Q2等待调度，J2获得CPU开始运行。</span><br><span class="line">4、时刻3 J3到达，由于同一队列采用先来先服务，故J3在Q1等待调度，J1也在Q2等待调度。</span><br><span class="line">5、时刻4 J2处理完成，由于J3，J1都在等待调度，但是J3所在的队列比J1所在的队列的优先级要高，于是J3被调度，J1继续在Q2等待。</span><br><span class="line">6、时刻5 J3经过1个时间片，完成。</span><br><span class="line">7、时刻6 由于Q1已经空闲，于是开始调度Q2中的作业，则J1得到处理器开始运行。 J1再经过一个时间片，完成了任务。于是整个调度过程结束。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件管理</title>
      <link href="2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="文件管理系统的功能"><a href="#文件管理系统的功能" class="headerlink" title="文件管理系统的功能"></a>文件管理系统的功能</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件系统的管理功能是通过把它所管理的程序和数据组织成一系列文件的方法来实现的。</span><br><span class="line">可以把数据组成分为数据项、记录、文件。</span><br><span class="line"></span><br><span class="line">当前OS所提供的大多数对文件的操作，</span><br><span class="line">其过程大致都是这样两步：首先，检索文件目录来找到指定文件的属性及其在外存上的位置；</span><br><span class="line">然后，对文件实施相应的操作，如读&#x2F;写文件等，当用户要求对一个文件实施多次读&#x2F;写或其他操作时，</span><br><span class="line">每次都要从检索目录开始，为了避免多次重复地检索目录，</span><br><span class="line">在大多数OS中都引入了打开这一文件系统调用，当用户第一次请求对某文件系统进行操作时，</span><br><span class="line">先利用open系统调用将该文件打开。</span><br></pre></td></tr></table></figure><h1 id="文件的逻辑结构：无结构文件-流式文件-和有结构文件-记录式文件"><a href="#文件的逻辑结构：无结构文件-流式文件-和有结构文件-记录式文件" class="headerlink" title="文件的逻辑结构：无结构文件(流式文件)和有结构文件(记录式文件)"></a>文件的逻辑结构：无结构文件(流式文件)和有结构文件(记录式文件)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构是从实现观点出发，又称为文件的存储结构，是指文件在外存上的存储组织形式。</span><br><span class="line">文件的逻辑结构与存储介质特性无关，但文件的物理结构与存储介质的特性有很大关系。</span><br><span class="line">按逻辑结构，文件有无结构文件和有结构文件两种类型：无结构文件和有结构文件。</span><br></pre></td></tr></table></figure><h1 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无结构文件是最简单的文件组织形式。无结构文件将数据按顺序组织成记录并积累保存，</span><br><span class="line">它是有序相关信息项的集合，以字节(Byte)为单位。由于无结构文件没有结构，因而对记录的访问只能通过穷举搜索的方式，故这种文件形式对大多数应用不适用。但字符流的无结构文件管理简单，用户可以方便地对其进行操作。所以，那些对基本信息单位操作不多的文件较适于釆用字符流的无结构方式，如源程序文件、目标代码文件等。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">顺序文件:</span><br><span class="line">文件中的记录一个接一个地顺序排列，记录可以是定长的或变长的，可以顺序存储或以链表形式存储，</span><br><span class="line"></span><br><span class="line">索引文件:</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要包括虚地址、地址变换、内存分配和回收、内存扩充、内存共享和保护等功能。</span><br><span class="line">连续分配是指为一个用户程序分配连续的内存空间。连续分配有单一连续存储管理和分区式储管理两种方式</span><br></pre></td></tr></table></figure><h2 id="内存分配的方式"><a href="#内存分配的方式" class="headerlink" title="内存分配的方式"></a>内存分配的方式</h2><h3 id="单一连续存储管理"><a href="#单一连续存储管理" class="headerlink" title="单一连续存储管理"></a>单一连续存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。</span><br><span class="line">其特点是，最简单，适用于单用户、单任务的操作系统。</span><br><span class="line">CP／M和 DOS 2．0以下就是采用此种方式。这种方式的最大优点就是易于管理。</span><br></pre></td></tr></table></figure><h3 id="分区式存储管理"><a href="#分区式存储管理" class="headerlink" title="分区式存储管理"></a>分区式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分区式存储管理是把内存分为一些大小相等或不等的分区，</span><br><span class="line">操作系统占用其中一个分区，其余的分区由应用程序使用，</span><br><span class="line">每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，</span><br><span class="line">但难以进行内存分区的共享。</span><br></pre></td></tr></table></figure><h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">固定式分区的特点是把内存划分为若干个固定大小的连续分区。</span><br><span class="line">分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：</span><br></pre></td></tr></table></figure><h3 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，</span><br><span class="line">则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，</span><br><span class="line">而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。</span><br><span class="line">动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。</span><br><span class="line"></span><br><span class="line">最先适配法(nrst-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。</span><br><span class="line">该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。</span><br><span class="line"></span><br><span class="line">下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后&#123;区时再从头开始&#125;，</span><br><span class="line">找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。</span><br><span class="line"></span><br><span class="line">最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。</span><br><span class="line">从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。</span><br><span class="line"></span><br><span class="line">最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，</span><br><span class="line">找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。</span><br></pre></td></tr></table></figure><h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">固定分区和动态分区的折中方法</span><br><span class="line">当需要为进程分配一个长度为n的存储空间时:</span><br><span class="line">首先计算一个 i 值，使 2 ^ (i－1) &lt; n ≤ 2 ^ i，</span><br><span class="line">然后在空闲分区大小为2 ^ i的空闲分区链表中查找。</span><br><span class="line">若找到，即把该空闲分区分配给进程。</span><br><span class="line">否则，表明长度为2 ^ i的空闲分区已经耗尽，则在分区大小为2 ^ (i ＋ 1)的空闲分区链表中寻找。</span><br><span class="line">若存在 2 ^ (i ＋ 1)的一个空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙伴，其中的一个分区用于配，</span><br><span class="line">而把另一个加入分区大小为2 ^ i的空闲分区链表中。</span><br><span class="line">若大小为2 ^ (i ＋ 1)的空闲分区也不存在，则需要查找大小为2 ^ (i ＋ 2)的空闲分区， 若找到则对其进行两次分割：</span><br><span class="line">第一次，将其分割为大小为 2 ^ (i ＋ 1)的两个分区，一个用于分配，一个加入到大小为 2^(i ＋ 1)的空闲分区链表中；</span><br><span class="line">第二次，将第一次用于分配的空闲区分割为 2^i的两个分区，一个用于分配，一个加入到大小为 2^i的空闲分区链表中。</span><br><span class="line">若仍然找不到，则继续查找大小为 2 ^ (i ＋ 3)的空闲分区，以此类推。</span><br></pre></td></tr></table></figure><h3 id="内存紧缩（地址变换）"><a href="#内存紧缩（地址变换）" class="headerlink" title="内存紧缩（地址变换）"></a>内存紧缩（地址变换）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将各个占用分区向内存一端移动, 然后将各个空闲分区合并成为一个空闲分区。</span><br></pre></td></tr></table></figure><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引入覆盖 (overlay)技术的目标是在较小的可用内存中运行较大的程序。</span><br><span class="line">这种技术常用于多道程序系统之中，与分区式存储管理配合使用。</span><br></pre></td></tr></table></figure><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交换 (swapping)技术在多个程序并发执行时，可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程），</span><br><span class="line">或读人保存在外存中而处于就绪状态的程序。交换单位为整个进程的地址空间。交换技术常用于多道程序系统或小型分时系统中，</span><br><span class="line">因为这些系统大多采用分区存储管理方式。与分区式存储管理配合使用又称作“对换”或“滚进／滚出” (roll-in／roll-out)。</span><br><span class="line">暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），</span><br><span class="line">而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，</span><br><span class="line">并将该进程送到就绪队列（换入swap in）。</span><br></pre></td></tr></table></figure><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="页式和段式存储管理"><a href="#页式和段式存储管理" class="headerlink" title="页式和段式存储管理"></a>页式和段式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">地址空间：将源程序经过编译后得到的目标程序，</span><br><span class="line">存在于它所限定的地址范围内，这个范围称为地址空间。地址空间是逻辑地址的集合。</span><br><span class="line"></span><br><span class="line">存储空间：指主存中一系列存储信息的物理单元的集合，</span><br><span class="line">这些单元的编号称为物理地址存储空间是物理地址的集合。</span><br><span class="line"></span><br><span class="line">根据分配时所采用的基本单位不同，可将离散分配的管理方式分为以下三种：</span><br><span class="line">页式存储管理、段式存储管理和段页式存储管理。其中段页式存储管理是前两种结合的产物。</span><br></pre></td></tr></table></figure><h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">将程序的逻辑地址空间划分为固定大小的页(page)，</span><br><span class="line">而物理内存划分为同样大小的页框(page frame)。</span><br><span class="line">程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。</span><br><span class="line">该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。</span><br><span class="line">在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）</span><br><span class="line"></span><br><span class="line">没有外碎片，每个内碎片不超过页</span><br><span class="line">一个程序不必连续存放。</span><br><span class="line">便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。</span><br></pre></td></tr></table></figure><h3 id="页式管理的数据结构"><a href="#页式管理的数据结构" class="headerlink" title="页式管理的数据结构"></a>页式管理的数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在页式系统中，指令所给出的地址分为两部分：逻辑页号和页内地址。</span><br><span class="line">原理：</span><br><span class="line">CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，</span><br><span class="line">将物理页框号与页内地址相加形成物理地址</span><br><span class="line">逻辑页号，页内偏移地址－&gt;查进程页表，得物理页号－&gt;物理地址</span><br><span class="line"></span><br><span class="line">若给定一个逻辑地址为A，页面大小为L，则</span><br><span class="line">页号P&#x3D;INT[A&#x2F;L]，页内地址W&#x3D;A  MOD  L</span><br><span class="line">物理地址：物理块号 * 页面大小+ 页内偏移&#x3D; 28683</span><br></pre></td></tr></table></figure><h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">页面是主存物理空间中划分出来的等长的固定区域。分页方式的优点是页长固定，因而便于构造页表、易于管理，且不存在外碎片。</span><br><span class="line">但分页方式的缺点是页长与程序的逻辑大小不相关。例如，某个时刻一个子程序可能有一部分在主存中，另一部分则在辅存中。</span><br><span class="line">这不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。</span><br><span class="line"></span><br><span class="line">另一种划分可寻址的存储空间的方法称为分段。段是按照程序的自然分界划分的长度可以动态改变的区域。</span><br><span class="line">通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。</span><br><span class="line"></span><br><span class="line">作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例程序段、数据段等。每个段都从0开始编址，</span><br><span class="line">并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。</span><br><span class="line">整个作业的地址空间是二维的。</span><br><span class="line"></span><br><span class="line">每个程序设置一个段表，段表的每一个表项对应一个段，每个表项至少包括三个字段：</span><br><span class="line">有效位（指明该段是否已经调入主存）、段起址(该段在实存中的首地址)和段长（记录该段的实际长度）。</span><br><span class="line"></span><br><span class="line">绝对地址&#x3D;根据段号找到段表中的起始地址+段内地址 (如果段内地址超过限长则产生“地址越界”程序性中断事件达到存储保护)</span><br></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">已知逻辑空间地址为2^m个字节（也就是说逻辑地址的长度是m位），</span><br><span class="line">已知页大小是2^n字节。那么一共可以有2^(m-n)个页。</span><br><span class="line">因此页码部分会占m-n位，之后的n位，用来存储页偏移。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举个例子， 页大小为4B，而逻辑内存为32B（8页），</span><br><span class="line">逻辑地址0的页号为0，页号0对应帧5，</span><br><span class="line">因此逻辑地址映射为物理地址5*4+0&#x3D;20。逻辑地址3映射物理地址5*4+3&#x3D;23。</span><br><span class="line">逻辑地址13(4*3+1，页号为3，偏移为1，因为帧号为5)，映射到物理地址21。</span><br><span class="line">13 &#x2F; 4 &#x3D; 3</span><br><span class="line">13 mod 4 &#x3D; 1</span><br><span class="line">5 * 4 + 1 &#x3D; 21</span><br><span class="line"></span><br><span class="line">页式的逻辑地址是连续的，段式的逻辑地址可以不连续</span><br><span class="line">页式的地址是一维的，段式的地址是二维的</span><br><span class="line">分页是操作系统进行的，分段是用户确定的</span><br><span class="line"></span><br><span class="line">段页式管理中，地址映像表是每个进程一张段表，每个段一张页表</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程和协程</title>
      <link href="2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/"/>
      <url>2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程的出现是为了更好的利用CPU资源使到并发成为可能。</span><br><span class="line">是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。</span><br><span class="line">进程是表示资源分配的的基本单位，又是调度运行的基本单位，是系统中的并发执行的单位。</span><br></pre></td></tr></table></figure><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。</span><br><span class="line">进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，</span><br><span class="line">保证程序执行的可再现性。一般进程同步的方法有这几种: **计时器**,**信号量**,**事件**,**互斥锁**.</span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行：初始化，P操作(-)和V操作(+)，</span><br><span class="line">这三种操作都是原子操作。P操作(-)可以用于阻塞一个进程，V操作(+)可以用于解除阻塞一个进程。</span><br><span class="line">一个信号量可以初始化为非负数,</span><br><span class="line">semWait操作使信号量s减1.若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。</span><br><span class="line">semSignal操作使信号量加1，若值大于或等于零，则被semWait操作阻塞的进程被解除阻塞。</span><br></pre></td></tr></table></figure><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">就绪→执行 调度程序选一个优先权最高的进程占有处理机；</span><br><span class="line">执行→就绪 处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。&#39;</span><br><span class="line">当前运行进程时间片用完；</span><br><span class="line">执行→阻塞 当前运行进程等待键盘输入，进入了睡眠状态；</span><br><span class="line">正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。</span><br><span class="line">阻塞→就绪</span><br><span class="line">I&#x2F;O操作完成，被中断处理程序唤醒。</span><br><span class="line">处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。</span><br></pre></td></tr></table></figure><h2 id="进程通讯"><a href="#进程通讯" class="headerlink" title="进程通讯"></a>进程通讯</h2><p>进程通讯的目的是：数据传输，共享数据，通知事件，资源共享，进程控制。通讯的方式有如下几种</p><h3 id="管道pipe"><a href="#管道pipe" class="headerlink" title="管道pipe"></a>管道pipe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">管道是一种半双工的通信方式，数据只能单向流动，</span><br><span class="line">而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</span><br></pre></td></tr></table></figure><h3 id="命名管道FIFO"><a href="#命名管道FIFO" class="headerlink" title="命名管道FIFO"></a>命名管道FIFO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</span><br></pre></td></tr></table></figure><h3 id="消息队列MessageQueue"><a href="#消息队列MessageQueue" class="headerlink" title="消息队列MessageQueue"></a>消息队列MessageQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。</span><br><span class="line">消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</span><br></pre></td></tr></table></figure><h3 id="共享存储SharedMemory"><a href="#共享存储SharedMemory" class="headerlink" title="共享存储SharedMemory"></a>共享存储SharedMemory</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">共享内存就是映射一段能被其他进程所访问的内存，</span><br><span class="line">这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的**IPC**方式，</span><br><span class="line">它是针对其他进程间通信方式运行效率低而专门设计的。</span><br><span class="line">它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</span><br></pre></td></tr></table></figure><h3 id="信号量Semaphore："><a href="#信号量Semaphore：" class="headerlink" title="信号量Semaphore："></a>信号量Semaphore：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</span><br><span class="line">它常作为一种锁机制，防止某进程正在访问共享资源时，</span><br><span class="line">其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</span><br></pre></td></tr></table></figure><h3 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</span><br></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</span><br></pre></td></tr></table></figure><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。</span><br><span class="line">一个线程只能属于一个进程，但是一个进程可以拥有多个线程。</span><br><span class="line">多线程处理就是允许一个进程中在同一时刻执行多个任务。</span><br><span class="line">线程是一种轻量级的进程，与进程相比，线程给操作系统带来侧创建、维护、和管理的负担要轻，意味着线程的代价或开销比较小。</span><br><span class="line">线程没有地址空间，线程包含在进程的地址空间中。线程上下文只包含一个堆栈、一个寄存器、一个优先权，</span><br><span class="line">线程文本包含在他的进程的文本片段中，进程拥有的所有资源都属于线程。所有的线程共享进程的内存和资源。</span><br><span class="line">同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。</span><br><span class="line">但是每个线程拥有自己的栈段， 寄存器的内容，栈段又叫运行时段，用来存放所有局部变量和临时变量。</span><br><span class="line">父和子进程使用进程间通信机制，同一进程的线程通过读取和写入数据到进程变量来通信。</span><br><span class="line">进程中任何线程都可以通过销毁主线程来销毁进程，销毁主线程将导致该进程的销毁，对主线程的修改可能影响所有的线程。</span><br></pre></td></tr></table></figure><h1 id="进程与线程共同点"><a href="#进程与线程共同点" class="headerlink" title="进程与线程共同点:"></a>进程与线程共同点:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程和线程都有ID&#x2F;寄存器组、状态和优先权、信息块，创建后都可更改自己的属性，</span><br><span class="line">都可与父进程共享资源、都不能直接访问其他无关进程或线程的资源。</span><br></pre></td></tr></table></figure><h1 id="协程："><a href="#协程：" class="headerlink" title="协程："></a>协程：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个程序可以包含多个协程，可以对比与一个进程包含多个线程，</span><br><span class="line">因而下面我们来比较协程和线程。我们知道多个线程相对独立，</span><br><span class="line">有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，</span><br><span class="line">但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。</span><br></pre></td></tr></table></figure><h1 id="并行："><a href="#并行：" class="headerlink" title="并行："></a>并行：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">并行就是指同一时刻有两个或两个以上的“工作单位”在同时执行，</span><br><span class="line">从硬件的角度上来看就是同一时刻有两条或两条以上的指令处于执行阶段。</span><br><span class="line">所以，多核是并行的前提</span><br></pre></td></tr></table></figure><h1 id="并发："><a href="#并发：" class="headerlink" title="并发："></a>并发：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使多个操作可以在重叠的时间段内进行</span><br></pre></td></tr></table></figure><h1 id="并行与并发的关系"><a href="#并行与并发的关系" class="headerlink" title="并行与并发的关系:"></a>并行与并发的关系:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并发的设计使到并发执行成为可能，而并行是并发执行的其中一种模式。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统简介</title>
      <link href="2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统:"></a>什么是操作系统:</h1><p>一个程序，管理计算机硬件，给应用程序提供一个环境</p><h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><ol><li>内存管理：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有的应用程序需要使用内存时都要向操作系统去申请和注册</span><br><span class="line">由操作系统的内存管理模块来分配内存给你使用</span><br><span class="line">保证内存使用不会冲突。</span><br></pre></td></tr></table></figure></li><li>进程调度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作系统的进程调度模块负责在各个进程之间进行切换。</span><br></pre></td></tr></table></figure></li><li>硬件设备管理：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有了操作系统后操作系统本身会去控制各个硬件</span><br><span class="line">应用程序就不用考虑硬件的具体细节了。操作系统的硬件设备管理模块就是驱动模块。</span><br></pre></td></tr></table></figure></li><li>文件管理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件系统是管理存储设备的一种方式。存储设备是由很多个扇区组成的</span><br><span class="line">存储设备要以扇区为单位进行读写。如果没有文件系统，程序要自己去读写扇区，就得记得哪个文件在哪个扇区。</span><br><span class="line">有了文件系统之后我们人不用再关注扇区，人只用关注文件系统中的目录和文件名，而不用管这个文件在物理磁盘的哪个扇区</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式系列之行为性模式</title>
      <link href="2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A1%8C%E4%B8%BA%E6%80%A7%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A1%8C%E4%B8%BA%E6%80%A7%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>对在不同的对象之间划分责任和算法的抽象化，行为型模式不仅仅关注类和对象的结构，而且重点关注他们之间的相互作用，通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互</p><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个<br>算法的结构即可重定义该算法的某些特定步骤</p><blockquote><p>这个主要用在基类，比如你可以把公共的方法写进一个基类，这样就不需要重复实现功能了</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> template(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.operation1();</span><br><span class="line">        <span class="built_in">this</span>.hookMethod() &amp;&amp; <span class="built_in">this</span>.operation2();</span><br><span class="line">        <span class="built_in">this</span>.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> operation1(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;使用了方法operation1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> operation2(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;使用了方法operation2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> operation3(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;使用了方法operation3&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 钩子方法</span></span><br><span class="line">    <span class="keyword">protected</span> hookMethod(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClassA</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> operation2(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;对该方法operation2进行了修改再使用&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> operation3(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;对该方法operation3进行了修改再使用&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClassB</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖钩子方法</span></span><br><span class="line">    <span class="keyword">protected</span> hookMethod(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> class1: AbstractClass = <span class="keyword">new</span> ConcreteClassA();</span><br><span class="line">    <span class="keyword">const</span> class2: AbstractClass = <span class="keyword">new</span> ConcreteClassB();</span><br><span class="line"></span><br><span class="line">    class1.template();</span><br><span class="line">    class2.template();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求<br>排或者记录请求日志，可以提供命令的撤销和恢复功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Command &#123;</span><br><span class="line">    execute(): <span class="built_in">void</span>;</span><br><span class="line">    undo(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommandOn</span> <span class="title">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> receiver: Receiver;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">receiver: Receiver</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行命令的方法</span></span><br><span class="line">    <span class="keyword">public</span> execute(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver.actionOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销命令的方法</span></span><br><span class="line">    <span class="keyword">public</span> undo(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver.actionOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommandOff</span> <span class="title">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> receiver: Receiver;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">receiver: Receiver</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行命令的方法</span></span><br><span class="line">    <span class="keyword">public</span> execute(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver.actionOff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销命令的方法</span></span><br><span class="line">    <span class="keyword">public</span> undo(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver.actionOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空命令（省去判空操作）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="title">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> execute(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> undo(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> actionOn(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是命令接收者，开启了某动作&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> actionOff(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是命令接收者，关闭了某动作&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> onCommands: <span class="built_in">Array</span>&lt;Command&gt;;</span><br><span class="line">    <span class="keyword">private</span> offCommands: <span class="built_in">Array</span>&lt;Command&gt;;</span><br><span class="line">    <span class="keyword">private</span> undoCommand: Command;</span><br><span class="line">    <span class="keyword">private</span> slotNum: <span class="built_in">number</span> = <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.undoCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        <span class="built_in">this</span>.onCommands = [];</span><br><span class="line">        <span class="built_in">this</span>.offCommands = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.slotNum; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.onCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">            <span class="built_in">this</span>.offCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> setCommand(index: <span class="built_in">number</span>, <span class="attr">onCommand</span>: Command, <span class="attr">offCommand</span>: Command): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onCommands[index] = onCommand;</span><br><span class="line">        <span class="built_in">this</span>.offCommands[index] = offCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启</span></span><br><span class="line">    <span class="keyword">public</span> on(index: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onCommands[index].execute();<span class="comment">// 调用相应方法</span></span><br><span class="line">        <span class="comment">//记录这次操作，用于撤销</span></span><br><span class="line">        <span class="built_in">this</span>.undoCommand = <span class="built_in">this</span>.onCommands[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="keyword">public</span> off(index: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.offCommands[index].execute();</span><br><span class="line">        <span class="built_in">this</span>.undoCommand = <span class="built_in">this</span>.offCommands[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销</span></span><br><span class="line">    <span class="keyword">public</span> undo(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.undoCommand.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建接收者</span></span><br><span class="line">    <span class="keyword">const</span> receiver: Receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建命令</span></span><br><span class="line">    <span class="keyword">const</span> commandOn: Command = <span class="keyword">new</span> ConcreteCommandOn(receiver);</span><br><span class="line">    <span class="keyword">const</span> commandOff: Command = <span class="keyword">new</span> ConcreteCommandOff(receiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建调用者</span></span><br><span class="line">    <span class="keyword">const</span> invoker: Invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">    invoker.setCommand(<span class="number">0</span>, commandOn, commandOff);</span><br><span class="line"></span><br><span class="line">    invoker.on(<span class="number">0</span>);</span><br><span class="line">    invoker.off(<span class="number">0</span>);</span><br><span class="line">    invoker.undo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>定义一组算法，将每个算法都封装起来，并且使他们之间可以互换</p><blockquote><p>这个主要用在写测试类的时候，比如有8种排序算法，每次只需要改变当前的策略，即可实现相应的测试检查</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Strategy &#123;</span><br><span class="line">    <span class="comment">// 策略模式运算法则</span></span><br><span class="line">    doSomething(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> <span class="title">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> doSomething(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;使用的策略1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy2</span> <span class="title">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> doSomething(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;使用的策略2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextofStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _strategy: Strategy;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">strategy: Strategy</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">strategy</span>(<span class="params">strategy: Strategy</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装后的策略方法</span></span><br><span class="line">    doOperation(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._strategy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strategy1: Strategy = <span class="keyword">new</span> ConcreteStrategy1();</span><br><span class="line">    <span class="keyword">const</span> strategy2: Strategy = <span class="keyword">new</span> ConcreteStrategy2();</span><br><span class="line">    <span class="keyword">const</span> context: ContextofStrategy = <span class="keyword">new</span> ContextofStrategy(strategy1);</span><br><span class="line">    context.doOperation();</span><br><span class="line">    context.strategy = strategy2;</span><br><span class="line">    context.doOperation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>这个也是一个比较流行的模式，比如跟事件类有关的类。通过某一个事件，触发对该事件订阅的模型发生数据变化。</p><blockquote><p> 比如在一个游戏框架中，键盘和鼠标事件的触发，会使得全局订阅者集合中相对应的事件的订阅者触发自己的行为事件<br>又比如在mvvm模型中，Object.defineProperty中通过set方法调用的时候，会触发所有订阅这的更新</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Observer &#123;</span><br><span class="line">    update(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者模式</span></span><br><span class="line"><span class="keyword">interface</span> AbstractSubject &#123;</span><br><span class="line">    <span class="comment">// 注册订阅者</span></span><br><span class="line">    registerObserver(observer: Observer): <span class="built_in">void</span>;</span><br><span class="line">    remove(observer: Observer): <span class="built_in">void</span>;</span><br><span class="line">    <span class="comment">// 通知订阅者,让每个订阅者调用自己的update方法</span></span><br><span class="line">    notifyObservers(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="title">implements</span> <span class="title">AbstractSubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> observers: <span class="built_in">Array</span>&lt;Observer&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> registerObserver(observer: Observer): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.push(observer);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> remove(observer: Observer): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> observerIndex = <span class="built_in">this</span>.observers.findIndex(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value == observer;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        observerIndex &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.observers.splice(observerIndex, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> notifyObservers(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer.update())</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="title">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> update(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;已经执行更新操作1，值为&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="title">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> update(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;已经执行更新操作2，值为&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布订阅模式</span></span><br><span class="line"><span class="keyword">interface</span> Publish &#123;</span><br><span class="line">    registerObserver(eventType: <span class="built_in">string</span>, <span class="attr">subscribe</span>: Subscribe): <span class="built_in">void</span>;</span><br><span class="line">    remove(eventType: <span class="built_in">string</span>, subscribe?: Subscribe): <span class="built_in">void</span>;</span><br><span class="line">    notifyObservers(eventType: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SubscribesObject &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">Array</span>&lt;Subscribe&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePublish</span> <span class="title">implements</span> <span class="title">Publish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> subscribes: SubscribesObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subscribes = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registerObserver(eventType: <span class="built_in">string</span>, <span class="attr">subscribe</span>: Subscribe): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.subscribes[eventType]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.subscribes[eventType] = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.subscribes[eventType].push(subscribe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove(eventType: <span class="built_in">string</span>, subscribe?: Subscribe): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> subscribeArray = <span class="built_in">this</span>.subscribes[eventType];</span><br><span class="line">        <span class="keyword">if</span> (subscribeArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!subscribe) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="built_in">this</span>.subscribes[eventType];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subscribeArray.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (subscribe === subscribeArray[i]) &#123;</span><br><span class="line">                        subscribeArray.splice(i, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifyObservers(eventType: <span class="built_in">string</span>, ...args: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> subscribes = <span class="built_in">this</span>.subscribes[eventType];</span><br><span class="line">        <span class="keyword">if</span> (subscribes) &#123;</span><br><span class="line">            subscribes.forEach(<span class="function"><span class="params">subscribe</span> =&gt;</span> subscribe.update(...args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Subscribe &#123;</span><br><span class="line">    update(...value: <span class="built_in">any</span>[]): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubscribe1</span> <span class="title">implements</span> <span class="title">Subscribe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> update(...value: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;已经执行更新操作1，值为&#x27;</span>, ...value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubscribe2</span> <span class="title">implements</span> <span class="title">Subscribe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> update(...value: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;已经执行更新操作2，值为&#x27;</span>, ...value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> publish = <span class="keyword">new</span> ConcretePublish();</span><br><span class="line">    <span class="keyword">const</span> subscribe1 = <span class="keyword">new</span> ConcreteSubscribe1();</span><br><span class="line">    <span class="keyword">const</span> subscribe2 = <span class="keyword">new</span> ConcreteSubscribe2();</span><br><span class="line"></span><br><span class="line">    publish.registerObserver(<span class="string">&#x27;1&#x27;</span>, subscribe1);</span><br><span class="line">    publish.registerObserver(<span class="string">&#x27;2&#x27;</span>, subscribe2);</span><br><span class="line"></span><br><span class="line">    publish.notifyObservers(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;22222&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式系列之结构型模式</title>
      <link href="2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>为了解决怎样组装现有的类，设计他们的交互方式，从而实现一定的功能</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将一个类的接口变换为客户端所期待的另一个接口<br>从而使原本因接口不匹配而无法在一起工作的两个类能够一起工作<br>也就是说原本的类或者实例通过适配器的方式添加了新的功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口，定义了多种方法</span></span><br><span class="line"><span class="keyword">interface</span> Target &#123;</span><br><span class="line">    request(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> specificRequest(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配器给原类添加新的接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="title">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> request(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.specificRequest()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>动态的将新功能附加到对象上<br>装饰者模式也是一种非常常见的模式，其实也就是我们日常使用的装饰器，将公共的方法变成一个装饰方法或者装饰类。<br>这样就能简化代码量。</p><blockquote><p>比如在后端中每个接口都需要判断用户是否登录，可以写一个装饰方法定义用户的登录状态<br>这样每个需要判断用户登录态的接口直接用装饰器装饰即可。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> operate(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> method(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> operate(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.method()</span><br><span class="line">        <span class="built_in">super</span>.operate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>主要用来描述部分和整体的关系，将对象组合成树形结构表示部分-整体的结构层次</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> doOperation(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">public</span> add(component: Component): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> remove(component: Component): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> getChildren(): <span class="built_in">Array</span>&lt;Component&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> componentList: <span class="built_in">any</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">        <span class="built_in">this</span>.componentList = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> doOperation(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> add(component: Component): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentList.push(component)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> remove(component: Component): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> componentIndex = <span class="built_in">this</span>.componentList.findIndex(<span class="function">(<span class="params">value: Component, index: <span class="built_in">Number</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value == component;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.componentList.splice(componentIndex, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getChildren(): <span class="built_in">Array</span>&lt;Component&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.componentList</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> doOperation(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root: Component = <span class="keyword">new</span> Composite(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> node1: Component = <span class="keyword">new</span> Leaf(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> node2: Component = <span class="keyword">new</span> Composite(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> node3: Component = <span class="keyword">new</span> Leaf(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    root.add(node1);</span><br><span class="line">    root.add(node2);</span><br><span class="line">    root.add(node3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> node2_1: Component = <span class="keyword">new</span> Leaf(<span class="string">&quot;2_1&quot;</span>);</span><br><span class="line">    node2.add(node2_1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> children1 = root.getChildren();</span><br><span class="line">    <span class="built_in">console</span>.log(children1);</span><br><span class="line"></span><br><span class="line">    root.remove(node2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> children2 = root.getChildren();</span><br><span class="line">    <span class="built_in">console</span>.log(children2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>为其他对象提供一种代理以控制对这个对象的询问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理</span></span><br><span class="line"><span class="keyword">interface</span> Subject &#123;</span><br><span class="line">    doOperation(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="title">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> doOperation(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;RealSubject running&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProxy</span> <span class="title">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> target: Subject;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">realSubject: Subject</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = realSubject</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">doOperation</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;proxy class&#x27;</span>)</span><br><span class="line">        <span class="built_in">this</span>.target.doOperation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> realSubject: Subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">    <span class="keyword">const</span> myProxy: Subject = <span class="keyword">new</span> MyProxy(realSubject);</span><br><span class="line"></span><br><span class="line">    myProxy.doOperation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式系列之创建型模式</title>
      <link href="2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>创建型模式就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。也就说对创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>一个类仅有一个实例，不管什么时候我们要确保该类的只有一个对象实例存在。</p><blockquote><p>这个在游戏中用的比较多，比如打砖块游戏中，在砖块类中和挡板类中都使用了小球这个类。<br>但是小球这个类的属性都是变化的，而小球只能是一个单独的实例。这个时候就需要单例模式</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> instance: Singleton = <span class="keyword">new</span> Singleton()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> getInstance(): Singleton &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>一个创建对象的类，这个类封装实例化对象行为</p><blockquote><p>这个在游戏中用的比较多，比如打飞机游戏中有多种飞机，可以用工厂模式创建相应的飞机实例</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Product &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1</span> <span class="title">implements</span> <span class="title">Product</span> </span>&#123; <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2</span> <span class="title">implements</span> <span class="title">Product</span> </span>&#123; <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> createProduct(<span class="keyword">type</span>: <span class="built_in">number</span>): Product &#123;</span><br><span class="line">        <span class="keyword">const</span> mp = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="keyword">new</span> Product1(),</span><br><span class="line">            <span class="number">2</span>: <span class="keyword">new</span> Product2()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[<span class="keyword">type</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模式, 定义了一个创建对象的抽象方法, 由子类决定实例化的类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> createProduct(<span class="keyword">type</span>: <span class="built_in">number</span>): Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> createProduct(<span class="keyword">type</span>: <span class="built_in">number</span>): Product &#123;</span><br><span class="line">        <span class="keyword">const</span> mp = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="keyword">new</span> Product1(),</span><br><span class="line">            <span class="number">2</span>: <span class="keyword">new</span> Product2()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[<span class="keyword">type</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sass用法大全</title>
      <link href="2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/sass%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
      <url>2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/sass%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这是一篇关于sass的语法大全</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="comment">/* 默认变量: */</span></span><br><span class="line"><span class="variable">$color</span>: <span class="number">#fff</span> !default;</span><br><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">2</span>;</span><br><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">1.5</span> !default;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="variable">$baseLineHeight</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">        <span class="selector-tag">header</span> &amp; &#123;</span><br><span class="line">            <span class="attribute">color</span>:green;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后的css代码：</span></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性嵌套"><a href="#属性嵌套" class="headerlink" title="属性嵌套"></a>属性嵌套</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: &#123;</span><br><span class="line">        top: <span class="number">1px</span> solid red;</span><br><span class="line">        <span class="attribute">bottom</span>: <span class="number">1px</span> solid green;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">编译后的css代码：</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明混合宏（复用的公共样式）"><a href="#声明混合宏（复用的公共样式）" class="headerlink" title="声明混合宏（复用的公共样式）"></a>声明混合宏（复用的公共样式）</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> border-radius(<span class="variable">$radius</span>: <span class="number">5px</span>)&#123;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@mixin</span> box-shadow(<span class="variable">$shadow</span>...) &#123;</span><br><span class="line">    <span class="comment">/* @if @else 用法 */</span></span><br><span class="line">    <span class="keyword">@if</span> length(<span class="variable">$shadow</span>) &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">@include</span> prefixer(box-shaow, <span class="variable">$shadow</span>);</span><br><span class="line">    &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="variable">$shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">4px</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">3</span>)</span><br><span class="line">        @include prefixer(box-shaow, <span class="variable">$shadow</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用混合宏"><a href="#调用混合宏" class="headerlink" title="调用混合宏"></a>调用混合宏</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> border-radius(<span class="number">3px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展和继承"><a href="#扩展和继承" class="headerlink" title="扩展和继承"></a>扩展和继承</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f36</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="keyword">@extend</span> .btn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sass-占位符"><a href="#sass-占位符" class="headerlink" title="[sass]占位符%"></a>[sass]占位符%</h2><p>编译出来的代码会将相同的代码合并在一起</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%mt5&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %mt5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %mt5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//   编译后的css代码：</span></span><br><span class="line"><span class="selector-class">.btn</span>, <span class="selector-class">.block</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其他-插值-逻辑运算-加减乘除"><a href="#其他-插值-逻辑运算-加减乘除" class="headerlink" title="其他(插值: #{}, 逻辑运算: 加减乘除)"></a>其他(插值: #{}, 逻辑运算: 加减乘除)</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$col-width</span>: <span class="number">60px</span>;</span><br><span class="line"><span class="variable">$col-gap</span>: <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* for循环</span></span><br><span class="line"><span class="comment">*@for $i from &lt;start&gt; through &lt;end&gt;</span></span><br><span class="line"><span class="comment">*@for $i from &lt;start&gt; to &lt;end&gt;</span></span><br><span class="line"><span class="comment">*through 表示包括 end 这个数，而 to 则不包括 end 这个数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">12</span> &#123;</span><br><span class="line">    <span class="selector-class">.col-</span>#&#123;<span class="variable">$i</span>&#125;&#123;</span><br><span class="line">        <span class="attribute">width</span>: (<span class="variable">$col-width</span> + <span class="variable">$col-gap</span>) * <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*列表 用()表示一组列表*/</span></span><br><span class="line"><span class="variable">$properties</span>: (margin, padding);</span><br><span class="line"><span class="keyword">@mixin</span> set-value(<span class="variable">$side</span>, <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="comment">/* each 遍历列表 */</span></span><br><span class="line">    <span class="keyword">@each</span> <span class="variable">$prop</span> in <span class="variable">$properties</span> &#123;</span><br><span class="line">        #&#123;<span class="variable">$prop</span>&#125;-#&#123;<span class="variable">$side</span>&#125;: <span class="variable">$value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.login-box</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> set-value(top, <span class="number">14px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> e(<span class="variable">$element</span>, <span class="variable">$content</span>) &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line">    &amp;__#&#123;<span class="variable">$element</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">        <span class="keyword">@each</span> <span class="variable">$k</span>, <span class="variable">$v</span> in <span class="variable">$content</span> &#123;</span><br><span class="line">            #&#123;<span class="variable">$k</span>&#125;: <span class="variable">$v</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@include e(<span class="string">&#x27;content&#x27;</span>, (<span class="string">&#x27;display&#x27;</span>: flex, <span class="string">&#x27;height&#x27;</span>: <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">/* while */</span><br><span class="line"><span class="variable">$types</span>: <span class="number">4</span>;</span><br><span class="line"><span class="variable">$type-width</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="keyword">@while</span> <span class="variable">$types</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="selector-class">.while-</span>#&#123;<span class="variable">$types</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">$type-width</span> + <span class="variable">$types</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$types</span>: <span class="variable">$types</span> - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*颜色可以相加*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    color: #010203 + #040506 /* #050709; */</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*函数*/</span></span><br><span class="line"><span class="keyword">@function</span> widthFn(<span class="variable">$n</span>) &#123;</span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$n</span> * <span class="variable">$twoWidth</span> + (<span class="variable">$n</span> - <span class="number">1</span>) * <span class="variable">$oneWidth</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 特殊函数</span></span><br><span class="line"><span class="comment">* unquote($string) 删除字符串中的引号</span></span><br><span class="line"><span class="comment">* quote($string) 给字符串添加引号</span></span><br><span class="line"><span class="comment">* to-upper-case() 字符串小写字母转换成大写字母</span></span><br><span class="line"><span class="comment">* to-lower-case() 字符串大写字母转换成小写字母</span></span><br><span class="line"><span class="comment">* percentage() 将一个不带单位的数字转换成百分比形式</span></span><br><span class="line"><span class="comment">* round() 函数可以将一个数四舍五入为一个最接近的整数</span></span><br><span class="line"><span class="comment">* ceil() 函数将一个数转换成最接近于自己的整数</span></span><br><span class="line"><span class="comment">* floor() 函数刚好与 ceil() 函数功能相反，其主要将一个数去除其小数部分</span></span><br><span class="line"><span class="comment">* abs() 函数会返回一个数的绝对值</span></span><br><span class="line"><span class="comment">* min()函数功能主要是在多个数之中找到最小的一个 min(1px,2,3px)</span></span><br><span class="line"><span class="comment">* random() 获取一个随机数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*列表函数</span></span><br><span class="line"><span class="comment">* nth($list,$n) 用来指定列表中某个位置的值</span></span><br><span class="line"><span class="comment">* join() 函数是将两个列表连接合并成一个列表 join (10px) (20px)</span></span><br><span class="line"><span class="comment">* length() 计算列表长度</span></span><br><span class="line"><span class="comment">* append() 用来将某个值插入到列表中，并且处于最末位</span></span><br><span class="line"><span class="comment">* index() 你找到某个值在列表中所处的位置 index(solid red, red)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript语法大全</title>
      <link href="2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/typescript%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
      <url>2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/typescript%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是一篇typescript的语法说明书</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br><span class="line">tsc hello.ts 编译ts文件</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boolean:</span></span><br><span class="line">    <span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// number, string, void, null, undefined,any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// union:</span></span><br><span class="line">    <span class="keyword">let</span> myFavoriateNumber: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces: 对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）</span></span><br><span class="line">    <span class="keyword">interface</span>: Person &#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        age?: <span class="built_in">number</span>; <span class="comment">// age是可选属性, 用 ？表示可选</span></span><br><span class="line">        [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 允许有任意的属性</span></span><br><span class="line">        <span class="keyword">readonly</span> id: <span class="built_in">number</span> <span class="comment">// 只读属性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array:</span></span><br><span class="line">    <span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = <span class="string">&#x27;cat&#x27;</span>, lastName?:<span class="built_in">string</span>, ...items: <span class="built_in">any</span>[]</span>):<span class="title">string</span></span>&#123;</span><br><span class="line">      <span class="keyword">let</span> r: <span class="built_in">number</span>[] = []</span><br><span class="line">      items.forEach(<span class="function"><span class="params">item</span> =&gt;</span> r.push(item))</span><br><span class="line">      <span class="keyword">return</span> lastName ? firstName + lastName : firstName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    swim(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">animal: Cat | Fish</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用类型断言 &quot;值 as&quot; 的方式解决了联合类型变量只能访问共有属性的问题</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> (animal <span class="keyword">as</span> Fish).swim === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).foo = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="声明与导出"><a href="#声明与导出" class="headerlink" title="声明与导出"></a>声明与导出</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span></span><br><span class="line"><span class="comment">// 声明全局方法</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">// 声明全局类</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">class</span></span></span><br><span class="line"><span class="function">// 声明全局枚举类型</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">enum</span></span></span><br><span class="line"><span class="function">// 声明（含有子属性的）全局对象</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">namespace</span></span></span><br><span class="line"><span class="function">// 声明全局类型</span></span><br><span class="line"><span class="function"><span class="title">interface</span> 和 <span class="title">type</span></span></span><br><span class="line"><span class="function">// 导出变量</span></span><br><span class="line"><span class="function"><span class="title">export</span></span></span><br><span class="line"><span class="function">// 导出（含有子属性的）对象</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">namespace</span></span></span><br><span class="line"><span class="function">// <span class="title">ES6</span> 默认导出</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">default</span></span></span><br><span class="line"><span class="function">// 导出模块</span></span><br><span class="line"><span class="function"><span class="title">export</span> = <span class="title">commonjs</span></span></span><br><span class="line"><span class="function">// <span class="title">UMD</span> 库声明全局变量</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">as</span> <span class="title">namespace</span></span></span><br><span class="line"><span class="function">// 扩展全局变量</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">global</span></span></span><br><span class="line"><span class="function">// 扩展模块</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">module</span></span></span><br><span class="line"><span class="function">/// &lt;<span class="title">reference</span> /&gt; 三斜线指令</span></span><br><span class="line"><span class="function">// 在引入外部文件的时候，比如<span class="title">jquery</span>,因为<span class="title">ts</span>中在编译过程的时候，需要每个变量进行定义</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">var</span> <span class="title">jQuery</span>: (<span class="params">selector: <span class="built_in">string</span></span>) =&gt; <span class="title">any</span></span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">namespace</span> <span class="title">JQuery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function">() =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver</span><br></pre></td></tr></table></figure><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventNames = <span class="string">&#x27;click&#x27;</span> | <span class="string">&#x27;scroll&#x27;</span> | <span class="string">&#x27;mousemove&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;hello&#x27;</span>), <span class="string">&#x27;scroll&#x27;</span>);  <span class="comment">// 没问题</span></span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;world&#x27;</span>), <span class="string">&#x27;dblclick&#x27;</span>); <span class="comment">// 报错，event 不能为 &#x27;dblclick&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;tom&#x27;</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认第一个是0，依次递增加一</span></span><br><span class="line"><span class="built_in">enum</span> Days &#123;sun, mon, tue, wed, thr, fir, sat&#125;</span><br><span class="line"><span class="built_in">enum</span> Days &#123;sun=<span class="number">7</span>, mon=<span class="number">1</span>, tue, wed, thr, fri, sat&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类的抽象方法，继承的类要具体实现</span></span><br><span class="line"><span class="keyword">public</span>, <span class="keyword">private</span>, protect, <span class="keyword">static</span>, <span class="keyword">readonly</span>, <span class="keyword">abstract</span></span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口可以继承接口</span></span><br><span class="line"><span class="comment">// 一个类可以实现多个接口</span></span><br><span class="line"><span class="comment">// 接口可以继承类</span></span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert():<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;securitydoor&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法</span></span><br><span class="line"><span class="comment">// 但是可以通过约束的办法解决这个问题</span></span><br><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>):<span class="title">Array</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">create&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">tuple: [T, U]</span>): [<span class="title">U</span>, <span class="title">T</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([<span class="number">7</span>, <span class="string">&#x27;seven&#x27;</span>]); <span class="comment">// [&#x27;seven&#x27;, 7]</span></span><br><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line">nterface CreateArrayFunc&lt;T&gt; &#123;</span><br><span class="line">    (length: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">createArray = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span></span><br><span class="line"><span class="comment">// 泛型参数的默认类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span> = <span class="title">string</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法思想</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口，"><a href="#滑动窗口，" class="headerlink" title="滑动窗口，"></a>滑动窗口，</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用在数组和字符串的操作上面。</span><br><span class="line">可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续(单调递增或者单调递减)</span><br><span class="line">因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。</span><br><span class="line">往往类似于“ 请找到满足 xx 的最 x 的区间（子串、子数组）的 xx ”</span><br></pre></td></tr></table></figure><h1 id="动态规划，"><a href="#动态规划，" class="headerlink" title="动态规划，"></a>动态规划，</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是一种暴力方法，下一步的操作时通过上一步的某条件达到的。</span><br><span class="line">写出表达式和约束条件即可达到目的</span><br><span class="line">动态规划一般会超出时间限制，如果是dp就生成一维数组，如果是dp[i][j]就生成二维数组。</span><br><span class="line">反正就是个多维数组保存每一种情况下的办法。</span><br></pre></td></tr></table></figure><h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个问题可以拆成两个或多个“相似”的小问题，就一定要用分治法。</span><br><span class="line">因为小问题可以拆到简单的直接求解</span><br></pre></td></tr></table></figure><h1 id="回朔法，深度遍历dfs"><a href="#回朔法，深度遍历dfs" class="headerlink" title="回朔法，深度遍历dfs"></a>回朔法，深度遍历dfs</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是一种暴力方法</span><br><span class="line">试探性一步一步的看能否到达终点。</span><br><span class="line">如果当前的方法可行满足约束条件，且下一步操作也可行。就往下走</span><br><span class="line">如果下一步是死路就不往下一步走，悔棋，更换当前的可行方法是自己满足约束条件</span><br></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">维护一个单调递增或者单调递减的栈。如果是递减栈，遇到一个比栈顶元素还要小的元素，</span><br><span class="line">就一直推出元素直到这个元素作为栈顶元素时依旧是一个递减栈。</span><br><span class="line">通常用这种数据结构解决一种公共区间内最大或最小值。</span><br><span class="line">比如木板长短不一怎样能打最多的水,柱状图的最大矩形。</span><br></pre></td></tr></table></figure><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种搜索方法，在一种具有单调性的队列中，快速搜索目标</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>如果遇到必须用暴力的算法来解决的问题，一般都会用一个栈来进行维护减少重复操作。<br>就比如回朔法，给之前走过的可行步骤做一个存储，如果下一步骤可行的操作在存储里存在<br>就调用存储的方法</li><li>能用dp算法的一般也能用回朔法。如果当前可选择的方法量比较少推荐用回溯</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="匹配字符串之kmp"><a href="#匹配字符串之kmp" class="headerlink" title="匹配字符串之kmp"></a>匹配字符串之kmp</h2><blockquote><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">题目来源</a><br>思路：<br>这里使用了一个《部分匹配表》的数据结构<br>字符串与搜索词依次比较，通过‘移动位数=已知匹配字符串数-对应的部分匹配值’来<br>移动搜索词。注意这里的移动是指移动字符串的索引位数。<br>“前缀”指除了最后一个字符以外，一个字符串的全部头部组合<br>“后缀”指除了第一个字符以外，一个字符串的全部尾部组合<br>部分匹配值：前缀与后缀的最长的共有元素长度<br>字符串：‘abcdabd’<br>前缀:[a, ab, abc, abcd, abcda, abcdb],<br>后缀: [bcdabd, cdabd, dabd, abd, bd, d]<br>部分匹配值: 0<br>字符串：‘abcda’<br>前缀:[a, ab, abc, abcd],<br>后缀: [bcda, cda, da, a]<br>部分匹配值: 1<br>str: bbc abcdab abcdabcdabde<br>search: abcdabd<br>=&gt;<br>bbc abcdab abcdabcdabde<br>____abcdabd(4 = 6 - 2)(移动位数=已知匹配字符串数-对应的部分匹配值)<br>=&gt;<br>bbc abcdab abcdabcdabde<br>________abcdabd(2 = 2 - 0)<br>=&gt;<br>bbc abcdab abcdabcdabde<br>__________abcdabd<br>=&gt;<br>bbc abcdab abcdabcdabde<br>___________abcdabd(4 = 6 - 2)<br>=&gt;<br>bbc abcdab abcdabcdabde<br>_______________abcdabd(4 = 6 - 2)<br>=&gt;<br>over</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取前缀</span></span><br><span class="line"><span class="keyword">const</span> getPrefix = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    arr.splice(str.length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">            result.push(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr.slice(<span class="number">0</span>, index + <span class="number">1</span>).join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取后缀</span></span><br><span class="line"><span class="keyword">const</span> getSuffix = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s = str.slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> s) &#123;</span><br><span class="line">        result.push(s.slice(key))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取前缀与后缀的最长公共子集的长度</span></span><br><span class="line"><span class="keyword">const</span> commonFix = <span class="function">(<span class="params">prefix, suffix</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> pre <span class="keyword">of</span> prefix) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> suff <span class="keyword">of</span> suffix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre === suff) &#123;</span><br><span class="line">                maxLen = pre.length &gt; maxLen ? pre.length : maxLen</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到部分匹配表</span></span><br><span class="line"><span class="keyword">const</span> getMatchTable = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        map.set(i + <span class="number">1</span>, commonFix(</span><br><span class="line">            getPrefix(str.slice(<span class="number">0</span>, i + <span class="number">1</span>)),</span><br><span class="line">            getSuffix(str.slice(<span class="number">0</span>, i + <span class="number">1</span>))</span><br><span class="line">        ))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> match = <span class="function">(<span class="params">str, search</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> matchedLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> table = getMatchTable(search)</span><br><span class="line">    <span class="keyword">let</span> jump = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jump) &#123;</span><br><span class="line">            jump -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (char === search[matchedLen]) &#123;</span><br><span class="line">            matchedLen += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (matchedLen === search.length) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (matchedLen) &#123;</span><br><span class="line">                <span class="comment">// ‘移动位数=已知匹配字符串数-对应的部分匹配值’</span></span><br><span class="line">                jump = matchedLen - table.get(matchedLen)</span><br><span class="line">                matchedLen = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><blockquote><p>[题目来源](<a href="https://leetcode-cn.com/problems/ti-huan-kon">https://leetcode-cn.com/problems/ti-huan-kon</a> g-ge-lcof/)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> replaceSpace = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&#x27; &#x27;</span>).join(<span class="string">&#x27;%20&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><blockquote><p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">题目来源</a><br>思路：使用有限状态自动机<br>状态自动机:<br>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：<br>有一个特殊的状态，被称作「初始状态」。<br>还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。<br>起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝</p><p>枚举字符类型：空格 「 」、数字「 0—9 」 、正负号 「 +- 」 、小数点 「 . 」 、幂符号 「 eE 」<br>按照字符串从左到右的顺序，定义以下 9 种状态。<br>0: 开始的空格<br>1: 幂符号前的正负号<br>2: 小数点前的数字<br>3: 小数点、小数点后的数字<br>4: 当小数点前为空格时，小数点、小数点后的数字<br>5: 幂符号<br>6: 幂符号后的正负号<br>7: 幂符号后的数字<br>8: 结尾的空格</p><p>数值（按顺序）可以分成以下几个部分：<br>1: 若干空格<br>2: 一个小数或者整数<br>3:（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个整数<br>4: 若干空格</p><p>小数的定义：<br>1:（可选）一个符号字符（’+’ 或 ‘-‘）<br>2: 下述格式之一：<br>至少一位数字，后面跟着一个点 ‘.’ 比如’1.’<br>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字 比如’1.1’<br>一个点 ‘.’ ，后面跟着至少一位数字 比如’.1’</p><p>整数的定义：<br>1:（可选）一个符号字符（’+’ 或 ‘-‘）<br>2: 至少一位数字<br>其中终点为2，3，7，8的状态都是接受状态<br>*/<br>// ‘5.2e-3 ‘</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CharType = &#123;</span><br><span class="line">    <span class="string">&#x27;blank&#x27;</span>: <span class="string">&#x27;blank&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;sign&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;digit&#x27;</span>: <span class="string">&#x27;digit&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dot&#x27;</span>: <span class="string">&#x27;dot&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 状态转移表2, 3, 7</span></span><br><span class="line"><span class="comment">// 状态转移表显示了所有的路线方案</span></span><br><span class="line"><span class="keyword">const</span> states = [</span><br><span class="line">    <span class="comment">// 0: 开始的空格</span></span><br><span class="line">    &#123; <span class="string">&#x27;blank&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;sign&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;digit&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;dot&#x27;</span>: <span class="number">4</span> &#125;,</span><br><span class="line">    <span class="comment">// 1: 幂符号前的正负号</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;dot&#x27;</span>: <span class="number">4</span> &#125;,</span><br><span class="line">    <span class="comment">// 2: 小数点前的数字</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;dot&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;blank&#x27;</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    <span class="comment">// 3: 小数点、小数点后的数字</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;blank&#x27;</span>: <span class="number">8</span> &#125;,</span><br><span class="line">    <span class="comment">// 4: 当小数点前为空格时，小数点、小数点后的数字</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="comment">// 5: 幂符号</span></span><br><span class="line">    &#123; <span class="string">&#x27;sign&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;digit&#x27;</span>: <span class="number">7</span> &#125;,</span><br><span class="line">    <span class="comment">// 6: 幂符号后的正负号</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">7</span> &#125;,</span><br><span class="line">    <span class="comment">// 7: 幂符号后的数字</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;blank&#x27;</span>: <span class="number">8</span> &#125;,</span><br><span class="line">    <span class="comment">// 8: 结尾的空格</span></span><br><span class="line">    &#123; <span class="string">&#x27;blank&#x27;</span>: <span class="number">8</span> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> isNumber = <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> t = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// 状态转移循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= char &amp;&amp; <span class="string">&#x27;9&#x27;</span> &gt;= char) &#123;</span><br><span class="line">            t = <span class="string">&#x27;digit&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;+-&#x27;</span>.includes(char)) &#123;</span><br><span class="line">            t = <span class="string">&#x27;sign&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;eE&#x27;</span>.includes(char)) &#123;</span><br><span class="line">            t = <span class="string">&#x27;e&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            t = <span class="string">&#x27;dot&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            t = <span class="string">&#x27;blank&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = <span class="string">&#x27;?&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!states[p][t]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        p = states[p][t]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>].includes(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><blockquote><p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">题目来源</a><br>思路:<br>深度:    选择<br>depth0: a or b or c<br>depth1: a or b or c<br>depth2: a or b or c<br>depth3: back</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permutation = <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">depth</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.length === s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!result.has(path.join(<span class="string">&#x27;&#x27;</span>))) &#123;</span><br><span class="line">                result.add(path.join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.has(i)) &#123;</span><br><span class="line">                path.push(s[i])</span><br><span class="line">                visited.add(i)</span><br><span class="line">                dfs(depth + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">                visited.delete(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><blockquote><p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">题目来源</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseLeftWords = <span class="function"><span class="keyword">function</span> (<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.slice(n) + s.slice(<span class="number">0</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="2021/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这是一个linux常用命令大全</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl+d</td><td>键盘输入结束或退出终端</td></tr><tr><td>Ctrl+s</td><td>暂停当前程序，暂停后按下任意键恢复运行</td></tr><tr><td>Ctrl+z</td><td>将当前程序放到后台运行，恢复到前台为命令fg</td></tr><tr><td>Ctrl+a</td><td>将光标移至输入行头，相当于Home键</td></tr><tr><td>Ctrl+e</td><td>将光标移至输入行末，相当于End键</td></tr><tr><td>Ctrl+k</td><td>删除从光标所在位置到行末</td></tr><tr><td>Ctrl+c</td><td>使用键来强行终止当前程序</td></tr><tr><td>Alt+Backspace</td><td>向前删除一个单词</td></tr><tr><td>Shift+PgUp</td><td>将终端显示向上滚动</td></tr><tr><td>Shift+PgDn</td><td>将终端显示向下滚动</td></tr></tbody></table><h2 id="功能手册（man"><a href="#功能手册（man" class="headerlink" title="功能手册（man)"></a>功能手册（man)</h2><p>可以使用功能手册查看一个命令的具体用法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ man &lt;command_type&gt; &lt;command_name&gt;</span><br><span class="line"><span class="comment"># `man 1 ls` 这条命令可以查看`ls`有哪些用法</span></span><br><span class="line"><span class="comment"># comman_type 的选择如下</span></span><br><span class="line"><span class="comment"># 1一般命令</span></span><br><span class="line"><span class="comment"># 2系统调用</span></span><br><span class="line"><span class="comment"># 3库函数，涵盖了C标准函数库</span></span><br><span class="line"><span class="comment"># 4特殊文件（通常是/dev中的设备）和驱动程序</span></span><br><span class="line"><span class="comment"># 5文件格式和约定</span></span><br><span class="line"><span class="comment"># 6游戏和屏保</span></span><br><span class="line"><span class="comment"># 7杂项</span></span><br><span class="line"><span class="comment"># 8系统管理命令和守护进程</span></span><br></pre></td></tr></table></figure><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul><li>查看用户<br>具体的用法可以： <code>man 1 who</code> 打开功能手册<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前用户的两种写法</span></span><br><span class="line">who am i</span><br><span class="line">who mom likes</span><br></pre></td></tr></table></figure></li><li>创建用户<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新用户 woyao</span></span><br><span class="line">sudo adduser woyao</span><br><span class="line"><span class="comment"># 更新用户密码</span></span><br><span class="line">passwd woyao</span><br></pre></td></tr></table></figure></li><li>切换用户<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su -l woyao</span><br><span class="line">su woyao</span><br></pre></td></tr></table></figure></li><li>删除用户<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo userdel woyao -f</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><ul><li>创建<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line">touch 1.txt 2.txt</span><br><span class="line">touch love_&#123;1..10&#125;_woyao.txt</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir mydir</span><br><span class="line">mkdir -p user/woyao/name</span><br></pre></td></tr></table></figure></li><li>复制<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line">cp a.txt user/woyao/name</span><br><span class="line"><span class="comment"># 复制目录</span></span><br><span class="line"><span class="comment"># 将father内的子文件复制到family文件夹</span></span><br><span class="line">cp -r father family</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">rm a.txt</span><br><span class="line">rm -f a.txt</span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line">rm -rf father</span><br></pre></td></tr></table></figure></li><li>移动文件和文件重命名：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.txt 移动到 father</span></span><br><span class="line">mv a.txt father</span><br><span class="line"><span class="comment"># a.txt 重命名为b.txt</span></span><br><span class="line">mv a.txt b.txt</span><br><span class="line"><span class="comment"># 批量将后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件:</span></span><br><span class="line">rename <span class="string">&#x27;s/.txt/.c/&#x27;</span> *.txt</span><br><span class="line"><span class="comment"># 批量将文件，文件名和后缀改为大写:</span></span><br><span class="line">rename <span class="string">&#x27;y/a-z/A-Z/&#x27;</span> *.c</span><br></pre></td></tr></table></figure></li><li>查看<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt</span><br><span class="line"><span class="comment"># -n 参数显示行号</span></span><br><span class="line">cat -n a.txt</span><br><span class="line"><span class="comment"># 更多显示</span></span><br><span class="line">more a.txt</span><br><span class="line"><span class="comment"># 显示一部分</span></span><br><span class="line">less a.txt</span><br><span class="line"><span class="comment"># 文件的最后一行</span></span><br><span class="line">tail -n 1 /father/son/grandson/a.txt</span><br><span class="line"><span class="comment"># 文件的开始</span></span><br><span class="line">head b.txt</span><br><span class="line"><span class="comment"># 查看文件类型</span></span><br><span class="line">file a.txt</span><br><span class="line"><span class="comment"># 查看文件大小</span></span><br><span class="line">du -h -d 0 *.zip ~ | sort</span><br><span class="line">du -h woyao.zip</span><br></pre></td></tr></table></figure></li><li>搜索<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配所有文件名带a.txt的路径</span></span><br><span class="line">locate a.txt</span><br><span class="line"><span class="comment"># 在root目录下，查找有a.txt的路径</span></span><br><span class="line">find /root/ -name a.txt</span><br></pre></td></tr></table></figure></li><li>文件权限管理<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#x27;r&#x27;读4， &#x27;w&#x27;写2， &#x27;x&#x27;可执行1</span></span><br><span class="line"><span class="comment"># 600 等价于 -wr-----</span></span><br><span class="line"><span class="comment"># 644 等价于 -rw-r--r--</span></span><br><span class="line">chmod 600 a.txt</span><br><span class="line"><span class="comment"># 变更文件所有者</span></span><br><span class="line">sudo chown chen a.txt</span><br></pre></td></tr></table></figure></li><li>文件的压缩，解压，打包<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把woyao文件夹压缩成woyao.zip</span></span><br><span class="line"><span class="built_in">cd</span> /Desktop</span><br><span class="line">zip -r -q -o woyao.zip woyao</span><br><span class="line"><span class="comment"># 解压woyao.zip</span></span><br><span class="line">unzip woyao.zip</span><br><span class="line"><span class="comment"># 解压到指定目录</span></span><br><span class="line">unzip -q woyao.zip -d /Desktop/tomas</span><br><span class="line"><span class="comment"># 查看zip压缩包的内容</span></span><br><span class="line">unzip -l woyao.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把woyao文件夹压缩成woyao.tar</span></span><br><span class="line"><span class="built_in">cd</span> /Desktop</span><br><span class="line">tar -cf woyao.tar woyao</span><br><span class="line"><span class="comment"># 解压woyao.tar</span></span><br><span class="line">tar -xf woyao.tar</span><br><span class="line"><span class="comment"># 解压到指定目录</span></span><br><span class="line">tar -xf woyao.tar -C /Desktop/tomas</span><br><span class="line"><span class="comment"># 查看tar压缩包的内容</span></span><br><span class="line">tar -tf woyao.tar</span><br></pre></td></tr></table></figure></li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 declare 命令创建一个变量名为 tmp 的变量：</span></span><br><span class="line"><span class="built_in">declare</span> tmp</span><br><span class="line">tmp=woyao</span><br><span class="line"><span class="comment"># $符号用于表示引用一个变量的值，</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$tmp</span></span><br></pre></td></tr></table></figure><h2 id="骚操作-管道，重定向，…"><a href="#骚操作-管道，重定向，…" class="headerlink" title="骚操作(管道，重定向，…)"></a>骚操作(管道，重定向，…)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 家目录 ~</span></span><br><span class="line"><span class="built_in">echo</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重定向 &gt;, &gt;&gt;, tee</span></span><br><span class="line"><span class="comment"># 输出重定向覆盖模式(会覆盖原文件内容)</span></span><br><span class="line">cat b.gua &gt; c.gua</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello gua&quot;</span> &gt; c.gua</span><br><span class="line"><span class="comment"># 输出重定向的追加模式，不会覆盖文件内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello gua&quot;</span> &gt;&gt; c.gua</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道 |</span></span><br><span class="line"><span class="comment"># 管道符号把输出传给另一个程序作为输入</span></span><br><span class="line">cat c.gua | tee f.gua</span><br><span class="line"><span class="comment"># 显示历史密令中带有cat命令的字符串</span></span><br><span class="line"><span class="built_in">history</span> | grep cat</span><br><span class="line"></span><br><span class="line">tee: 把输入过来的数据输出到屏幕上并且重定向一份到文件</span><br><span class="line"><span class="built_in">history</span> | grep cat | tee new.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让程序在后台运行 &amp;</span></span><br><span class="line"><span class="comment"># 可以使运行的Firefox在终端后台运行</span></span><br><span class="line">firefox &amp;</span><br></pre></td></tr></table></figure><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><ol><li>安装shadowsocks<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-pip</span><br><span class="line">pip install shadowsocks</span><br><span class="line">sudo apt install nano</span><br><span class="line">nano /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><blockquote><p>shadowsocks.json 的配置如下<br>{<br> “server”:”主机的Ip地址是”,<br> “server_port”:8388,<br> “local_address”: “127.0.0.1”,<br> “local_port”:1080,<br> “password”:”密码”,<br> “timeout”:300,#超时<br> “method”:”aes-256-cfb”,#加密方式<br> “fast_open”: false<br>}</p></blockquote></li><li>后台运行<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></li><li>服务器开机自动启动，必要性不大，因为服务器基本不重启<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/usr/bin/ssserver -c /etc/shadowsocks.json -d&#x27;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列七</title>
      <link href="2021/04/20/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/"/>
      <url>2021/04/20/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="docker持续集成和部署"><a href="#docker持续集成和部署" class="headerlink" title="docker持续集成和部署"></a>docker持续集成和部署</h2><pre><code>现在是docker系列的最后一篇文章，这里直接实战吧。另外这一篇文章的代码没有测试。看一看就好，就不要实操了主要是了解一套部署流程，因为实际工作中的流程操作用到的镜像都不是这些</code></pre><h3 id="安装代码托管服务gogs"><a href="#安装代码托管服务gogs" class="headerlink" title="安装代码托管服务gogs"></a>安装代码托管服务gogs</h3><p>gogs 是一个类似github的代码托管服务, 它简单方便易于使用，我们使用它进行源代码管理.<br>将本目录下的docker-compose.yml 上传到服务器的 /root/gogs/docker-compose.yml<br>在服务器的 /root/gogs 中启动服务<code>docker-compose up -d</code>.<br>访问服务器的 3000 端口并初始化服务.</p><p>docker-compose.yml文件内容:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">    gogs:</span><br><span class="line">      image: gogs/gogs</span><br><span class="line">      restart: always</span><br><span class="line">      volumes:</span><br><span class="line">        <span class="comment"># 将 gogs 的数据文件存储在本机</span></span><br><span class="line">        - <span class="string">&quot;./data/gogs:/data&quot;</span></span><br><span class="line">      ports:</span><br><span class="line">        - <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">      environment:</span><br><span class="line">        - <span class="string">&quot;RUN_CROND=true&quot;</span></span><br><span class="line">      depends_on:</span><br><span class="line">        - postgres</span><br><span class="line">    postgres:</span><br><span class="line">      image: postgres:<span class="number">9.5</span></span><br><span class="line">      restart: always</span><br><span class="line">      volumes:</span><br><span class="line">        <span class="comment"># 将数据库文件存储到本机，以免丢失</span></span><br><span class="line">        - <span class="string">&quot;./data/postgresql:/var/lib/postgresql&quot;</span></span><br><span class="line">      ports:</span><br><span class="line">        - <span class="string">&quot;127.0.0.1:5432:5432&quot;</span></span><br><span class="line">      environment:</span><br><span class="line">        <span class="comment"># 数据库的连接信息</span></span><br><span class="line">        - <span class="string">&quot;POSTGRES_USER=admin&quot;</span></span><br><span class="line">        - <span class="string">&quot;POSTGRES_PASSWORD=123456&quot;</span></span><br><span class="line">        - <span class="string">&quot;POSTGRES_DB=gogs&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>打开 <code>&lt;server ip&gt;:3000</code>，会看到如下<br><img src="http://121.5.231.10:3000/docker/gogs.png" alt="gogs配置图片"><br>修改数据库用户为:admin, 用户密码：123456. 数据库主机改为你的服务器ip<br>点击安装</p></blockquote><h1 id="安装持续集成服务器"><a href="#安装持续集成服务器" class="headerlink" title="安装持续集成服务器"></a>安装持续集成服务器</h1><p>drone 是一个轻便简介的持续继承服务器程序。持续继承服务器的功能是我们提交代码后自动拉取，自动运行预先配置好的测试<br>以确保及发现代码中的bug。在代码测试失败后，我们可以配置通过微信，短信，邮箱等方式接收通知以便于即使修复bug<br>在代码测试成功后，我们可以配置自动部署到线上生产环境，这个过程叫持续部署<br>将本目录下的docker-compose.yml 上传到服务器的 /root/drone/docker-compose.yml. 在服务器的 /root/drone 中启动服务<code>docker-compose up -d</code><br>由于docker-compose.yml 中配置了gogs, 所以现在可以访问服务器的8000端口并使用gogs的账号登录, 它会在登录后自动同步我们存放在gogs中的项目<br>文件内容如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  server:</span><br><span class="line">    image: drone/drone:0.8.6</span><br><span class="line">    ports:</span><br><span class="line">      - 8000:8000</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/drone:/var/lib/drone/</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      <span class="comment"># false 表示禁止注册</span></span><br><span class="line">      - DRONE_OPEN=<span class="literal">false</span></span><br><span class="line">      <span class="comment"># DRONE_ADMIN 配置的用户作为管理员</span></span><br><span class="line">      - DRONE_ADMIN=kuaibiancheng.com</span><br><span class="line">      <span class="comment"># 本机主机名</span></span><br><span class="line">      - DRONE_HOST=http://111.231.98.114</span><br><span class="line">      <span class="comment"># 随机输入一个字符串</span></span><br><span class="line">      - DRONE_SECRET=random_string_123</span><br><span class="line">      <span class="comment"># 使用 gogs 服务</span></span><br><span class="line">      - DRONE_GOGS=<span class="literal">true</span></span><br><span class="line">      <span class="comment"># gogs 的地址</span></span><br><span class="line">      - DRONE_GOGS_URL=http://111.231.98.114:3000</span><br><span class="line">      <span class="comment"># gogs 的 git 用户名</span></span><br><span class="line">      - DRONE_GOGS_GIT_USERNAME=kuaibiancheng.com</span><br><span class="line">      <span class="comment"># 密码</span></span><br><span class="line">      - DRONE_GOGS_GIT_PASSWORD=123</span><br><span class="line">      <span class="comment"># 私有模式</span></span><br><span class="line">      - DRONE_GOGS_PRIVATE_MODE=<span class="literal">true</span></span><br><span class="line">      <span class="comment"># 关闭 ssl 验证（我们没有配置 https 访问）</span></span><br><span class="line">      - DRONE_GOGS_SKIP_VERIFY=<span class="literal">true</span></span><br><span class="line">  agent:</span><br><span class="line">    image: drone/agent:0.8.6</span><br><span class="line">    <span class="built_in">command</span>: agent</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - server</span><br><span class="line">    volumes:</span><br><span class="line">      <span class="comment"># 这样才可以在容器中使用宿主机的 Docker 服务</span></span><br><span class="line">      - /var/run/docker.sock:/var/run/docker.sock</span><br><span class="line">    environment:</span><br><span class="line">      <span class="comment"># secret 和上面的 DRONE_SECRET 配置一致</span></span><br><span class="line">      - DRONE_SECRET=random_string_123</span><br><span class="line">      <span class="comment"># 上面的 server 服务的 9000 端口</span></span><br><span class="line">      - DRONE_SERVER=server:9000</span><br></pre></td></tr></table></figure><h1 id="drone-的使用"><a href="#drone-的使用" class="headerlink" title="drone 的使用"></a>drone 的使用</h1><p>首先在drone 的网页中打开对仓库的监听, 点开仓库的详细页面<br>drone 使用 .drone.yml 文件配置自动测试. 如果drone监听了一个仓库，仓库的根目录下有.drone.yml文件<br>drone就会使用.drone.yml 文件中定义的步骤测试代码并做一些自定义的操作<br>自定义的操作包括通知，自动部署等<br>详见.drone.yml 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline:</span><br><span class="line">  run:</span><br><span class="line">    image: python:3.7-alpine3.8</span><br><span class="line">    commands:</span><br><span class="line">      - python3 test.py</span><br><span class="line">  deploy:</span><br><span class="line">    image: appleboy&#x2F;drone-ssh</span><br><span class="line">    host: 115.159.181.16</span><br><span class="line">    username: ubuntu</span><br><span class="line">    secrets: [ ssh_key ]</span><br><span class="line">    port: 22</span><br><span class="line">    script:</span><br><span class="line">      - cd &#x2F;home&#x2F;ubuntu&#x2F;test</span><br><span class="line">      - git pull</span><br><span class="line">      - sudo sh reload.sh</span><br></pre></td></tr></table></figure><p>如果你有其他需求，下面是drone 的文档地址，请自行参阅<br><a href="http://readme.drone.io/">http://readme.drone.io/</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><a href="http://plugins.drone.io/">插件</a></li><li><a href="http://docs.drone.io/pipeline-conditions/">让整个构建步骤只在某些分支发生变化的时候执行</a></li><li><a href="http://docs.drone.io/step-conditions/">让某一步动作在特定条件执行</a></li><li><a href="http://docs.drone.io/install-for-github/">让 Drone 支持 GitHub</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列六</title>
      <link href="2021/04/20/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/"/>
      <url>2021/04/20/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="docker在服务器部署"><a href="#docker在服务器部署" class="headerlink" title="docker在服务器部署"></a>docker在服务器部署</h2><h3 id="前面的文章也写过关于服务器怎么部署的"><a href="#前面的文章也写过关于服务器怎么部署的" class="headerlink" title="前面的文章也写过关于服务器怎么部署的"></a>前面的文章也写过关于服务器怎么部署的</h3><p>详见: <a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></p><h3 id="下面是一个安装docker的sh配置脚本"><a href="#下面是一个安装docker的sh配置脚本" class="headerlink" title="下面是一个安装docker的sh配置脚本"></a>下面是一个安装docker的sh配置脚本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方安装指南 Ubuntu 版本</span></span><br><span class="line"><span class="comment"># https://docs.docker.com/install/linux/docker-ce/ubuntu</span></span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 的源是 https，所以安装这些软件用于支持 https 的 apt 仓库</span></span><br><span class="line">sudo apt install -y apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG key</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置官方 Docker 源</span></span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你想验证 Docker 安装好了，可以运行一个 hello-world 容器</span></span><br><span class="line"><span class="comment"># sudo docker run hello-world</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列五</title>
      <link href="2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/"/>
      <url>2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="给docker加上数据持久"><a href="#给docker加上数据持久" class="headerlink" title="给docker加上数据持久"></a>给docker加上数据持久</h2><h3 id="数据券介绍"><a href="#数据券介绍" class="headerlink" title="数据券介绍"></a>数据券介绍</h3><p>我们可以在概念上把docker看做虚拟机,当容器被删除的时候，容器里所有数据都会被删除,两个不同容器之间无法互通<br>可以把数据卷理解为虚拟机的虚拟磁盘，他是独立于容器的文件.在容器中他被挂载为一个目录的形式.<br>对于容器中的应用来说，数据卷是透明的，无法感知它的存在，他就是一个普通的文件夹<br>由于数据卷独立于容器而存在，因此删除容器的时候数据卷也不会受影响。数据卷有以下优点:</p><ol><li>多容器可以通过挂载同一个数据卷来共享数据</li><li>数据卷可以方便地备份，存储数据</li></ol><h3 id="数据卷的相关命令操作"><a href="#数据卷的相关命令操作" class="headerlink" title="数据卷的相关命令操作"></a>数据卷的相关命令操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个volume</span></span><br><span class="line">docker volume create testvolume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个数据卷</span></span><br><span class="line">docker volume rm testvolume</span><br></pre></td></tr></table></figure><h3 id="在容器中使用数据卷"><a href="#在容器中使用数据卷" class="headerlink" title="在容器中使用数据卷"></a>在容器中使用数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建数据卷</span></span><br><span class="line">docker volume create web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在运行容器的时候，使用参数--mount 如下</span></span><br><span class="line"><span class="comment"># 下面的参数含义是把数据卷(web)挂载到容器的/volume目录上面</span></span><br><span class="line"><span class="comment"># 这里的webimage 镜像可以用我前面文章写得Dockerfile生成</span></span><br><span class="line"><span class="comment"># 这样就运行了一个带有数据卷的容器，这个容器的/volume目录中的内容在容器被删除之后仍然存在.</span></span><br><span class="line"><span class="comment"># 因为它实际上是存在Docker数据卷中。</span></span><br><span class="line">docker run -d --name demovolume --mount <span class="built_in">source</span>=web,target=/volume webimage</span><br></pre></td></tr></table></figure><h3 id="以下例子用于演示数据卷保存数据的特性"><a href="#以下例子用于演示数据卷保存数据的特性" class="headerlink" title="以下例子用于演示数据卷保存数据的特性"></a>以下例子用于演示数据卷保存数据的特性</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行命令在容器的 /b.txt 写入时间内容并查看</span></span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;date &gt; /b.txt&#x27;</span></span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;cat /b.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器后重新启动一个同名容器在查看，之前容器的内容已经没有了</span></span><br><span class="line">docker rm -f demovolume</span><br><span class="line">docker run -d --name demovolume --mount <span class="built_in">source</span>=web,target=/volume webimage</span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;cat /b.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存在数据卷上的文件，即使容器被删除仍然存在</span></span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;date &gt; /volume/b.txt&#x27;</span></span><br><span class="line">docker rm -f demovolume</span><br><span class="line">docker run -d --name demovolume --mount <span class="built_in">source</span>=web,target=/volume webimage</span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;cat /volume/b.txt&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="共享目录"><a href="#共享目录" class="headerlink" title="共享目录"></a>共享目录</h3><p>除了挂载数据卷以外，docker还可以挂载共享目录（这一点和虚拟机一样），共享目录的优势是使用方便，易于理解，可以在某些场景下方便使用<br>（比如开发是在宿主机中修改源代码docker中实时生效省却build镜像的过程）<br>下面用一个具体的例子来演示挂载共享目录的用法:</p><ol><li>在当前目录下创建index.html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>volume<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个在宿主机的 index.html 文件。<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>打开终端输入<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令会从nginx镜像运行一个名为nginx1的容器</span></span><br><span class="line"><span class="comment"># 并且设置了8080：80的端口映射</span></span><br><span class="line"><span class="comment"># --mount 参数的 type=bind 表明要挂载的共享目录</span></span><br><span class="line"><span class="comment"># 把宿主机的当前目录映射为容器的 /usr/share/nginx/html (这是nginx容器的静态页面文件存放路径)</span></span><br><span class="line"><span class="comment"># 这样在宿主机中访问localhost:8080会自动访问宿主机当前目录下的index.html文件 （这是nginx的默认静态文件首页）</span></span><br><span class="line"></span><br><span class="line">docker run -p 8080:80 --name nginx1 --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>,target=/usr/share/nginx/html/ nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要注意的是source参数必须使用绝对路径</span></span><br><span class="line"><span class="comment"># 所以这里使用&quot;$&#123;PWD&#125;&quot;的方式来在 Mac/Linux/Windows 中获取当前目录路径</span></span><br><span class="line"><span class="comment"># 这是一个可以在多平台通用的获取当前目录路径的方法 (windows下必须使用PowerShell)</span></span><br><span class="line"><span class="comment"># 加引号是因为路径中可能含有空格等特殊符号，如果路径有空格而未加引号，会产生错误</span></span><br></pre></td></tr></table></figure></li><li>打开浏览器输入: localhost:8080</li></ol><h3 id="其他挂载模式"><a href="#其他挂载模式" class="headerlink" title="其他挂载模式"></a>其他挂载模式</h3><p>除了挂载整个目录，还可以单独挂载一个文件。 如果要挂载单个文件，一定要要保证宿主机文件存在，否则整个路径会被认为是一个目录挂载</p><ol><li>创建index.html, 随便写点东西</li><li>打开终端输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8081:80 \</span><br><span class="line">    --name nginx2 \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>/index.html,target=/usr/share/nginx/html/test.html \</span><br><span class="line">    nginx</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  这时候我们访问http://localhost:8081 返回的是nginx的默认首页</span></span><br><span class="line">    <span class="comment">#  而访问http:/localhost:8081/test.html 返回的是挂载的单个文件</span></span><br></pre></td></tr></table></figure>注意：可以创建多文件挂载<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8082:80 \</span><br><span class="line">    --name nginx3 \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>/index.html,target=/usr/share/nginx/test.html/ \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>/test.html,target=/usr/share/nginx/test2.html/ \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列四</title>
      <link href="2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/"/>
      <url>2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="使用compose部署多容器应用"><a href="#使用compose部署多容器应用" class="headerlink" title="使用compose部署多容器应用"></a>使用compose部署多容器应用</h2><h3 id="compose介绍"><a href="#compose介绍" class="headerlink" title="compose介绍"></a>compose介绍</h3><pre><code>`docker`被设计为程序容器，所以每一个容器只应该运行一个程序。但是在实际的项目中会有需要多个程序相互配合一起运行的情况。比如web程序通常包含app, 数据库，nginx，redis等。这些程序各自的容器需要协同工作，并且需要能够互相访问网络。比如app需要连接数据库，nginx需要能访问app才能给他做反向代理。由于docker容器是一个隔离的环境，正常情况下容器与容器之间是无法互相访问的。为了应对复杂工程的需要，我们可以手动配置多容器之间的虚拟网络，文件互访等功能来实现容器互相访问。但docker官方推出了compose程序用于配置管理多容器的运行。`compose`通过一个单独的`docker-compose.yml`配置文件来管理一组容器。</code></pre><h3 id="compose安装"><a href="#compose安装" class="headerlink" title="compose安装"></a>compose安装</h3><pre><code>在`docker for mac`, `docker for windows`中`docker-compose`是自带的。linux服务器上，需要单独安装，方法如下：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你应该检查如下的链接用最新的版本: https://github.com/docker/compose/releases</span></span><br><span class="line"><span class="comment"># 这是linux服务器的安装方法：</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose</span><br><span class="line"><span class="comment"># 给docker-compose 增加修改的权限</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment"># 由于官方的Compose程序在github速度比较慢，所以我们也可以用国内的地址安装</span></span><br><span class="line">curl -L https://get.doocloud.io/docker/compose/releases/download/1.22.0/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment"># 其他系统安装方法见官方指南： https://docs.docker.com/compose/install/</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="compose使用"><a href="#compose使用" class="headerlink" title="compose使用"></a>compose使用</h3><pre><code>`compose`把一组容器作为一个项目来进行管理，并且会设置好容器间互联的内部网络每一个容器在compose中被称之为服务（service). 如同docker使用dockerfile来描述一个镜像的构建一样.`compose`使用一个`docker-compose.yml`文件来描述`compose`项目的构建. 请注意，如果你对yml格式不太熟悉，那么可能需要查阅一下yml格式的相关信息. 下面是关于`compose`的相关命令操作<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line">docker-compose up</span><br><span class="line"><span class="comment"># 重新运行</span></span><br><span class="line">docker-compose up --build</span><br><span class="line"><span class="comment"># 用-d参数让项目后台运行</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用stop暂停容器的运行</span></span><br><span class="line">docker-compose stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用down关闭并且删除项目的所有容器</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目运行起来后，用ctrl+c终止项目</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="实例操作1-compose的使用"><a href="#实例操作1-compose的使用" class="headerlink" title="实例操作1: compose的使用"></a>实例操作1: compose的使用</h3><ol><li><p>在当前目录下创建compose1文件夹</p></li><li><p>进入compose1, 创建<code>app.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># redisdemo 是 compose 中创建的主机名，由 docker-compose.yml 中指定</span></span><br><span class="line"><span class="comment"># compose 会给每个容器提供 DNS 服务保证容器间互相访问</span></span><br><span class="line">redis = Redis(host=<span class="string">&#x27;redisdemo&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    count = redis.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;views &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>进入compose1, 创建Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install flask redis</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>进入compose1, 创建docker-compose.yml</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示这是 compose 配置文件的版本</span></span><br><span class="line">version: <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="comment"># 每个服务都是一个 Docker 容器</span></span><br><span class="line"><span class="comment"># 所以必须用 image 指定服务的镜像名或者从 Dockerfile 中 build 镜像</span></span><br><span class="line">services:</span><br><span class="line">    pyweb:</span><br><span class="line">    <span class="comment"># build 指定了 Dockerfile 所在的路径。docker build -t pyimage .</span></span><br><span class="line">    build: .</span><br><span class="line">    <span class="comment"># ports 指定暴露的端口，9000 是宿主机，5000 是容器</span></span><br><span class="line">    <span class="comment"># 可以指定多个暴露端口</span></span><br><span class="line">    ports:</span><br><span class="line">        - <span class="string">&quot;9000:5000&quot;</span></span><br><span class="line">    <span class="comment"># depends_on 设定了依赖，这里 redisdemo 会先于 pyweb 启动</span></span><br><span class="line">    <span class="comment"># 但是如果 redisdemo 启动时间长于 pyweb</span></span><br><span class="line">    <span class="comment"># 那么 pyweb 运行的时候 redisdemo 未必可用</span></span><br><span class="line">    depends_on:</span><br><span class="line">        - redisdemo</span><br><span class="line"></span><br><span class="line">    redisdemo:</span><br><span class="line">        <span class="comment"># 每个服务必须用 image 指定镜像名或者从 Dockerfile 中 build</span></span><br><span class="line">        <span class="comment"># 这里用 image 指定镜像，redis:alpine 是 redis 项目的官方 Docker 镜像</span></span><br><span class="line">        image: <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>启动项目,打开终端</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器输入: localhost:9000/. 不断刷新浏览器你会发现redis记录了该页面访问的次数变化。</p></li><li><p>输入<code>docker-compose down</code>关闭应用</p></li></ol><h3 id="实例操作2-使用共享券"><a href="#实例操作2-使用共享券" class="headerlink" title="实例操作2: 使用共享券"></a>实例操作2: 使用共享券</h3><p>在开发过程中，如果每次修改<code>app.py</code>文件都要重新build再启动容器会比较繁琐<br>我们可以用共享券的方式来直接修改程序文件,这样可以大大提高开发效率.<br>上面的实例操作一，每次修改compose1文件夹下的文件都需要输入<code>docker-compose up --build</code>重启启动应用。现在使用了共享券(volumes)，容器中<code>/code</code>下的文件都来自宿主机的当前目录。<br>.</p><ol><li><p>进入目录compose1, 修改docker-compose.yml文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改pyweb容器的配置</span></span><br><span class="line">pyweb:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">        - <span class="string">&quot;9000:5000&quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">        - redisdemo</span><br><span class="line">    volumes:</span><br><span class="line">        - .:/code</span><br></pre></td></tr></table></figure></li><li><p>进入目录compose1, 修改Dockerfile文件</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除 COPY 命令</span><br><span class="line"><span class="deletion">- COPY app.py /code/app.py</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>打开终端, 启动项目</p></li><li><p>打开浏览器输入: localhost:9000/. 不断刷新浏览器你会发现redis记录了该页面访问的次数变化。这时候修改<code>app.py</code>不需要重新启动容器</p></li><li><p>输入<code>docker-compose down</code>关闭应用</p></li></ol><h3 id="实例操作3-在服务器中使用docker-compose启动项目"><a href="#实例操作3-在服务器中使用docker-compose启动项目" class="headerlink" title="实例操作3: 在服务器中使用docker-compose启动项目"></a>实例操作3: 在服务器中使用docker-compose启动项目</h3><ol><li>进入compose1文件夹，创建upload-and-run.sh文件.<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传项目到服务器</span></span><br><span class="line"><span class="comment"># 比如`scp -r . root@xxxxx:/local/woyao`</span></span><br><span class="line">scp -r . &lt;username&gt;@&lt;server host&gt;:&lt;server path&gt;</span><br><span class="line"><span class="comment"># 在服务器重启项目</span></span><br><span class="line"><span class="comment"># 登录服务器</span></span><br><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line">ssh &lt;username&gt;@&lt;server host&gt; <span class="string">&#x27;sh &lt;server path&gt;/run.sh&#x27;</span></span><br></pre></td></tr></table></figure></li><li>进入compose1文件夹，创建run.sh文件.<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;server path&gt;</span><br><span class="line">sudo docker-compose down</span><br><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure></li><li>在本地执行<code>sh upload-and-run.sh</code></li><li>打开浏览器输入: <code>&lt;server ip&gt;:9000</code>，就可以访问了。</li><li>注意事项:</li></ol><ul><li>可能服务器docker服务会关闭，在服务器输入<code>systemctl start docker</code>重启docker。</li><li>服务器防火墙原因，只放开了80,443端口</li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列三</title>
      <link href="2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/"/>
      <url>2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="使用dockerfile打包镜像"><a href="#使用dockerfile打包镜像" class="headerlink" title="使用dockerfile打包镜像"></a>使用dockerfile打包镜像</h2><pre><code>上一篇文章，我们实现了在一个基础的ubuntu镜像中运行我们的程序。但是运行程序的过程手动执行行命令式一件很麻烦的事情。接下来我们又把执行的命令协程了脚本，提高了一定的效率。但是如果要启动多个容器，我们的自制脚本每次都要重新安装配置一次这个过程是很耗时的。有没有更简单的办法呢？有的下面介绍dockerfile.</code></pre><h3 id="dockerfile介绍"><a href="#dockerfile介绍" class="headerlink" title="dockerfile介绍"></a>dockerfile介绍</h3><pre><code>docker 可以让我们自行编写配置文件（名为Dockerfile）来构建一个镜像,这样我们就可以轻松地从自定义构建的镜像中启动多个容器, 所以在实际使用中，我们会把整个程序打包成一个新的docker. 也就是说把所得配置操作，启动运行操作都写到自己的自定义的镜像配置文件中，这样生成的镜像实例(容器)只管运行就好了。不需要额外配置</code></pre><h3 id="关于镜像相关的命令"><a href="#关于镜像相关的命令" class="headerlink" title="关于镜像相关的命令"></a>关于镜像相关的命令</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用下面的命令查看本机存储的镜像 (包括下载的和构建的)</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker image rm &lt;webimage&gt;</span><br><span class="line">or</span><br><span class="line">docker rmi -f &lt;webimage&gt;</span><br><span class="line"><span class="comment"># 构建镜像, -t表示镜像的名字和标签，.代表当前的工作目录</span></span><br><span class="line">docker build -t webimage .</span><br></pre></td></tr></table></figure></code></pre><h3 id="使用dockerfile构建的镜像启动容器"><a href="#使用dockerfile构建的镜像启动容器" class="headerlink" title="使用dockerfile构建的镜像启动容器"></a>使用dockerfile构建的镜像启动容器</h3><pre><code>下面是对dockerfile文件中内容的解释<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在dockerfile文件中 #是注释</span></span><br><span class="line"><span class="comment"># FROM用于指定构建镜像使用的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN 用于在构建镜像的时候在镜像中执行命令</span></span><br><span class="line"><span class="comment"># 这里我们安装python3 和 flask web 框架</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip2 insatll flask</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY 相当于命令的 docker cp</span></span><br><span class="line"><span class="comment"># 把本机当前目录下的app.py文件拷贝到镜像的 /code/app.py</span></span><br><span class="line"><span class="comment"># 和docker cp 不同的是， COPY 会自动创建镜像中不存在的目录, 比如/code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR 用于指定从镜像启动的容器内的工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 用于指定容器运行后要执行的命令和参数列表</span></span><br><span class="line"><span class="comment"># 这样从本镜像启动容器后会自动执行 python3 app.py 这个命令</span></span><br><span class="line"><span class="comment"># 由于我们已经用WORDKDIR指定了容器的工作目录</span></span><br><span class="line"><span class="comment"># 所以以下的命令都是在 /code 下执行的</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><ol><li>当前目录下创建app.py文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from Dockerfile&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li>当前目录下创建Dockerfile文件<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install flask</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为使用了docker build -t webimage .</span></span><br><span class="line"><span class="comment"># 指明了镜像的工作目录是当前目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li>打开终端输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令中参数 -t webimage 指定了镜像的名字为 webimage</span></span><br><span class="line"><span class="comment"># 这个名字可以用于在之后从镜像启动容器</span></span><br><span class="line"><span class="comment"># 最后那个 . 用来指定构建镜像时候的工作目录为本机当前目录</span></span><br><span class="line">docker build -t webimage .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用下面的命令查看本机存储的镜像 (包括下载的和构建的)</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -p 8000:5000 --name demo webimage</span><br></pre></td></tr></table></figure></li><li>在浏览器输入: localhost:8000</li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列二</title>
      <link href="2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/"/>
      <url>2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="手动从镜像运行一个容器"><a href="#手动从镜像运行一个容器" class="headerlink" title="手动从镜像运行一个容器"></a>手动从镜像运行一个容器</h2><h3 id="手动启动一个容器"><a href="#手动启动一个容器" class="headerlink" title="手动启动一个容器"></a>手动启动一个容器</h3><pre><code>手动在本地电脑的docker容器中运行一个web应用<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令启动一个docker容器</span></span><br><span class="line">docker run -d -t -p 8000:5000 --name demo ubuntu:18.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这条命令的解释</span></span><br><span class="line">-d 的意思是让容器在后台运行</span><br><span class="line">-t 极少能用到，用于让一个空白的Ubuntu镜像在后台运行</span><br><span class="line">-p 用于指定端口映射，表示在本机访问8000会被自动转到容器中5000端口</span><br><span class="line">   必须保证本机没有其他应用程序占用了8000端口，否则这里会失败</span><br><span class="line">--name demo 制定了容器的名字是demo</span><br><span class="line">ubuntu:18.04 是启动容器时用的镜像名, docker会自动从镜像服务器去下载这个镜像</span><br></pre></td></tr></table></figure></code></pre><h3 id="启动容器常见的问题"><a href="#启动容器常见的问题" class="headerlink" title="启动容器常见的问题"></a>启动容器常见的问题</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个端口为3456的进程</span></span><br><span class="line">docker run -t -d -p 3456:5000 --name <span class="built_in">test</span> ubuntu:18.04</span><br><span class="line"><span class="comment"># 报错1，端口被占用，删除test容器来不安比3456端口的占用</span></span><br><span class="line">docker rm -f <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 报错2，名字已存在, 那么改名字, 也可以用上面的删除容器命令</span></span><br><span class="line">docker run -t -d -p 3456:5000 --name test1 ubuntu:18.04</span><br></pre></td></tr></table></figure></code></pre><h3 id="关于容器相关的命令"><a href="#关于容器相关的命令" class="headerlink" title="关于容器相关的命令"></a>关于容器相关的命令</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最新指定数量的容器的状态</span></span><br><span class="line">docker ps -n 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止容器</span></span><br><span class="line">docker stop &lt;container id&gt;/&lt;container name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对终止运行的容器重启, 容器id通过docker ps查询</span></span><br><span class="line">docker start &lt;container id&gt;/&lt;container name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志</span></span><br><span class="line">docker logs &lt;container id&gt;/&lt;container name</span><br></pre></td></tr></table></figure></code></pre><h3 id="在容器中安装必备软件"><a href="#在容器中安装必备软件" class="headerlink" title="在容器中安装必备软件"></a>在容器中安装必备软件</h3><pre><code>启动容器以后，说明了运行了一个镜像实例，比如ubuntu:18.04镜像生成的test容器。这个容器目前有了ubuntu操作系统的文件管理功能，内存管理功能，进程调度等功能。现在还需要拥有python3, pip 环境, apt工具包。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -t -p 8000:5000 --name unbuntu:18.04</span><br><span class="line"><span class="comment"># 下载apt工具包</span></span><br><span class="line">docker <span class="built_in">exec</span> demo apt update</span><br><span class="line">docker <span class="built_in">exec</span> apt -y install python3 python3-pip</span><br><span class="line"><span class="comment"># 安装flask库</span></span><br><span class="line">docker <span class="built_in">exec</span> demo pip3 install flask</span><br></pre></td></tr></table></figure></code></pre><h3 id="在容器中运行程序"><a href="#在容器中运行程序" class="headerlink" title="在容器中运行程序"></a>在容器中运行程序</h3><pre><code>上面说过，使用docker的目的就是软件应用带环境安装。现在环境好了，需要运行软件应用<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo 容器中创建/code目录</span></span><br><span class="line">docker <span class="built_in">exec</span> demo mkdir /code</span><br><span class="line"><span class="comment"># cp参数把当前文件夹的a.py拷贝到demo容器的/code/a.py</span></span><br><span class="line">docker cp a.py demo:/code/a.py</span><br><span class="line"><span class="comment"># 运行demo容器中的a.py</span></span><br><span class="line">docker <span class="built_in">exec</span> demo python3 /code/a.py</span><br></pre></td></tr></table></figure></code></pre><h3 id="用脚本的方式配置容器，然后运行脚本配置并开启新容器"><a href="#用脚本的方式配置容器，然后运行脚本配置并开启新容器" class="headerlink" title="用脚本的方式配置容器，然后运行脚本配置并开启新容器"></a>用脚本的方式配置容器，然后运行脚本配置并开启新容器</h3><pre><code>之前的一系列命令有些繁琐, 其实更好的方式是在宿主机写脚本，然后cp到docker容器中直接运行.具体操作看实例操作</code></pre><h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><ol><li>在当前目录下创建a.py文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from Docker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认端口5000</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li>在当前目录下创建install.sh文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install.sh</span></span><br><span class="line">apt update</span><br><span class="line">apt -y install python3 python3-pip</span><br><span class="line">pip3 install flask</span><br></pre></td></tr></table></figure></li><li>在当前目录下创建run.sh文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run.sh</span></span><br><span class="line"><span class="built_in">cd</span> /code</span><br><span class="line">python3 a.py</span><br></pre></td></tr></table></figure></li><li>打开终端，输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -t -p 8000:5000 --name unbuntu:18.04</span><br><span class="line"><span class="comment"># demo 容器中创建/code目录</span></span><br><span class="line">docker <span class="built_in">exec</span> demo mkdir /code</span><br><span class="line">docker cp install.sh <span class="string">&quot;demo:/code/install.sh&quot;</span></span><br><span class="line">docker cp run.sh <span class="string">&quot;demo:/code/run.sh&quot;</span></span><br><span class="line">docker cp a.py <span class="string">&quot;demo:/code/a.py&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> demo bash /code/install.sh</span><br><span class="line">docker <span class="built_in">exec</span> demo bash /code/run.sh</span><br></pre></td></tr></table></figure></li><li>打开浏览器输入：localhost:8000/</li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列一</title>
      <link href="2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/"/>
      <url>2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="docker概念篇"><a href="#docker概念篇" class="headerlink" title="docker概念篇"></a>docker概念篇</h2><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>官方解释：通过对应用的封装、分发、部署、运行 生命周期进行管理，达到应用组件级别的“一次封装，到处运行”。<br>大白话：在以前一个软件应用在不同机器上运行，都需要对操作系统设置，各种库和组装单独下载，配置好环境变量。才能运行的起来。这种模式很不好，首先老旧的模块和当前环境不兼容就”gg思密达了”. 于是就有了软件应用带环境安装的解决方案。然后就出现了<code>虚拟机的方案</code>。但是虚拟机<strong>资源占用多</strong>，<strong>冗余步骤多</strong>，<strong>启动慢</strong>。既然虚拟机方案不好，那么革命的变更就出现了<code>linux容器方案</code>。关于<code>linux容器方案</code>的介绍:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux 容器不是模拟一个完整的操作系统，而是对进程(一个正在运行的应用)进行隔离。</span><br><span class="line">在正常进程的外面套了一个容器。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。另外容器也属于一个进程。</span><br></pre></td></tr></table></figure><p>具有<strong>启动快</strong>，<strong>占用资源少</strong>，<strong>体积小</strong>。docker属于<code>linux容器</code>的一种封装。是目前最流行的<code>linux容器方案</code>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="centOs系统"><a href="#centOs系统" class="headerlink" title="centOs系统:"></a>centOs系统:</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 添加docker稳定版本的yum软件源</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">// 安装docker</span><br><span class="line">sudo yum install -y docker-ce</span><br><span class="line"></span><br><span class="line">// 确定docker服务启动正常</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h4 id="macOs系统"><a href="#macOs系统" class="headerlink" title="macOs系统:"></a>macOs系统:</h4><p><a href="https://www.runoob.com/docker/macos-docker-install.html">参考macos系统docker的安装</a></p><h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p><a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac">docker安装官网</a></p><h3 id="docker镜像-docker-image"><a href="#docker镜像-docker-image" class="headerlink" title="docker镜像(docker image)"></a>docker镜像(docker image)</h3><p>Docker把应用程序及其依赖，打包在image文件里面。docker image 一个只读的模板, 创建Docker容器的基础。镜像相当于光盘，光盘里存储的数据是只读的，不会被更改</p><h3 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h3><p>容器是从镜像创建的应用运行实例, 一个镜像可以生成多个容器，每个容器之间，容器与宿主机之间都是相互隔离的，容器可以快速方便的运行，也可以方便的删除</p><h3 id="docker的优势"><a href="#docker的优势" class="headerlink" title="docker的优势"></a>docker的优势</h3><ol><li><p>同一环境，标准化部署 ubntu centos 等服务器的安装运行环境是不一样的<br>要使用某些新版的软件需要自行编译，非常繁琐</p></li><li><p>解决复杂的依赖问题<br>比如两个微服务 2个不同的依赖互相冲突</p></li><li><p>隔离应用的运行环境<br>比如redis获取服务器权限的漏洞</p></li><li><p>轻量级的虚拟环境，相比虚拟机而言开销小速度快</p></li><li><p>统一的服务管理<br> 不同的服务有不同的管理工具和方式<br> 如果使用了docker则统一用docker管理</p></li><li><p>dockerhub 上有许多高价值的镜像可以直接使用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react的hooks教程</title>
      <link href="2021/04/16/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/react%E7%9A%84hooks%E6%95%99%E7%A8%8B/"/>
      <url>2021/04/16/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/react%E7%9A%84hooks%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="这是一篇react的hooks教程"><a href="#这是一篇react的hooks教程" class="headerlink" title="这是一篇react的hooks教程"></a>这是一篇react的hooks教程</h2><p>另外欢迎大家访问<a href="https://chenwoyao.github.io/categories/">我的博客</a></p><h2 id="react-hooks-与-class-Component-的区别"><a href="#react-hooks-与-class-Component-的区别" class="headerlink" title="react hooks 与 class Component 的区别"></a><code>react hooks</code> 与 <code>class Component</code> 的区别</h2><ul><li>写法更加简洁，不再需要写冗长的生命周期函数</li><li><code>class Componet hoc</code> 的阅读让人看起来不易理解, 在组件之间复用状态逻辑很难.</li></ul><h2 id="hooks-使用规则"><a href="#hooks-使用规则" class="headerlink" title="hooks 使用规则"></a><code>hooks</code> 使用规则</h2><ul><li>只能在<strong>函数最外层</strong>调用 Hook。不要在循环、条件判断或者子函数中调用。</li><li>只能在<strong>React的函数组件中调用</strong>Hook。不要在其他JavaScript函数中调用。除了自定义的hook以外</li></ul><h2 id="react-hooks-常见的api使用"><a href="#react-hooks-常见的api使用" class="headerlink" title="react hooks 常见的api使用"></a><code>react hooks</code> 常见的api使用</h2><h3 id="useState-用法"><a href="#useState-用法" class="headerlink" title="useState 用法"></a><code>useState</code> 用法</h3><blockquote><p>identity: <code>const [state, setState] = useState(initialState)</code></p></blockquote><p><code>useState</code>的作用是在react函数组件中添加state的hook。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line">function Count() &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - count &lt;&#x3D;&gt; this.state.count, setCount &lt;&#x3D;&gt; this.setState</span><br><span class="line">        - setCount 支持两种写法 setCount(count + 1) or setCount(preState &#x3D;&gt; preState + 1)</span><br><span class="line">        第一种写法是一种异步机制，会将短时间内的多个setCount合并成一个方法，第二种写法是为了不使用第一种的合并机制。</span><br><span class="line">    *&#x2F;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    return &lt;div onClick&#x3D;&#123;setCount(pre &#x3D;&gt; pre + 1)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useEffect-用法"><a href="#useEffect-用法" class="headerlink" title="useEffect 用法"></a><code>useEffect</code> 用法</h3><blockquote><p>identity: <code>useEffect(callBack:clearCallBack, [deps])</code></p></blockquote><p><code>useEffect</code>的作用是在函数组件中执行副作用操作, 等价于在ComponetDidMount，ComponentDidUpdate, ComponentWillUnmount 三个函数的组合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - useEffect接受一个callBack参数和数组参数</span><br><span class="line">        - 数组中的值作为依赖，数组中的值发生变化的时候，callBack会重新调用。等价于ComponentDidUpdate</span><br><span class="line">        - callBack可以return一个clearCallBack,在组件卸载的时候调用clearCallBack。等价于ComponentWillUnmount</span><br><span class="line">        - useEffect默认会在render流程执行完以后，在调用callBack。等价于ComponetDidMount</span><br><span class="line">    *&#x2F;</span><br><span class="line">    const [isonline, setIsOnline] &#x3D; useState(false);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [isonline])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useContext-用法"><a href="#useContext-用法" class="headerlink" title="useContext 用法"></a><code>useContext</code> 用法</h3><p><code>useContext</code>的作用是接受一个context对象，并返回该context的当前值。主要用于深层级的组件通讯。需要和React.createContext配合使用<br>context的值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt;的 value prop决定。另外value的值更新会引起调用了uesContext的组件重新渲染。</p><blockquote><p>注意调用useContext的组件即使用了React.memo进行声明，也会重新渲染。因此需要使用<a href="https://github.com/facebook/react/issues/15156">memoization</a>来进行优化.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext, Children, useContext, useMemo &#125; from &#39;react&#39;</span><br><span class="line">const GlobalContext &#x3D; React.createContext()</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">    const data &#x3D; useContext(GlobalContext)</span><br><span class="line">    &#x2F;&#x2F; memoization 写法</span><br><span class="line">    return useMemo(() &#x3D;&gt; &#123;</span><br><span class="line">        return &lt;div&gt;&#123;data.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;, [data.name])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Parent() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;Parent&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;GlobalContext.Provider value&#x3D;&#123;&#123;name: &#39;woyao&#39;&#125;&#125;&gt;</span><br><span class="line">                &lt;Child &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;GlobalContext.Provider&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="useRef-用法"><a href="#useRef-用法" class="headerlink" title="useRef 用法"></a><code>useRef</code> 用法</h3><p><code>useRef</code>返回一个可变的ref对象，<code>ref.current</code>在组件内是一个全局常量。相当于在组件外写了一个全局常量。也就是说每次重新渲染函数组件时，返回的ref对象都是同一个。 常用于<em>访问Dom</em>,<em>当做全局变量</em>。</p><blockquote><p><em>访问 Dom</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef &#125; from &#39;react&#39;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    const inputElement &#x3D; useRef(null)</span><br><span class="line">    const btnClick &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class="line">        inputElement.current.focus()</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &lt;input ref&#x3D;&#123;inputElement&#125; &#x2F;&gt;</span><br><span class="line">            &lt;button ref&#x3D;&#123;btn&#125; onClick&#x3D;&#123;btnClick&#125;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><em>当做全局变量</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef, useEffect, useState &#125; from &#39;react&#39;</span><br><span class="line">function usePrevious(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 每次重新渲染，都会执行useRef,</span><br><span class="line">    const ref &#x3D; useRef()</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - 不设置依赖，每次reRender都会重新执行</span><br><span class="line">        - 能够返回上一次渲染之前value是什么值</span><br><span class="line">        - 注意是先执行return, 在执行useEffect</span><br><span class="line">    *&#x2F;</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        ref.current &#x3D; value</span><br><span class="line">    &#125;)</span><br><span class="line">    return ref.current</span><br><span class="line">&#125;</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0)</span><br><span class="line">    const preCount &#x3D; usePrevious(count)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;previous: &#123;preCount&#125; &lt;&#x2F;p&gt;</span><br><span class="line">            &lt;p&gt;now: &#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useImperativeHandle-用法"><a href="#useImperativeHandle-用法" class="headerlink" title="useImperativeHandle 用法"></a><code>useImperativeHandle</code> 用法</h3><blockquote><p>identity: <code>useImperativeHandle(ref, createHandle, [deps])</code></p></blockquote><p><code>useImperativeHandle</code>可以让你在使用<code>ref</code>时自定义暴露给父组件的实例值, 与<code>forwardRef</code>一起使用. 让你能够父组件调用子组件的方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef, useImperativeHandle, forwardRef &#125; from &#39;react&#39;</span><br><span class="line">function MyInput(props, ref) &#123;</span><br><span class="line">    const inputRef &#x3D; useRef()</span><br><span class="line">    const childFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;hh&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        ref: ref实例</span><br><span class="line">        createHandle: 给ref实例绑上方法</span><br><span class="line">        [dps]: 当deps发生变化的时候, createHandle 重新执行</span><br><span class="line">    *&#x2F;</span><br><span class="line">    useImperativeHandle(ref, () &#x3D;&gt; (&#123;</span><br><span class="line">        focus: () &#x3D;&gt; &#123;</span><br><span class="line">            inputRef.current.focus()</span><br><span class="line">        &#125;,</span><br><span class="line">        childFunc</span><br><span class="line">    &#125;))</span><br><span class="line">    return &lt;input ref&#x3D;&#123;inputRef&#125; &#x2F;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    MyInput &#x3D; forwardRef(MyInput)</span><br><span class="line"></span><br><span class="line">    function App() &#123;</span><br><span class="line">        const myInputCoponent &#x3D; useRef()</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;MyInput ref&#x3D;&#123;myInputCoponent&#125; &#x2F;&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; myInputCoponent.current.childFunc() &#125;&#125;&gt; focus now &lt;&#x2F;button&gt;</span><br><span class="line">            &lt;&#x2F;&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="useReducer-用法"><a href="#useReducer-用法" class="headerlink" title="useReducer 用法"></a><code>useReducer</code> 用法</h3><blockquote><p>identity: <code>const [state, dispatch] = useReducer(reducer, initialArg, init)</code></p></blockquote><p><code>useReducer</code>是useState的替代方案，接受一个形如(state, action) =&gt; newState 的 reducer, 并返回<br>当前的state以及其配套的dispatch方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const initialState &#x3D; &#123;count: 0&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;increment&#39;:</span><br><span class="line">            return &#123;count: state.count + 1&#125;;</span><br><span class="line">        case &#39;decrement&#39;:</span><br><span class="line">            return &#123;count: state.count - 1&#125;;</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, initialState);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            Count: &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useMemo-用法"><a href="#useMemo-用法" class="headerlink" title="useMemo 用法"></a><code>useMemo</code> 用法</h3><blockquote><p>identity: <code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b])</code><br>newRenderTemplate = useMemo(() =&gt; renderTemplate(), [deps])</p></blockquote><p><code>useMemo</code>是减少组件渲染次数，优化组件性能的hook, 传入<code>useMemo</code>的函数会在渲染期间执行，请不要再函数<br>内部执行与渲染无关的操作，其实也就是只有依赖项发生变化才会生成新的memoizedValue。这样就减少了不必要的<br>渲染。一般用在组件中进行解耦操作，与这个逻辑渲染相关的逻辑发生变化就重新渲染，而不相关的就不会重新渲染。<br>大白话就是有一个count逻辑相关的渲染，还有一个和name相关的逻辑渲染。不要因为name的state属性变化导致<br>count的渲染函数也重新执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useMemo &#125; from &#39;react&#39;</span><br><span class="line">const log &#x3D; console.log.bind(console)</span><br><span class="line"></span><br><span class="line">function Child(props) &#123;</span><br><span class="line">    log(&#39;child render&#39;)</span><br><span class="line">    const [count, SetCount] &#x3D; useState(0)</span><br><span class="line">    const renderCountTemplate &#x3D; (count) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;count render&#39;)</span><br><span class="line">        return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            child, &#123;props.name&#125;</span><br><span class="line">            &#123;&#x2F;*</span><br><span class="line">                - 使用useMemo防止了不必要的渲染更新，不会因为与当前父组件的props发生变化就会重新对renderCountTemplate进行执行。</span><br><span class="line">            *&#x2F;&#125;</span><br><span class="line">            &#123; useMemo(() &#x3D;&gt; renderCountTemplate(count), [count])&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Child组件优化：组件内 prop，state 的值发生变化才会重新渲染。防止了父组件的更新，子组件也进行不必要的更新</span><br><span class="line">Child &#x3D; React.memo(Child)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">    log(&#39;parent render&#39;)</span><br><span class="line">    const [name, SetName] &#x3D; useState(&#39;&#39;)</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;parent, &#123;name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;input onChange&#x3D;&#123;(event) &#x3D;&gt; SetName(event.target.value)&#125; &#x2F;&gt;</span><br><span class="line">            &lt;Child name&#x3D;&#123;name&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useCallback-用法"><a href="#useCallback-用法" class="headerlink" title="useCallback 用法"></a><code>useCallback</code> 用法</h3><blockquote><p>identity: <code>const memoizedCallback = useCallback(() =&gt; &#123; doSomething(a, b); &#125;, [a, b]);</code></p></blockquote><p><code>useCallback</code>是减少组件渲染次数，优化组件性能的hook, 与<code>useMemo</code>类似。回调函数仅在某个依赖项改变时才会更新<br>常用在对事件函数中匿名函数的处理。当然能用到useMemo的地方，useCallback也可以用到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useCallback, useState &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">const [ count, setCount ] &#x3D; useState(0)</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    &lt;!--</span><br><span class="line">        - 防止了每次count发生变化，导致的重新渲染，都需要重新生成一个新的匿名函数</span><br><span class="line">        - 也就是说 () &#x3D;&gt; &#123;setCount(count + 1)&#125; 这个匿名函数不需要再从新的内存空间中创建</span><br><span class="line">     --&gt;</span><br><span class="line">    return &lt;div onClick&#x3D;&#123;useCallback(() &#x3D;&gt; setCount(count+1), [])&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useLayoutEffect-用法"><a href="#useLayoutEffect-用法" class="headerlink" title="useLayoutEffect 用法"></a><code>useLayoutEffect</code> 用法</h3><p><code>useLayoutEffect</code> 官方解释说它会在所有的DOM变更之后同步调用effect，可能<code>useEffect</code>是在所有的DOM变更之后异步调用effect吧.</p><ul><li>可以使用它来读取 DOM 布局并同步触发重渲染</li><li>在浏览器执行绘制之前，<code>useLayoutEffect</code>内部的更新计划将被同步刷新。</li><li>这么说吧，我也不太<code>useLayoutEffect</code>的区别。有下面一段代码可以参考一下。估计在使用<code>useEffect</code>的时候带来了页面的抖动问题的时候就使用<code>useLayoutEffect</code>。网上的解释:layout会在组件树构建完毕或者刷新完毕后同步立刻执行。effect会等其他js代码执行完毕后执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (count &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      const randomNum &#x3D; 10 + Math.random()*200</span><br><span class="line">      setCount(10 + Math.random()*200);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>效果如下:<br><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0dcc15419be9?imageslim" alt="结果"></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (count &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      const randomNum &#x3D; 10 + Math.random()*200</span><br><span class="line">      setCount(10 + Math.random()*200);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>效果如下:<br><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0dca05c0fa6e?imageslim" alt="结果"></p></blockquote></li></ul><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><p>其实也就是hook mixin, 公共的方法逻辑可以写成自定义hooks</p><ul><li><a href="#useDidUpdate">useDidUpdate</a></li><li><a href="#useGlobalReduxHook">useGlobalReduxHook</a></li></ul><div id="useDidUpdate"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个ComponentDidUpdate的简易实现</span><br><span class="line">import &#123; useEffect, useRef &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">function useDidUpdate(cb, deps&#x3D;[]) &#123;</span><br><span class="line">  const didMount &#x3D; useRef(false)</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (!didMount.current) &#123;</span><br><span class="line">      didMount.current &#x3D; true</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, deps)</span><br><span class="line"></span><br><span class="line">  return didMount.current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="useGlobalReduxHook"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个redux的简易实现</span><br><span class="line">import React, &#123; useContext, useReducer &#125; from &#39;react&#39;</span><br><span class="line">const initState &#x3D; &#123; count: 0 &#125;</span><br><span class="line">const Store &#x3D; React.createContext(initStore)</span><br><span class="line">const MapActionReducer &#x3D; &#123;</span><br><span class="line">    [&#39;ADD&#39;](state, action) &#123;</span><br><span class="line">        return &#123;...state, count: action.payload&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reducer &#x3D; (initState, action) &#x3D;&gt; &#123;</span><br><span class="line">    return MapActionReducer[action.type](initState, action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function useGlobalReduxHook(Component) &#123;</span><br><span class="line">    &#x2F;&#x2F; dispatch触发state发生变化，会重新执行渲染</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, Store)</span><br><span class="line">    return (</span><br><span class="line">        &lt;Store.Provider value&#x3D;&#123;state, dispatch&#125; &#x2F;&gt;</span><br><span class="line">            &lt;Component &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Store.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法教程</title>
      <link href="2021/04/14/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/"/>
      <url>2021/04/14/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="这是一篇markdwon语法教程"><a href="#这是一篇markdwon语法教程" class="headerlink" title="这是一篇markdwon语法教程"></a>这是一篇markdwon语法教程</h1><p>另外欢迎大家访问<a href="https://chenwoyao.github.io/categories/">我的博客</a></p><h1 id="关于markdown"><a href="#关于markdown" class="headerlink" title="关于markdown"></a>关于markdown</h1><p>markdown 是一种文本，类似于html， 比起html文本，语法标签更少，很容易上手写作</p><h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 标题1</span></span><br><span class="line"><span class="section">## 标题2</span></span><br><span class="line"><span class="section">### 标题3</span></span><br><span class="line"><span class="section">#### 标题4</span></span><br><span class="line"><span class="section">##### 标题5</span></span><br><span class="line"><span class="section">###### 标题6</span></span><br><span class="line">快捷键: h1 + tap</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">有序列表:</span><br><span class="line"><span class="bullet">1.</span> list1</span><br><span class="line"><span class="bullet">2.</span> list2</span><br><span class="line"></span><br><span class="line">无序列表:</span><br><span class="line"><span class="bullet">-</span> list1</span><br><span class="line"><span class="bullet">*</span> list2</span><br><span class="line"><span class="bullet">    -</span> list3</span><br><span class="line"><span class="bullet">    -</span> list4</span><br><span class="line"></span><br><span class="line">任务列表：</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成任务1</span><br><span class="line"><span class="bullet">-</span> [x] 已完成任务1</span><br><span class="line"></span><br><span class="line">引用列表:</span><br><span class="line"><span class="quote">&gt; ref1</span></span><br><span class="line"><span class="quote">&gt; ref2</span></span><br></pre></td></tr></table></figure><h2 id="文字样式语法"><a href="#文字样式语法" class="headerlink" title="文字样式语法"></a>文字样式语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**加粗** [快捷键：Ctrl+B]</span><br><span class="line">__加粗2__</span><br><span class="line"></span><br><span class="line">_倾斜_</span><br><span class="line">*倾斜*</span><br><span class="line"></span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><h2 id="图片显示或者链接显示"><a href="#图片显示或者链接显示" class="headerlink" title="图片显示或者链接显示"></a>图片显示或者链接显示</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">链接语法：</span><br><span class="line">[<span class="string">我的github</span>](<span class="link">https://github.com/ChenWoyao</span>)</span><br><span class="line"></span><br><span class="line">图片语法：</span><br><span class="line">![<span class="string">alt帅哥</span>](<span class="link">./static/img/bg.png</span>)</span><br></pre></td></tr></table></figure><h2 id="表格语法"><a href="#表格语法" class="headerlink" title="表格语法"></a>表格语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|th1|th2|th3|</span><br><span class="line">|--|--|--|</span><br><span class="line">|td1|td2|td3|</span><br><span class="line">|td1|td2|   td3|</span><br></pre></td></tr></table></figure><h2 id="代码块语法"><a href="#代码块语法" class="headerlink" title="代码块语法"></a>代码块语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">表示一个代码片段：</span><br><span class="line"><span class="code">`from urllib import parse`</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span>from urllib import parse<span class="xml"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">表示一段代码块：(diff, js, php, sh 等语法都支持)</span><br><span class="line"><span class="code">``` js</span></span><br><span class="line"><span class="code">    data = &#123;</span></span><br><span class="line"><span class="code">        &#x27;a&#x27;: &#x27;test&#x27;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">` ``</span></span><br><span class="line"><span class="code">&lt;pre&gt;</span></span><br><span class="line"><span class="code">    data = &#123;</span></span><br><span class="line"><span class="code">        &#x27;a&#x27;: &#x27;test&#x27;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&lt;/pre&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释--&gt;</span><br><span class="line">快捷键: cmd + /</span><br></pre></td></tr></table></figure><h2 id="目录与锚点"><a href="#目录与锚点" class="headerlink" title="目录与锚点"></a>目录与锚点</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">展示目录树的写法：</span><br><span class="line">├── [<span class="string">README.md</span>](<span class="link">#readme</span>)</span><br><span class="line">├── [<span class="string">build</span>](<span class="link">#build</span>)</span><br><span class="line">│ ├── [<span class="string">webpack.base.js</span>](<span class="link">#webpack-base</span>)</span><br><span class="line">│ ├── [<span class="string">webpack.client.js</span>](<span class="link">#webpack-client</span>)</span><br><span class="line">│ └── [<span class="string">webpack.server.js</span>](<span class="link">#webpack-server</span>)</span><br><span class="line">├── [<span class="string">package-lock.json</span>](<span class="link">#package-lock</span>)</span><br><span class="line">├── [<span class="string">package.json</span>](<span class="link">#package.json</span>)</span><br><span class="line">└── [<span class="string">src</span>](<span class="link">#src</span>)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [<span class="string">README.md</span>](<span class="link">#readme</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">build</span>](<span class="link">#build</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.base.js</span>](<span class="link">#webpack-base</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.client.js</span>](<span class="link">#webpack-client</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.server.js</span>](<span class="link">#webpack-server</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">package-lock.json</span>](<span class="link">#package-lock</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">package.json</span>](<span class="link">#package.json</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">src</span>](<span class="link">#src</span>)</span><br><span class="line"></span><br><span class="line">对应的锚点dom:</span><br><span class="line"><span class="section">## readme</span></span><br><span class="line"><span class="section">## build</span></span><br><span class="line"><span class="section">### webpack-base</span></span><br><span class="line"><span class="section">### webpack-client</span></span><br><span class="line"><span class="section">### webpack-server</span></span><br><span class="line"><span class="section">## ackage-lock</span></span><br><span class="line"><span class="section">## package.json</span></span><br><span class="line"><span class="section">## src</span></span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;readme&quot;</span>&gt;</span></span> readme <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span> build <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">------------- 【快捷键：hr后敲Tab】</span><br><span class="line">*************</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\sum<span class="emphasis">_&#123;i=1&#125;^n a_</span>i=0$$</span><br><span class="line"></span><br><span class="line">$$f(x<span class="emphasis">_1,x_</span>x,\ldots,x<span class="emphasis">_n) = x_</span>1^2 + x<span class="emphasis">_2^2 + \cdots + x_</span>n^2$$</span><br><span class="line"></span><br><span class="line">$$\sum^&#123;j-1&#125;<span class="emphasis">_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_</span>&#123;kj&#125; z<span class="emphasis">_k&#125;$$</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> markdown语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
