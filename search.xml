<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器的相关知识</title>
      <link href="2021/05/30/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%80%E8%BF%B0/"/>
      <url>2021/05/30/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="总结的话是这样"><a href="#总结的话是这样" class="headerlink" title="总结的话是这样"></a>总结的话是这样</h2><h3 id="移动端："><a href="#移动端：" class="headerlink" title="移动端："></a>移动端：</h3><pre><code>保持单个文件小于 25kb打包内容为分段multipart文档</code></pre><h3 id="图片："><a href="#图片：" class="headerlink" title="图片："></a>图片：</h3><pre><code>优化图片优化css sprite不要再html中放缩放图片使用体积小，可以缓存的favicon.ico</code></pre><h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript:"></a>javascript:</h3><pre><code>把脚本放在页面底部使用外部JavaScript和css压缩js和css移除重复脚本减少dom操作使用高效的事件处理</code></pre><h3 id="css"><a href="#css" class="headerlink" title="css:"></a>css:</h3><pre><code>不要把样式表放在head中不要使用css表达式使用link代替@import不要使用filter</code></pre><h3 id="页面内容："><a href="#页面内容：" class="headerlink" title="页面内容："></a>页面内容：</h3><pre><code>减少http请求数减少dsn查询减少重定向使用ajax请求延迟加载预加载减少dom元素数量划分内容到不同域名劲量减少ifame使用避免404错误</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre><code>使用cdn添加expires和cache-control响应头启用gzip配置etag尽早输出缓冲ajax请求使用get方法避免图片src为空</code></pre><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><pre><code>减少cookie大小静态资源使用cookie域名</code></pre><h2 id="下面是一些具体的措施"><a href="#下面是一些具体的措施" class="headerlink" title="下面是一些具体的措施:"></a>下面是一些具体的措施:</h2><h3 id="尽可能减少HTTP请求"><a href="#尽可能减少HTTP请求" class="headerlink" title="尽可能减少HTTP请求:"></a>尽可能减少HTTP请求:</h3><pre><code>网页中的每个内容都是一次http请求获取，请求过多，那么响应就会变慢。所以可以图片合并，JavaScript合并，css合并</code></pre><h3 id="使用cdn（内容分发网络）"><a href="#使用cdn（内容分发网络）" class="headerlink" title="使用cdn（内容分发网络）"></a>使用cdn（内容分发网络）</h3><pre><code>再离你最近的地方，放置一台性能好链接顺畅的副本服务器，让你能够以最近的距离，最快的速度获取内容。</code></pre><h3 id="添加expire-cache-control头"><a href="#添加expire-cache-control头" class="headerlink" title="添加expire/cache-control头"></a>添加expire/cache-control头</h3><pre><code>当浏览器发送请求时候，如果nginx返回了一个expire响应头字段。资源在本地的过期时间，存在本地。Cache-control是http协议中常用的头部之一负责控制页面的缓存机制。</code></pre><h3 id="启用gzip压缩"><a href="#启用gzip压缩" class="headerlink" title="启用gzip压缩"></a>启用gzip压缩</h3><pre><code>把文件发在服务器压缩后，然后在传输，然后浏览器解压缩。将文件变小，减少了流通量。</code></pre><h3 id="将css放在页面最上面"><a href="#将css放在页面最上面" class="headerlink" title="将css放在页面最上面"></a>将css放在页面最上面</h3><pre><code>层得样式表单，后面的css,级别更高的css可以重叠前面的。css放在后面禁止了网页内容的顺序显示避免页面重现空白或者选错的问题，提高浏览器的渲染，需要把css放在前面。这样再加载html的时候因为css已经加载完毕，在渲染的时候就不会出现空白或者选错问题。</code></pre><h3 id="将script放在页面最下面"><a href="#将script放在页面最下面" class="headerlink" title="将script放在页面最下面"></a>将script放在页面最下面</h3><pre><code>dom加载顺序（读取html-&gt;head-&gt;meta-&gt;title-&gt;style-&gt;link-&gt;script-&gt;body-&gt;div-&gt;img）比如你写了一个script死循环，没有放在最后面而是放在body前面，那么后面的内容就显示不出来了。</code></pre><h3 id="避免在css中使用expression"><a href="#避免在css中使用expression" class="headerlink" title="避免在css中使用expression"></a>避免在css中使用expression</h3><pre><code>css expression: css表达式 比如:  width: calc(100% - 100px);页面显示和缩放，页面滚动，移动鼠标都会导致css expression重新计算</code></pre><h3 id="把JavaScript和css放在外部文件中"><a href="#把JavaScript和css放在外部文件中" class="headerlink" title="把JavaScript和css放在外部文件中"></a>把JavaScript和css放在外部文件中</h3><pre><code>// 单独提出-》减少文件体积；提高复用性；可维护性 // 卸载页面里面-》减少请求数；提升页面渲染速度比如common.css放在外部。如果不经常访问后者只是应用与一个页面的样式就写在里面或者脚本和样式内容很少。</code></pre><h3 id="减少dns查询"><a href="#减少dns查询" class="headerlink" title="减少dns查询"></a>减少dns查询</h3><pre><code>// 再第一次打开www.a.com的时候，必须通过一个机制，将www.a.com转化为10.96.14.1.1de的形式，然后dns查找找到www.a.com的位置。浏览器会自动缓存，可以减少dns查询，不过缓存时间长，如果www.a.com的地址发生变化就不会即使检测到。可以使用单域或者多域的方式。多域: 图片放在img.a.com, js放在js.a.com, 其他www.a.com</code></pre><h3 id="压缩JavaScript和css"><a href="#压缩JavaScript和css" class="headerlink" title="压缩JavaScript和css"></a>压缩JavaScript和css</h3><pre><code>也就是格式化，把js，css压成一坨。去除不必要的空白符，格式符，注释符减写方法名，参数名。</code></pre><h3 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h3><pre><code>原请求被重新转向了其他请求301 Moved pearmanently（永久重定向）用户请求的页面a.com被移动到了b.com,那么用户会在发送一个请求到b.com302 Found（临时重定向）用户请求的页面被找到了，但不在原始位置，所以服务器会回复一个新地址。增加了浏览器和服务器的往返次数。增加了http请求</code></pre><h3 id="移除重复的脚本"><a href="#移除重复的脚本" class="headerlink" title="移除重复的脚本"></a>移除重复的脚本</h3><pre><code>避免因为重复代码导致的页面内容显示错误</code></pre><h3 id="配置实体标签"><a href="#配置实体标签" class="headerlink" title="配置实体标签"></a>配置实体标签</h3><pre><code>Etag = entity Tag，属于http协议，受到web服务支持。使用特殊的字符串来标识某个请求资源版本浏览器请求资源的时候，如果请求字段的Etag和服务器一致，那么资源没有改动，返回304 not modified（说明无需再次传输请求的内容，也就是说可以使用缓存的内容）。浏览器使用缓存。</code></pre><h3 id="使用ajax缓存"><a href="#使用ajax缓存" class="headerlink" title="使用ajax缓存"></a>使用ajax缓存</h3><pre><code>分批加载和局部更新post 每次都执行 不被缓存get 同一地址不重复执行， 可以被缓存</code></pre><h3 id="减少dom操作"><a href="#减少dom操作" class="headerlink" title="减少dom操作"></a>减少dom操作</h3><pre><code>因为dom操作会引起重排和重绘，同时DOM和js其实是在两个文件，每次都要建立连接减少DOM 操作体现为:- 如果在一个局部方法中需要多次访问同一个dom，则先暂存它的引用- 用querySelectorAll()替代getElementByXX()。- 少用HTML集合（类数组）来遍历，因为集合遍历比真数组遍历耗费更高。- 用事件委托来减少事件处理器的数量。</code></pre><h3 id="减少重排"><a href="#减少重排" class="headerlink" title="减少重排"></a>减少重排</h3><pre><code>- 避免设置大量的style属性- 实现元素的动画，它的position属性，最好是设为absoulte或fixed，这样不会影响其他元素的布局,这点主要是体现在触发 BFC 机制上- 不要使用table布局，因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。是在要用设置 table-layout:auto; 或者 table-layout:flex;</code></pre><h3 id="dns预解析"><a href="#dns预解析" class="headerlink" title="dns预解析"></a>dns预解析</h3><pre><code>如果是http协议开头的页面 a 标签是默认开启dns预解析的, 如果是https协议开头的页面 a 标签是默认关闭dns预解析的就使用 &lt;meta http=&#39;x-dnc-prefetch-contorl&#39;&gt; 开启dns预解析 &lt;link rel=&#39;dns-prefetch&#39;&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《打包系列|gulp配置篇》</title>
      <link href="2021/05/24/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97gulp%E9%85%8D%E7%BD%AE%E7%AF%87/"/>
      <url>2021/05/24/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97gulp%E9%85%8D%E7%BD%AE%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>gulp用的也不是很熟，他和rollup不一样，是用的commonJS规范编写配置。<br>配置文件叫做gulpfile.js, 他的特点就是流式编写配置。通过定义一些列任务<br>然后组合进行打包. 通过<code>npm i gulp -g</code>安装</p><h2 id="下面是一个网上别人写的gulp的配置"><a href="#下面是一个网上别人写的gulp的配置" class="headerlink" title="下面是一个网上别人写的gulp的配置"></a>下面是一个网上别人写的gulp的配置</h2><p>不过我没有验证是否正确,但是其实配置就那么回事，在npm源里一个一个的查插件吧<br>都webpack过来的，需要哪些插件都是知道的，不过就是插件前缀名字叫gulp-xxx就好了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line">   <span class="keyword">let</span> sass = <span class="built_in">require</span>(<span class="string">&#x27;gulp-sass&#x27;</span>);  <span class="comment">// sass -&gt; css</span></span><br><span class="line">   <span class="keyword">let</span> prefixer = <span class="built_in">require</span>(<span class="string">&#x27;gulp-autoprefixer&#x27;</span>);  <span class="comment">// 增加前缀</span></span><br><span class="line">   <span class="keyword">let</span> minify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-minify-css&#x27;</span>);  <span class="comment">// css 压缩</span></span><br><span class="line">   <span class="keyword">let</span> notify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-notify&#x27;</span>);  <span class="comment">// 打印提醒语句</span></span><br><span class="line">   <span class="keyword">let</span> concat = <span class="built_in">require</span>(<span class="string">&#x27;gulp-concat&#x27;</span>);  <span class="comment">// 合并</span></span><br><span class="line">   <span class="keyword">let</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line">   <span class="keyword">let</span> imagemin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-imagemin&#x27;</span>);</span><br><span class="line">   <span class="keyword">let</span> cache = <span class="built_in">require</span>(<span class="string">&#x27;gulp-cache&#x27;</span>);  <span class="comment">// 减少重复压缩</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查脚本</span></span><br><span class="line">   gulp.task(<span class="string">&#x27;lint&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       gulp.src(<span class="string">&#x27;./static/src/js/*.js&#x27;</span>)</span><br><span class="line">           .pipe(jshint())</span><br><span class="line">           .pipe(jshint.reporter(<span class="string">&#x27;default&#x27;</span>))</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 编译Sass</span></span><br><span class="line">   <span class="comment">// 编译Sass</span></span><br><span class="line">   gulp.task(<span class="string">&#x27;css&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 任务名</span></span><br><span class="line">       gulp.src(<span class="string">&#x27;sass/*.scss&#x27;</span>)  <span class="comment">// 目标 sass 文件</span></span><br><span class="line">           .pipe(sass())  <span class="comment">// sass -&gt; css</span></span><br><span class="line">           .pipe(prefixer(<span class="string">&#x27;last 2 versions&#x27;</span>))  <span class="comment">// 参数配置参考 &lt;https://github.com/ai/browserslist&gt;</span></span><br><span class="line">           .pipe(minify())  <span class="comment">// 压缩</span></span><br><span class="line">           .pipe(gulp.dest(<span class="string">&#x27;css&#x27;</span>))  <span class="comment">// 目标目录</span></span><br><span class="line">           .pipe(notify(&#123;<span class="attr">message</span>: <span class="string">&#x27;done&#x27;</span>&#125;))</span><br><span class="line">           .pipe(concat(<span class="string">&#x27;all.min.css&#x27;</span>))  <span class="comment">// 合并</span></span><br><span class="line">           .pipe(gulp.dest(<span class="string">&#x27;css&#x27;</span>));  <span class="comment">// 目标目录</span></span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 压缩图片</span></span><br><span class="line">   gulp.task(<span class="string">&#x27;imagemin&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       gulp.src(<span class="string">&#x27;src/images/*&#x27;</span>)</span><br><span class="line">           .pipe(cache(imagemin(&#123; <span class="attr">optimizationLevel</span>: <span class="number">3</span>, <span class="attr">progressive</span>: <span class="literal">true</span>, <span class="attr">interlaced</span>: <span class="literal">true</span> &#125;)))</span><br><span class="line">           .pipe(gulp.dest(<span class="string">&#x27;dist/images/&#x27;</span>));</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并，压缩js文件</span></span><br><span class="line">   gulp.task(<span class="string">&#x27;scripts&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       gulp.src(<span class="string">&#x27;./static/src/js/*.js&#x27;</span>)</span><br><span class="line">           .pipe(concat(<span class="string">&#x27;all.js&#x27;</span>))  <span class="comment">// 合并</span></span><br><span class="line">           .pipe(gulp.dest(<span class="string">&#x27;./static/dist/js&#x27;</span>))</span><br><span class="line">           .pipe(rename(<span class="string">&#x27;all.min.js&#x27;</span>))</span><br><span class="line">           .pipe(uglify())</span><br><span class="line">           .pipe(gulp.dest(<span class="string">&#x27;./static/dist/js&#x27;</span>));</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 默认任务</span></span><br><span class="line">   gulp.task(<span class="string">&#x27;default&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       gulp.run(<span class="string">&#x27;lint&#x27;</span>, <span class="string">&#x27;sass&#x27;</span>,<span class="string">&#x27;imagemin&#x27;</span>, <span class="string">&#x27;scripts&#x27;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 监听文件变化</span></span><br><span class="line">       gulp.watch([</span><br><span class="line">           <span class="string">&#x27;./static/src/scss/*.scss&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;./static/src/images/**&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;./static/src/js/*.js&#x27;</span></span><br><span class="line">       ], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           gulp.run(<span class="string">&#x27;lint&#x27;</span>, <span class="string">&#x27;sass&#x27;</span>,<span class="string">&#x27;imagemin&#x27;</span>, <span class="string">&#x27;scripts&#x27;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h2 id="这是代码"><a href="#这是代码" class="headerlink" title="这是代码"></a>这是代码</h2><p><a href="https://github.com/ChenWoyao/baleExample/tree/master/gulp_example">gulp配置代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 打包系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《打包系列|rollup配置篇》</title>
      <link href="2021/05/24/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97rollup%E9%85%8D%E7%BD%AE%E7%AF%87/"/>
      <url>2021/05/24/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97rollup%E9%85%8D%E7%BD%AE%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>不像webpack 配置比较繁琐</li><li>ejs模式自动tree shaking</li><li>不会像webpack一样打包生成很多多余代码(webpack自定的require,factory函数等)</li></ul><p>所以常用来打包公共js库</p><blockquote><p>注意:</p><p><em>rollup tree shaking 无法直接处理 Class 模块(一般用gulp在处理一次)</em><br><em>Rollup tree shaking 只处理函数和顶层 import / export导入的变量</em></p></blockquote><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>由<code>npm i rollup -g</code>全局安装<br>通过rollup.config.js来配置rollup的打包规则, 使用的是esm语法.<br>关于各个配置项的介绍</p><ul><li><p><code>input</code>:<br>入口文件地址</p></li><li><p><code>output</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  file: <span class="string">&#x27;bundles.js&#x27;</span> <span class="comment">// 输出文件</span></span><br><span class="line">  format: <span class="string">&#x27;cjs&#x27;</span> <span class="comment">// 输出格式: cjs, umd, iife, es6, amd</span></span><br><span class="line">  <span class="comment">// format为iife或者umd的时候必须配置, 会作为全局变量</span></span><br><span class="line">  <span class="comment">// name: &#x27;woyaoUtil&#x27;,</span></span><br><span class="line">  sourcemap: <span class="literal">true</span> <span class="comment">// 生成源码映射文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>plugins</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rollup typescript配置处理</span></span><br><span class="line"><span class="string">`@rollup/plugin-typescript`</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 帮助寻找node_modules里的包</span></span><br><span class="line"><span class="comment">* rollup.js编译源码中的模块引用默认只支持ES6+的模块方式import/export。</span></span><br><span class="line"><span class="comment">* 然而大量的npm模块是基于CommonJS模块方式，这就导致了大量 npm 模块不能直接编译使用。</span></span><br><span class="line"><span class="comment">* 所以辅助rollup.js编译支持npm模块和CommonJS模块方式的插件就应运而生</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="string">`@rollup/plugin-node-resolve`</span></span><br><span class="line"><span class="comment">// 支持import &#x27;xx.json&#x27;文件</span></span><br><span class="line"><span class="string">`@rollup/plugin-json`</span></span><br><span class="line"><span class="comment">// 在打包的时候把目标字符串替换å</span></span><br><span class="line"><span class="string">`@rollup/plugin-replace`</span></span><br><span class="line"><span class="comment">// 对打包的js进行压缩</span></span><br><span class="line"><span class="string">`rollup-plugin-terser`</span></span><br><span class="line"><span class="comment">// 删除原来的bundle</span></span><br><span class="line"><span class="string">`rollup-plugin-delete`</span></span><br><span class="line"><span class="comment">// 显示打包后文件的大小</span></span><br><span class="line"><span class="string">`rollup-plugin-filesize`</span></span><br><span class="line"><span class="comment">// 将CommonJs语法转成es5</span></span><br><span class="line"><span class="string">`rollup-plugin-commonjs`</span></span><br><span class="line"><span class="comment">// rollup 的 babel 插件，ES6转ES5</span></span><br><span class="line"><span class="string">`rollup-plugin-babel`</span></span><br></pre></td></tr></table></figure></li><li><p><code>external</code>:</p><p>告诉rollup不要把第三方库进行打包，而是作为外部依赖, 配合”peerDependencies“使用，<br>这样业务代码引入我们的公共库的时候避免了重复下载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三方esm 语法的包</span></span><br><span class="line"><span class="keyword">const</span> external = [<span class="regexp">/lodash-es\/[a-z]+/</span>, <span class="string">&#x27;ts-date&#x27;</span>, <span class="string">&#x27;classnames&#x27;</span>]</span><br><span class="line"><span class="comment">// 第三方cjs 语法的包</span></span><br><span class="line"><span class="keyword">const</span> cjsExteranl = [<span class="string">&#x27;classnames&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>global</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">globals: &#123;</span><br><span class="line">        <span class="string">&#x27;react&#x27;</span>: <span class="string">&#x27;React&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;react-dom&#x27;</span>: <span class="string">&#x27;ReactDOM&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>package.json</code>中需要注意的点:</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;module&quot;</span> <span class="comment">// 打包的esm规范的bundle设置入口</span></span><br><span class="line"><span class="string">&quot;peerDependencies&quot;</span> <span class="comment">// 第三方库应该在这里强调依赖的版本</span></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;rollup -c&quot;,</span><br><span class="line">    &quot;build:dev&quot;: &quot;npm run clean &amp;&amp; env_type=development npm run build&quot;,</span><br><span class="line">    &quot;build:prod&quot;: &quot;npm run clean &amp;&amp; env_type=production npm run build&quot;,</span><br><span class="line">    &quot;clean&quot;: &quot;rimraf umd&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个生成umd bundle的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nodeResolve <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-node-resolve&#x27;</span></span><br><span class="line"><span class="keyword">import</span> replace <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-replace&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-terser&#x27;</span></span><br><span class="line"><span class="keyword">import</span> filesize <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-filesize&#x27;</span></span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-commonjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; babel &#125; <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-babel&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> env = process.env.env_type</span><br><span class="line"><span class="keyword">const</span> isProdEnv = env === <span class="string">&#x27;production&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    input: <span class="string">&#x27;src/index.js&#x27;</span>,</span><br><span class="line">    external: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>],</span><br><span class="line">    output: &#123;</span><br><span class="line">        name: <span class="string">&#x27;WoyaoUtil&#x27;</span>,</span><br><span class="line">        file: <span class="string">&#x27;umd/woyao-util.js&#x27;</span>,</span><br><span class="line">        format: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">        sourcemap: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">    nodeResolve(),</span><br><span class="line">    babel(&#123;</span><br><span class="line">        exclude: <span class="string">&#x27;**/node_modules/**&#x27;</span>,</span><br><span class="line">        babelHelpers: <span class="string">&#x27;bundled&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    isProdEnv &amp;&amp; filesize(),</span><br><span class="line">    replace(&#123;</span><br><span class="line">        <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="built_in">JSON</span>.stringify(env)</span><br><span class="line">    &#125;),</span><br><span class="line">    commonjs(),</span><br><span class="line">    isProdEnv &amp;&amp; terser()</span><br><span class="line">].filter(<span class="built_in">Boolean</span>)</span><br><span class="line"></span><br><span class="line">config.plugins = plugins</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> config</span><br></pre></td></tr></table></figure><p>babel需要作如下配置:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置为false, 否则babel会在rollup有机会执行其操作之前导致我们的模块转化为commonjs</span></span><br><span class="line">                <span class="attr">&quot;modules&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="comment">// polyfill按需引入</span></span><br><span class="line">                <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;corejs&quot;</span>: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;@babel/preset-react&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>不过我们实际开发并不会打包成umd格式的文件，因为umd格式的包文件很大。</em></p><p><em>一般会分开打包一个cjs包和一个es包。然后把cjs包写进package.json的main属性，</em></p><p><em>把es包写进package.json的module属性</em></p></blockquote><h1 id="typescript-配置"><a href="#typescript-配置" class="headerlink" title="typescript 配置"></a>typescript 配置</h1><p>需要安装下面几个包:</p><ul><li><code>typescript</code></li><li><code>@rollup/plugin-typescript</code></li><li><code>tslib</code></li></ul><p>rollup.config.js的配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-typescript&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">    typescript(&#123;</span><br><span class="line">      declaration: <span class="literal">false</span></span><br><span class="line">    &#125;),</span><br><span class="line">    nodeResolve(),</span><br><span class="line">    commonjs(),</span><br><span class="line">  replace(&#123;</span><br><span class="line">        <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="built_in">JSON</span>.stringify(env)</span><br><span class="line">    &#125;),</span><br><span class="line">    babel(&#123;</span><br><span class="line">        exclude: <span class="string">&#x27;**/node_modules/**&#x27;</span>,</span><br><span class="line">        babelHelpers: <span class="string">&#x27;bundled&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    isProdEnv &amp;&amp; filesize(),</span><br><span class="line">    isProdEnv &amp;&amp; terser()</span><br><span class="line">].filter(<span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure><p>typescript的配置文件tsconfig.json一般如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;allowUnreachableCode&quot;</span>: <span class="literal">true</span>, <span class="comment">// 不报告执行不到的代码错误。</span></span><br><span class="line">        <span class="attr">&quot;allowUnusedLabels&quot;</span>: <span class="literal">false</span>, <span class="comment">// 不报告未使用的标签错误</span></span><br><span class="line">        <span class="attr">&quot;alwaysStrict&quot;</span>: <span class="literal">false</span>, <span class="comment">// 以严格模式解析并为每个源文件生成 &quot;use strict&quot;语句</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>, <span class="comment">// 工作根目录</span></span><br><span class="line">        <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>, <span class="comment">// 启用实验性的ES装饰器</span></span><br><span class="line">        <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>, <span class="comment">// 在 .tsx文件里支持JSX</span></span><br><span class="line">        <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否生成map文件</span></span><br><span class="line">        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;ES2015&quot;</span>, <span class="comment">// 指定生成哪个模块系统代码</span></span><br><span class="line">        <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">false</span>, <span class="comment">// 是否默认禁用 any</span></span><br><span class="line">        <span class="attr">&quot;removeComments&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否移除注释</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ESNext&quot;</span>, <span class="comment">// 编译的目标是什么版本的</span></span><br><span class="line">        <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>, <span class="comment">// 输出目录</span></span><br><span class="line">        <span class="attr">&quot;declaration&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否自动创建类型声明文件</span></span><br><span class="line">        <span class="attr">&quot;declarationDir&quot;</span>: <span class="string">&quot;./ts/lib&quot;</span>, <span class="comment">// 类型声明文件的输出目录</span></span><br><span class="line">        <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许编译javascript文件。</span></span><br><span class="line">        <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;lib&quot;</span>: [ <span class="comment">// 编译过程中需要引入的库文件的列表</span></span><br><span class="line">            <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">            <span class="string">&quot;es2016&quot;</span>,</span><br><span class="line">            <span class="string">&quot;es2017&quot;</span>,</span><br><span class="line">            <span class="string">&quot;es2018&quot;</span>,</span><br><span class="line">            <span class="string">&quot;dom&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）</span></span><br><span class="line">    <span class="attr">&quot;include&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 指定一个排除列表（include的反向操作）</span></span><br><span class="line">    <span class="attr">&quot;exclude&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">        <span class="string">&quot;dist&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译css"><a href="#编译css" class="headerlink" title="编译css"></a>编译css</h1><p>需要安装下面插件</p><ul><li><code>rollup-plugin-postcss</code></li></ul><p>Rollup.config.js的配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> postcss <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-postcss&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">    typescript(),</span><br><span class="line">    nodeResolve(),</span><br><span class="line">    commonjs(),</span><br><span class="line">  replace(&#123;</span><br><span class="line">        <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="built_in">JSON</span>.stringify(env)</span><br><span class="line">    &#125;),</span><br><span class="line">    babel(&#123;</span><br><span class="line">        exclude: <span class="string">&#x27;**/node_modules/**&#x27;</span>,</span><br><span class="line">        babelHelpers: <span class="string">&#x27;bundled&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    postcss(),</span><br><span class="line">    isProdEnv &amp;&amp; filesize(),</span><br><span class="line">    isProdEnv &amp;&amp; terser()</span><br><span class="line">].filter(<span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我写了两个rollup的配置，一个是生成js公共库的，一个是生成js组件库的。<br>js公共库打包的代码是umd规范的,但是一般来说是要分别生成一个cjs和es规范的<br>两个文件。</p><p>js组件库我是分了两个环境的，开发环境打包成csj，生产环境打包成commonjs.<br>另外开发环境允许热更行并开启服务，生产环境除了代码打包以后，因为rollup的<br>treeshaking机制对直接处理 Class 模块，只处理函数和顶部Import/exprot.<br>所以我还写了一个gulp的打包后的es规范的包进行二次处理。</p><p><a href="https://github.com/ChenWoyao/baleExample/tree/master/woyao_util">这是rollup配置js公共库的代码</a></p><p><a href="https://github.com/ChenWoyao/baleExample/tree/master/woyao_library">这是rollup和gulp配置公共组件库的代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 打包系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《打包系列|webpack配置篇》</title>
      <link href="2021/05/24/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97webpack%E9%85%8D%E7%BD%AE%E7%AF%87/"/>
      <url>2021/05/24/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97webpack%E9%85%8D%E7%BD%AE%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h1><h2 id="初始化webpack"><a href="#初始化webpack" class="headerlink" title="初始化webpack"></a>初始化webpack</h2><p>通过<code>npm i -g webpack webpack-cli</code>下载webpack和webpack的命令行包。</p><h2 id="js-配置"><a href="#js-配置" class="headerlink" title="js 配置"></a>js 配置</h2><p>我们都知道es6语法在低版本浏览器内是不会被识别的, 另外有一些语法不会被浏览器支持。于是就有了<br><code>babel</code>这个工具链: 将 <code>ECMAScript 2015+</code> （又可称为<code>ES6</code>，<code>ES7</code>，<code>ES8</code>等）版本的代码转换为向后兼容的 <code>JavaScript</code> 语法，以便能够运行在当前和旧版本的浏览器或其他环境中</p><p>Babel 主要做了如下三件事:</p><ul><li>语法转换</li><li>通过 <code>Polyfill</code> 方式在目标环境中添加缺失的特性 (通过 <code>@babel/polyfill</code> 模块)</li><li>源码转换, 比如 JSX 等</li></ul><p>关于babel的相关插件和预设(.babelrc是babel的配置文件):</p><ul><li><code>@babel/core</code>:<br>babel的核心功能, 没有我下面的插件都别想用</li><li><code>@babel/preset-env</code>:<br>提供一个预设环境(其实就是各种语法翻译包),是很多语法能够被转换成es5(箭头语法, let， const等)<br>但是有些es6后面的语法比如(includes等)是不会被翻译的. 另外babel的插件的使用都需要这个预设库<br>支持。</li><li><code>@babel/preset-react</code>:<br>对react jsx等语法的翻译处理，另外可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining">js可选链操作</a></li><li><code>@babel/cli</code>:<br>一个内置的 CLI 命令行工具，可通过命令行编译文件<br>比如:<code>babel index.js -o ./dist/index.js</code></li><li><code>@babel/polyfill</code>:<br>包括<code>core-js</code>和一个自定义的<code>regenerator runtime</code>模块.<br>解决了有些浏览器或者低版本NodeJs下(inclues, promise, async, from等)语法不支持的问题</li><li><code>@babel/plugin-transform-runtime</code>:<br>防止打包后的文件中出现重复声明的函数, 它可以重复使用 Babel 注入的 helpers 函数，达到节省代码大小的目的</li><li><code>@babel/runtime</code>:<br>@babel/plugin-transform-runtime这个插件需要@babel/runtime配合使用<br>供业务代码引入模块化的 Babel helpers 函数</li></ul><p>babel的运作流程如下:<br>source code -&gt; @babel/core -&gt; ast -&gt;<br>@babel/traverse 和 @babel/types -&gt; ast -&gt; @babel/generator -&gt; output</p><p>但是babel会把esm的import语法变成CommonJS语法，这是不会被浏览器识别的。所以需要用打包工具处理</p><p>另外@babel/polyfill这个包文件很大.<br>一般会用 babel-polyfill 结合 @babel/preset-env + useBuiltins（entry） + preset-env targets 的方案<br>@babel/preset-env提供插件需要的预设环境, useBuiltins实现polyfill的按需引用<br>于是就有了下面的.babelrc配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">                <span class="string">&quot;corejs&quot;</span>: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;@babel/preset-react&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 支持 import(&#x27;xx.js&#x27;).then((&#123;default: file&#125;) =&gt; &#123;&#125;)语法</span></span><br><span class="line">        <span class="string">&quot;dynamic-import-webpack&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先关的js处理在webpack配置如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isProdMode = process.argv.indexOf(<span class="string">&quot;--mode=production&quot;</span>) !== -<span class="number">1</span></span><br><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            cacheDirectory: <span class="literal">true</span>, <span class="comment">// false是使用缓存, 所以就是对node_modules下的包进行缓存</span></span><br><span class="line">            cacheCompression: isProdMode <span class="comment">// true是对每个Babel的输出将使用Gzip压缩, 开发环境当然不要压缩了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>另外有时候在开发公共包的时候，团队协作可能就需要使用typescript了，typescript该怎么处理配置呢?</p><ul><li>webpack的配置文件下添加如下处理:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">    use: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>添加ts-loader的配置文件<code>tsconfig.json</code></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./dist/&quot;</span>,  <span class="comment">// 重定向输出目录。</span></span><br><span class="line">      <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span> : <span class="literal">true</span>, <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line">      <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;es6&quot;</span>, <span class="comment">// 指定生成哪个模块系统代码</span></span><br><span class="line">      <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>, <span class="comment">// 指定ECMAScript目标版本</span></span><br><span class="line">      <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span> <span class="comment">//允许ts中引入js</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;include&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;mock/**/*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;src/**/*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;config/**/*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.umirc.ts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;typings.d.ts&quot;</span></span><br><span class="line">      ],</span><br><span class="line">    <span class="attr">&quot;exclude&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lib&quot;</span>,</span><br><span class="line">        <span class="string">&quot;es&quot;</span>,</span><br><span class="line">        <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">        <span class="string">&quot;typings&quot;</span>,</span><br><span class="line">        <span class="string">&quot;**/__test__&quot;</span>,</span><br><span class="line">        <span class="string">&quot;test&quot;</span>,</span><br><span class="line">        <span class="string">&quot;docs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tests&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="样式配置"><a href="#样式配置" class="headerlink" title="样式配置"></a>样式配置</h2><p>关于css的处理，一般要处理各种浏览器的css样式兼容性，支持scss等。下面是各种loader和插件的解释:</p><ul><li><p><code>require(&quot;mini-css-extract-plugin&quot;).loder</code>:<br>把css拆分出来用外链的形式引入css文件，该插件会将所有的css样式合并为一个css文件</p></li><li><p><code>style-loader</code>:<br>把css插入到style中</p></li><li><p><code>css-loader</code>:<br>对<code>@import</code>,<code>url()</code>进行处理</p></li><li><p><code>sass-loader</code>:<br>把scss/sass 翻译成css</p></li><li><p><code>postcss-loader</code>:<br>使用<code>postcss</code>处理css</p></li><li><p><code>postcss</code>:<br>把css解析为一个抽象语法树, 调用插件处理抽象语法树并添加功能</p></li><li><p><code>autoprefixer</code>:<br>添加前缀的，解决浏览器兼容问题. 添加webkit, mozilla前缀</p></li><li><p><code>postcss-plugin-px2rem</code>:<br>根据跟节点fontsize设置,将px装成rem</p></li></ul><p>在webpack中配置如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> isProdMode = process.argv.indexOf(<span class="string">&quot;--mode=production&quot;</span>) !== -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> isDevMode = process.argv.indexOf(<span class="string">&quot;--mode=development&quot;</span>) !== -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getStyleLoaders = <span class="function">(<span class="params">cssOptions, preProcessors</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loaders = [</span><br><span class="line">        isDevMode &amp;&amp; <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">        isProdMode &amp;&amp; MiniCssExtractPlugin.loader,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="built_in">require</span>.resolve(<span class="string">&quot;css-loader&quot;</span>),</span><br><span class="line">            options: cssOptions,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="built_in">require</span>.resolve(<span class="string">&quot;postcss-loader&quot;</span>),</span><br><span class="line">            options: &#123;</span><br><span class="line">                postcssOptions: &#123;</span><br><span class="line">                    plugins: [</span><br><span class="line">                        <span class="built_in">require</span>(<span class="string">&quot;postcss-preset-env&quot;</span>)(&#123;</span><br><span class="line">                            autoprefixer: &#123;</span><br><span class="line">                                overrideBrowderslist: <span class="string">&quot;andoroid &gt;= 4.3&quot;</span>,</span><br><span class="line">                            &#125;,</span><br><span class="line">                            stage: <span class="number">3</span>,</span><br><span class="line">                        &#125;),</span><br><span class="line">                        <span class="built_in">require</span>(<span class="string">&quot;postcss-plugin-px2rem&quot;</span>)(&#123;</span><br><span class="line">                            rootValue: <span class="number">75</span>,</span><br><span class="line">                            minPixelValue: <span class="number">2</span>, <span class="comment">// 设置要替换的最小像素值</span></span><br><span class="line">                        &#125;),</span><br><span class="line">                    ],</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ].filter(<span class="built_in">Boolean</span>); <span class="comment">// loader 是在数组的从后往前的顺序先后处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preProcessors) &#123;</span><br><span class="line">        loaders.push(&#123;</span><br><span class="line">            loader: <span class="built_in">require</span>.resolve(preProcessors),</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loaders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: getStyleLoaders(&#123;</span><br><span class="line">        importLoaders: <span class="number">1</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(scss|sass)$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/\.module\.(scss|sass)$/</span>,</span><br><span class="line">    <span class="comment">// importLoaders 选项告知走该loader之前需要走几个loader</span></span><br><span class="line">    <span class="comment">// 为了防止经过css-loader处理时没有被sass-loader和postcss-loader处理</span></span><br><span class="line">    use: getStyleLoaders(</span><br><span class="line">        &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;sass-loader&quot;</span></span><br><span class="line">    ),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.module\.(scss|sass)$/</span>,</span><br><span class="line">    use: getStyleLoaders(&#123;</span><br><span class="line">        importLoaders: <span class="number">2</span>,</span><br><span class="line">        sourceMap: isProdMode,</span><br><span class="line">        modules: &#123;</span><br><span class="line">            localIdentName: <span class="string">&#x27;[local]_[hash:base64:6]&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;, <span class="string">&#x27;sass-loader&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="关于sourceMap"><a href="#关于sourceMap" class="headerlink" title="关于sourceMap"></a>关于sourceMap</h2><p>通过sourceMap可以查看报错是出自哪个源文件而不是打包后的文件哪里出错<br>不过使用sourceMap会使得打包速度变慢<br>另外默认在<code>module: &#39;development&#39;</code>环境中sourceMap是默认开启的<br>下面是各种sourceMap的解释:</p><ul><li>devtool: ‘inline-source-map’ 将对应的map文件放到js文件中</li><li>devtool: ‘cheap-inline-source-map’ 告诉你具体哪一行出问题，不会精确到那一列出问题</li><li>devtool: ‘eval’ eval是打包速度最快的除了你设置<code>devtool:none</code></li><li>devtool: ‘cheap-module-eval-source-map’ 推荐development环境使用</li><li>devtool: ‘cheap-module-source-map’ 推荐production环境使用</li></ul><h2 id="各种plugin"><a href="#各种plugin" class="headerlink" title="各种plugin"></a>各种plugin</h2><p>plugin 可以在webpack运行到某个时刻的时候帮你做一些事情，所以plugin有生命周期这个说法。<br>下面是一些常用的插件:<br><code>clean-webpack-plugin</code>:<br>打包前清除上一次打包的文件</p><p><code>htmlWebpackPlugin</code>:<br> 打包结束后，自动生成一个html文件, 并把打包生成的js自动引入到这个html</p><p><code>MiniCssExtractPlugin</code>:<br>把css拆分出来用外链的形式引入css文件，该插件会将所有的css样式合并为一个css文件<br>另外还可以对css进行代码分割</p><p><code>webpack-bundle-analyzer</code>:<br>打包分析工具</p><p><code>HappyPack</code>:<br>开启多进程Loader转换，不过还是别用，经常听到电脑风扇的转动声</p><p><code>HotModuleReplacementPlugin</code>:<br>热更新的模块替换插件</p><p><code>copy-webpack-plugin</code>:<br>拷贝静态资源</p><p><code>css-minimizer-webpack-plugin</code>:<br>压缩css</p><p><code>terser-webpack-plugin</code>:<br>压缩js</p><h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h2><p><a href="https://github.com/ChenWoyao/baleExample/tree/master/treeShaking">这是我写的一个tree shaking demo</a></p><p>去除无用代码, 只支持ESM, 不支持commonJS的require的引入,<br>因为CommonJS定义的模块化规范，只有在执行代码后，才能动态确定依赖模块，所以不支持tree shaking。毕竟tree shaking的本质是在在编译生成AST以后进行无用代码去除<br>默认production模式开启tree shaking(由类似terser-webpack-plugin的插件做的处理)<br>如果想在开发环境中设置tree shaing, 需要这么配置:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --webpack.config.js</span></span><br><span class="line">optimization: &#123;</span><br><span class="line">    usedExports: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --package.json</span></span><br><span class="line"><span class="string">&#x27;sideEffects&#x27;</span>: <span class="literal">false</span></span><br><span class="line"><span class="comment">// 对所有模块做tree shaking, 不过一般我们不对css等进行tree shaking</span></span><br><span class="line"><span class="comment">// 所以要这么配置</span></span><br><span class="line"><span class="string">&quot;sideEffects&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;*.css&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.scss&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.sass&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>另外有时候我们的代码是作为公共库进行开发，可能在Node环境也要运行，而CommonJs又不支持<br>tree shaking. 所以一般我们会有下面的处理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Library&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;dist&#x2F;index.cjs.js&quot;, &#x2F;&#x2F; 打包出一份commonjs规范的bundle</span><br><span class="line">  &quot;module&quot;: &quot;dist&#x2F;index.esm.js&quot;, &#x2F;&#x2F; 打包出一份tree shaking后的ESM规范的bundle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码分割-code-splitting"><a href="#代码分割-code-splitting" class="headerlink" title="代码分割(code splitting)"></a>代码分割(code splitting)</h2><p>当重新载入文件的时候，因为代码分割到了不同文件，<br>只需要对变更代码的文件重新加载即可，所以提升了加载性能<br>在webpack中配置如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    <span class="comment">// 把runtime部分的代码抽离出来单独打包</span></span><br><span class="line">    <span class="comment">// runtime部分的代码是管理各个模块的连接(模块之间的引用关系)</span></span><br><span class="line">    runtimeChunk: &#123;</span><br><span class="line">        name: <span class="string">&quot;runtime&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        <span class="comment">// 对同步代码和异步代码都进行代码分割</span></span><br><span class="line">        <span class="comment">// 如果是async那就是只对异步代码做代码分割</span></span><br><span class="line">        chunks: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">        minSize: <span class="number">30000</span>, <span class="comment">// 表示抽取出来的文件在压缩前的最小大小，默认为30000</span></span><br><span class="line">        maxSize: <span class="number">0</span>, <span class="comment">// 表示抽取出来的文件在压缩前的最大大小，默认为 0，表示不限制最大大小；</span></span><br><span class="line">        minChunks: <span class="number">1</span>, <span class="comment">// 引入的模块最少引入次数，超过才打包</span></span><br><span class="line">        maxAsyncRequests: <span class="number">6</span>, <span class="comment">// 同时加载的模块树</span></span><br><span class="line">        maxInitialRequests: <span class="number">4</span>,</span><br><span class="line">        automaticNameDelimiter: <span class="string">&quot;~&quot;</span>, <span class="comment">// 组和文件名的连接符</span></span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">            vendors: &#123;</span><br><span class="line">                name: <span class="string">&#x27;vendors&#x27;</span>, <span class="comment">// 对这种打包文件放到vendors.js中</span></span><br><span class="line">                enforce: <span class="literal">true</span>, <span class="comment">// 忽略默认参数</span></span><br><span class="line">                test: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 打包的文件来自node_modules</span></span><br><span class="line">                priority: <span class="number">20</span>, <span class="comment">// 不同组的优先级</span></span><br><span class="line">                reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// MiniCssExtractPlugin会对生成的css进行代码分割</span></span><br><span class="line">            <span class="comment">// 然后打包到styles.css的文件中</span></span><br><span class="line">            styles: &#123;</span><br><span class="line">                name: <span class="string">&#x27;styles&#x27;</span>,</span><br><span class="line">                test: <span class="regexp">/\.(scss|sass|css|less)$/</span>,</span><br><span class="line">                chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">                enforce: <span class="literal">true</span>,</span><br><span class="line">                priority: <span class="number">10</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 默认组</span></span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                minChunks: <span class="number">2</span>,</span><br><span class="line">                priority: -<span class="number">20</span>, <span class="comment">// 同时满足多个组条件，谁的优先级高就用谁</span></span><br><span class="line">                reuseExistingChunk: <span class="literal">true</span>, <span class="comment">// 如果一个模块已经被打包了，就用之前打包的模块做引用</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>另外还需要对webpack进行</p><ol><li>多环境配置</li><li>支持多页面入口打包配置</li><li>代码打包分析<br><a href="https://github.com/ChenWoyao/baleExample/tree/master/webpackExample/webpack_config">这是我写的一个webpack配置</a></li></ol><h3 id="谈谈我做的优化"><a href="#谈谈我做的优化" class="headerlink" title="谈谈我做的优化:"></a>谈谈我做的优化:</h3><ul><li><code>alias</code>和<code>extensions</code>的配置减少了webpack搜索路径的查找和根据后缀查找文件</li><li><code>HappyPack</code>开启多进程，是打包速度更快，减少了构建时间</li><li><code>cacheDirectory</code> 开启缓存，将每次的编译结果写进硬盘文件,这样如果打包的模块没有发生变换直接使用缓存就可以</li><li><code>tree shaking</code> 生成环境代码进行无用代码删除在压缩减少了代码的体积</li><li><code>split chunk</code> 代码分割以及抽离第三方模块，只需要对变更代码的文件重新加载即可，所以提升了加载性能</li><li><code>@babel/plugin-transform-runtime</code> 减少了代码的重复声明</li><li><code>dynamic-import-webpack</code> 动态加载，按需引入</li><li><code>external</code> cdn外联引入一些三方库, 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 打包系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《打包系列|webpack原理篇》</title>
      <link href="2021/05/24/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AEwebpack%E5%8E%9F%E7%90%86%E7%AF%87/"/>
      <url>2021/05/24/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AEwebpack%E5%8E%9F%E7%90%86%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-实现"><a href="#webpack-实现" class="headerlink" title="webpack 实现"></a>webpack 实现</h1><p>这是一个如何实现一个简单的webpack生成bundle.js的demo, 主要的实现流程:</p><blockquote><p>入口entry -&gt; 递归解析AST获取依赖 -&gt; 生成依赖图</p><p>-&gt; 为每个模块包裹factory function -&gt; 以入口脚本为起点，递归执行模块 -&gt; 拼接IIFE(factory, require实现) -&gt; 产出bundle</p></blockquote><p>另外需要用到以下插件:</p><ul><li>@babel/parser 用于分析源代码，产出 AST；</li><li>@babel/traverse 用于遍历 AST，找到 import 声明；</li><li>@babel/core 用于编译，将源代码编译为 ES5；</li><li>@babel/preset-env 搭配@babel/core使用；</li><li>resolve 用于获取依赖的绝对路径。</li></ul><p><a href="https://github.com/ChenWoyao/baleExample/tree/master/webpackExample/webpackSource">代码地址</a></p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="comment">// 用于分析源代码，产出 AST</span></span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&quot;@babel/parser&quot;</span>);</span><br><span class="line"><span class="comment">// 用于遍历 AST，找到 import 声明</span></span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&quot;@babel/traverse&quot;</span>).default;</span><br><span class="line"><span class="comment">// 用于编译，将源代码编译为 ES5</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>);</span><br><span class="line"><span class="comment">// 用于获取依赖的绝对路径</span></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="built_in">require</span>(<span class="string">&quot;resolve&quot;</span>).sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 维护一个全局 ID，并通过遍历 AST</span></span><br><span class="line"><span class="comment"> * 访问ImportDeclaration节点,收集依赖到deps数组中，</span></span><br><span class="line"><span class="comment"> * 同时完成 Babel 降级编译</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ID = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</span><br></pre></td></tr></table></figure><h2 id="生成依赖图"><a href="#生成依赖图" class="headerlink" title="生成依赖图"></a>生成依赖图</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了查找一个文件的所有依赖</span></span><br><span class="line"><span class="comment"> * 返回文件的路径，文件的所有引用依赖，文件的esm代码， 模块对应 ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createModuleInfo</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> content = fs.readFileSync(filePath, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(content, &#123; <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> deps = []</span><br><span class="line"></span><br><span class="line">    traverse(ast, &#123;</span><br><span class="line">        ImportDeclaration: <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            deps.push(node.source.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> id = ID++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译成esm5</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAstSync(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">        presets: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        id,</span><br><span class="line">        filePath,</span><br><span class="line">        deps,</span><br><span class="line">        code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// log(createModuleInfo(path.resolve(__dirname, &#x27;./test/app.js&#x27;)))</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对entry入口依赖进行遍历，对每个deps进行依赖信息生成</span></span><br><span class="line"><span class="comment"> * 注意: 这里不支持循环引用,否则死递归</span></span><br><span class="line"><span class="comment"> * 最后生成依赖图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDependencyGraph</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> entryInfo = createModuleInfo(entry)</span><br><span class="line">    <span class="keyword">const</span> graphArr = []</span><br><span class="line">    graphArr.push(entryInfo)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以入口模块为起点，遍历整个项目依赖的模块，并将每个模块信息维护到 graphArr 中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">module</span> <span class="keyword">of</span> graphArr) &#123;</span><br><span class="line">        <span class="built_in">module</span>.map = &#123;&#125;</span><br><span class="line">        <span class="built_in">module</span>.deps.forEach(<span class="function"><span class="params">depPath</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> baseDir = path.dirname(<span class="built_in">module</span>.filePath)</span><br><span class="line">            <span class="keyword">const</span> moduleDepPath = path.resolve(baseDir, depPath)</span><br><span class="line">            <span class="keyword">const</span> moduleInfo = createModuleInfo(moduleDepPath)</span><br><span class="line">            graphArr.push(moduleInfo)</span><br><span class="line">            <span class="built_in">module</span>.map[depPath] = moduleInfo.id</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graphArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对依赖图谱进行处理生成IIFE"><a href="#对依赖图谱进行处理生成IIFE" class="headerlink" title="对依赖图谱进行处理生成IIFE"></a>对依赖图谱进行处理生成IIFE</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 IIFE 的方式，来保证模块变量不会影响到全局作用域</span></span><br><span class="line"><span class="comment"> * 构造好的项目依赖树（Dependency Graph）数组，将会作为名为modules的行参，传递给 IIFE</span></span><br><span class="line"><span class="comment"> * 通过require(map[requireDeclarationName])方式，按顺序递归调用各个依赖模块</span></span><br><span class="line"><span class="comment"> * 通过调用factory(module.exports, localRequire)执行模块相关代码</span></span><br><span class="line"><span class="comment"> * 该方法最终返回module.exports对象，module.exports 最初值为空对象（&#123;exports: &#123;&#125;&#125;）</span></span><br><span class="line"><span class="comment"> * 但在一次次调用factory()函数后，module.exports对象内容已经包含了模块对外暴露的内容了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pack</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> moduleArgArr = graph.map(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">module</span>.id&#125;</span>: &#123;</span></span><br><span class="line"><span class="string">            factory: (exports, require) =&gt; &#123;</span></span><br><span class="line"><span class="string">                <span class="subst">$&#123;<span class="built_in">module</span>.code&#125;</span></span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            map: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">module</span>.map)&#125;</span></span></span><br><span class="line"><span class="string">        &#125;`</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> iifeBundler = <span class="string">`(function(modules)&#123;</span></span><br><span class="line"><span class="string">        const require = id =&gt; &#123;</span></span><br><span class="line"><span class="string">            const &#123;factory, map&#125; = modules[id];</span></span><br><span class="line"><span class="string">            const localRequire = requireDeclarationName =&gt; require(map[requireDeclarationName]);</span></span><br><span class="line"><span class="string">            const module = &#123;exports: &#123;&#125;&#125;;</span></span><br><span class="line"><span class="string">            factory(module.exports, localRequire);</span></span><br><span class="line"><span class="string">            return module.exports;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        require(0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#125;)(&#123;<span class="subst">$&#123;moduleArgArr.join()&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    <span class="keyword">return</span> iifeBundler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="webpack-loader-和-plugin"><a href="#webpack-loader-和-plugin" class="headerlink" title="webpack loader 和 plugin"></a>webpack loader 和 plugin</h1><p>下面再写一下简单的实现一个loader 和 plugin<br><a href="https://github.com/ChenWoyao/baleExample/tree/master/webpackExample/webpack_other">代码地址如下</a></p><h1 id="webpack-hmr"><a href="#webpack-hmr" class="headerlink" title="webpack hmr"></a>webpack hmr</h1><p>基本实现原理大致这样的，构建 bundle 的时候，加入一段 HMR runtime 的 js 和一段和服务沟通的 js 。文件修改会触发 webpack 重新构建，服务器通过向浏览器发送更新消息，浏览器通过 jsonp 拉取更新的模块文件，jsonp 回调触发模块热替换逻辑。</p><h2 id="服务端主要使用了-webpack-express-websocket"><a href="#服务端主要使用了-webpack-express-websocket" class="headerlink" title="服务端主要使用了: webpack, express, websocket"></a>服务端主要使用了: webpack, express, websocket</h2><blockquote><p>使用express启动本地服务，当浏览器访问资源时对此做响应<br>服务端和客户端使用websocket实现长连接</p><p>webpack监听源文件的变化，即当开发者保存文件时触发webpack的重新编译<br>每次编译都会生成hash值、已改动模块的json文件、已改动模块代码的js文件<br>编译完成后通过socket向客户端推送当前编译的hash戳</p><p>客户端的websocket监听到有文件改动推送过来的hash戳，会和上一次对比<br>一致则走缓存,不一致则通过ajax和jsonp向服务端获取最新资源</p><p>使用内存文件系统去替换有修改的内容实现局部刷新</p></blockquote><p>具体步骤如下：<br>启动webpack-dev-server服务器<br>创建webpack实例<br>创建Server服务器</p><p>添加webpack的done事件回调<br>编译完成向客户端发送消息</p><p>创建express应用app<br>设置文件系统为内存文件系统<br>添加webpack-dev-middleware中间件<br>中间件负责返回生成的文件（生成hash值、已改动模块的json文件、已改动模块代码的js文件）</p><p>启动webpack编译</p><p>创建http服务器并启动服务<br>使用sockjs在浏览器端和服务端之间建立一个 websocket 长连接</p><p>创建socket服务器</p><h2 id="客户端具体步骤-客户端bundles-js内被webpack处理后加入了一段websocket客户端代码"><a href="#客户端具体步骤-客户端bundles-js内被webpack处理后加入了一段websocket客户端代码" class="headerlink" title="客户端具体步骤(客户端bundles.js内被webpack处理后加入了一段websocket客户端代码)"></a>客户端具体步骤(客户端bundles.js内被webpack处理后加入了一段websocket客户端代码)</h2><blockquote><p>webpack-dev-server/client端会监听到此hash消息<br>客户端收到ok的消息后会执行reloadApp方法进行更新</p><p>在reloadApp中会进行判断，是否支持热更新，如果支持的话发射webpackHotUpdate事件，如果不支持则直接刷新浏览器</p><p>在webpack/hot/dev-server.js会监听webpackHotUpdate事件<br>在check方法里会调用module.hot.check方法<br>HotModuleReplacement.runtime请求Manifest<br>它通过调用 JsonpMainTemplate.runtime的hotDownloadManifest方法<br>调用JsonpMainTemplate.runtime的hotDownloadUpdateChunk方法通过JSONP请求获取到最新的模块代码</p><p>补丁JS取回来后会调用JsonpMainTemplate.runtime.js的webpackHotUpdate方法<br>然后会调用HotModuleReplacement.runtime.js的hotAddUpdateChunk方法动态更新模块代码<br>然后调用hotApply方法进行热更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 打包系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《打包系列|工程化管理工具篇》</title>
      <link href="2021/05/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>2021/05/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>前端工程化离不开<code>npm</code>或者<code>Yarn</code> 这些管理工具。npm或Yarn 在工程项目中，除了负责依赖的安装和维护以外，还能通过 <code>npm scripts</code> 串联起各个职能部分，让独立的环节自动运转起来。另外在使用管理工具的时候会遇到一些问题如下:</p><ul><li><p>项目依赖出现问题时，删除大法好，即删除 node_modules 和 lockfiles，再重新 install，这样操作是否存在风险</p><blockquote><p>重新安装可能会改变依赖版本, 是有风险的<br>因为删除lock文件以后, 模块的安装顺序可能影响 node_modules 内的文件结构<br>insatll命令执行的时候，获取依赖包的顺序不一样，可能导致扁平化机制生成的依赖树不一样</p></blockquote></li><li><p>我们的应用依赖了公共库 A 和公共库 B，同时公共库 A 也依赖了公共库 B，那么公共库 B 会被多次安装或重复打包吗</p><blockquote><p>看版本范围是否在一个范围内，同一个版本范围，不会重复。</p></blockquote></li><li><p>一个项目中，既有人用 npm，也有人用 Yarn，这会引发什么问题</p><blockquote><p>lock文件不同，可能会存在冲突，导致最终安装版本不一致。</p></blockquote></li><li><p>我们是否应该提交 lockfiles 文件到项目仓库呢</p><blockquote><p>如果开发一个应用，建议把 package-lock.json 文件提交到代码版本仓库。这样可以保证项目组成员、运维部署成员或者 CI 系统，在执行 npm install 后，能得到完全一致的依赖安装内容。</p><p>如果你的目标是开发一个给外部使用的库，那就要谨慎考虑了，因为库项目一般是被其他项目依赖的，在<br>不使用 package-lock.json 的情况下，就可以复用主项目已经加载过的包，减少依赖重复和体积</p><p>因此，一个推荐的做法是：把 package-lock.json 一起提交到代码库中，不需要 ignore。但是执行 npm publish 命令，发布一个库的时候，它应该被忽略而不是直接发布出去</p></blockquote></li><li><p>为什么单一的 package.json 不能确定唯一的依赖树</p><blockquote><p>不同版本的 npm 的安装依赖策略和算法不同；</p><p>npm install 将根据 package.json 中的 semver-range version 更新依赖，某些依赖项自上次安装以来，可能已发布了新版本。</p></blockquote></li><li><p>为什么有时候可以离线安装一些包</p><blockquote><p>因为包管理工具的缓存机制</p></blockquote></li></ul><p>另外很多时候我们在配置package.json中除了<code>scripts</code>属性的配置，其他的配置也会有些陌生，npm和yarn的一些操作也不太懂.</p><h2 id="关于package-json"><a href="#关于package-json" class="headerlink" title="关于package.json"></a>关于package.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: &#x27;woyao_cli&#x27;,</span><br><span class="line">  <span class="comment">// 执行脚本命令</span></span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当不配置 homepage 属性，build 打包之后的文件资源应用路径默认是 /</span></span><br><span class="line">  <span class="comment">// 当你设置了 homepage 属性后, 打包后的资源路径就会加上 homepage 的地址</span></span><br><span class="line">  <span class="comment">// 相当于output的publicPath</span></span><br><span class="line">  homepage: &#x27;/&#x27;,</span><br><span class="line">  <span class="comment">// bin的作用，它是一个命令名和本地文件名的映射。</span></span><br><span class="line">  <span class="comment">// 在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin</span></span><br><span class="line">  <span class="comment">// 如果是本地安装，会链接到./node_modules/.bin/</span></span><br><span class="line">  <span class="comment">// 通俗点理解如果我们是全局安装我们就可以在全局命令行中执行bin指向的这个文件</span></span><br><span class="line">  <span class="comment">// 本地安装我们只能在在当前工程目录的命令行中执行bin指向的该文件。</span></span><br><span class="line">  <span class="comment">// 其实做的事情就是在node_modules/bin文件夹下加入一个命令名, 命令名会映射到我们bin指向的文件</span></span><br><span class="line">  <span class="comment">// 请确保你的bin指向的文件里面最开头写上 #!/usr/bin/env node</span></span><br><span class="line">  <span class="comment">// 这样才能保证该文件的执行环境是在node中，否则你还得这么写 node woyao_cli xxx</span></span><br><span class="line">  <span class="comment">// 确保环境以后你就可以这么写woyao_cli xxx</span></span><br><span class="line">  <span class="comment">// 命令名的配置如果是单一文件，默认就是package.json中的name字段</span></span><br><span class="line">  <span class="comment">// 当然也可以自己设置: &#123;&quot;bin&quot;: &#123;&quot;woyao_cli&quot;: &#x27;index.js&#x27;&#125;&#125;</span></span><br><span class="line">  <span class="comment">// 这样在别的机器中全局安装我们这个项目包的时候</span></span><br><span class="line">  bin: &#x27;index.js&#x27;,</span><br><span class="line">  <span class="comment">// 代码入口</span></span><br><span class="line">  <span class="comment">// 再写公共库的时候这个配置项很重要</span></span><br><span class="line">  <span class="comment">// 比如我们打包后的文件放在dist文件下，包名叫做instance</span></span><br><span class="line">  <span class="comment">// 别的业务项目要引用我们的包需要这样require(&#x27;instance/dist/inddex.js&#x27;)</span></span><br><span class="line">  <span class="comment">// 如果指定main:&#x27;dist/index.js&#x27;,那么就可以直接require(&#x27;instance&#x27;)了</span></span><br><span class="line">  main: &#x27;index.js&#x27;,</span><br><span class="line">  <span class="comment">// &quot;main&quot;: &quot;dist/index.cjs.js&quot;, // 打包出一份commonjs规范的bundle</span></span><br><span class="line">  <span class="comment">//  &quot;module&quot;: &quot;dist/index.esm.js&quot;, // 打包出一份tree shaking后的ESM规范的bundle</span></span><br><span class="line">  <span class="comment">// module 一般用于和main进行区分</span></span><br><span class="line">  module: &#x27;xxxx.js&#x27;,</span><br><span class="line">  <span class="comment">// 代码运行时所需要的依赖</span></span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;core-js&quot;: &quot;^3.6.5&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^3.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发依赖，就是那些只在开发过程中需要，而运行时不需要的依赖</span></span><br><span class="line">  <span class="comment">// 也就是说打包过程要用到的依赖，打包以后你就不再要用到了</span></span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;eslint&quot;: &quot;^6.7.2&quot;,</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^7.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 可选依赖，这种依赖即便安装失败，Yarn也会认为整个依赖安装过程是成功的</span></span><br><span class="line">  &quot;optionalDependences&quot;: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 同版本依赖</span></span><br><span class="line">  <span class="comment">// 如果你安装我，那么你最好也安装我对应的依赖。</span></span><br><span class="line">  <span class="comment">// 举个例子，假设 react-ui@1.2.2</span></span><br><span class="line">  <span class="comment">// 只提供一套基于 React 的 UI 组件库，</span></span><br><span class="line">  <span class="comment">// 它需要宿主环境提供指定的 React 版本来搭配使用</span></span><br><span class="line">  <span class="comment">// 另外在开发公共包的时候，配置同版本依赖</span></span><br><span class="line">  <span class="comment">// 可以解决核心依赖库被重复下载</span></span><br><span class="line">  <span class="comment">// 在有一个 helloWorld 工程,</span></span><br><span class="line">  <span class="comment">// 已经在其 package.json 的 dependencies 中声明了 packageA，</span></span><br><span class="line">  <span class="comment">// 有两个插件 plugin1 和 plugin2 他们也依赖 packageA</span></span><br><span class="line">  <span class="comment">// 如果在插件中使用 dependencies 而不是 peerDependencies 来声明 packageA</span></span><br><span class="line">  <span class="comment">// 那么 $ npm install 安装完 plugin1 和 plugin2 之后的依赖图是这样的：</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ├── helloWorld</span></span><br><span class="line"><span class="comment">    │   └── node_modules</span></span><br><span class="line"><span class="comment">    │       ├── packageA</span></span><br><span class="line"><span class="comment">    │       ├── plugin1</span></span><br><span class="line"><span class="comment">    │       │   └── nodule_modules</span></span><br><span class="line"><span class="comment">    │       │       └── packageA</span></span><br><span class="line"><span class="comment">    │       └── plugin2</span></span><br><span class="line"><span class="comment">    │       │   └── nodule_modules</span></span><br><span class="line"><span class="comment">    │       │       └── packageA</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 而 peerDependency 就可以避免类似的核心依赖库被重复下载的问题</span></span><br><span class="line">  &quot;peerDependencies&quot;: &#123;</span><br><span class="line">      &quot;classnames&quot;: &quot;^2.2.6&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 注意:</span></span><br><span class="line"><span class="comment">并不是只有在 dependencies 中的模块才会被一起打包，</span></span><br><span class="line"><span class="comment">而在 devDependencies 中的依赖一定不会被打包。</span></span><br><span class="line"><span class="comment">实际上，依赖是否被打包，完全取决于项目里是否被引入了该模块。</span></span><br><span class="line"><span class="comment">dependencies 和 devDependencies 在业务中更多的只是一个规范作用，</span></span><br><span class="line"><span class="comment">我们自己的应用项目中，使用 npm install 命令安装依赖时，</span></span><br><span class="line"><span class="comment">dependencies 和 devDependencies 内容都会被下载。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><h2 id="npm的安装机制"><a href="#npm的安装机制" class="headerlink" title="npm的安装机制"></a><strong>npm的安装机制</strong></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1e95cc2637e4212900e939d41d3c8b6~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>注意</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1. 这里的config配置(npm配置)是指&#96;.npmrc文件&#96;</span><br><span class="line">(项目级的 .npmrc 文件&gt; 用户级的 .npmrc 文件&gt; 全局级的</span><br><span class="line">.npmrc 文件 &gt; npm 内置的 .npmrc 文件)。</span><br><span class="line"></span><br><span class="line">2. 构建依赖树时，当前依赖项目不管其是直接依赖还是子依赖的依赖，</span><br><span class="line">都应该按照扁平化原则，优先将其放置在 node_modules 根目录.</span><br><span class="line">在这个过程中，遇到相同模块就判断已放置在依赖树中的模块版本是否符合新模块的版本范围，</span><br><span class="line">如果符合则跳过；不符合则在当前模块的 node_modules 下放置该模块</span><br><span class="line">3. 依赖关系:</span><br><span class="line">并不是所有的子依赖都有 dependencies 属性，</span><br><span class="line">只有子依赖的依赖和当前已安装在根目录的 node_modules 中的依赖冲突之后，</span><br><span class="line">才会有这个属性</span><br><span class="line"></span><br><span class="line"> &quot;@babel&#x2F;helper-annotate-as-pure&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;7.12.13&quot;,</span><br><span class="line">      &quot;resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;@babel&#x2F;helper-annotate-as-pure&#x2F;download&#x2F;@babel&#x2F;helper-annotate-as-pure-7.12.13.tgz&quot;,</span><br><span class="line">      &quot;integrity&quot;: &quot;sha1-D1jobfxLs7H819uAZXDhd9Q5tqs&#x3D;&quot;,</span><br><span class="line">      &quot;dev&quot;: true,</span><br><span class="line">      &quot;requires&quot;: &#123;</span><br><span class="line">        &quot;@babel&#x2F;types&quot;: &quot;^7.12.13&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;@babel&#x2F;generator&quot;: &#123;</span><br><span class="line">          &quot;version&quot;: &quot;7.2.0&quot;,</span><br><span class="line">          &quot;resolved&quot;: &quot;http:&#x2F;&#x2F;www.npm.com&#x2F;@babel%2fgenerator&#x2F;-&#x2F;generator-7.2.0.tgz&quot;,</span><br><span class="line">          &quot;integrity&quot;: &quot;sha1-6vOCH6AwHZ1K74jmPUvMGbc7oWw&#x3D;&quot;,</span><br><span class="line">          &quot;dev&quot;: true,</span><br><span class="line">          &quot;requires&quot;: &#123;</span><br><span class="line">            &quot;@babel&#x2F;types&quot;: &quot;^7.2.0&quot;,</span><br><span class="line">            &quot;jsesc&quot;: &quot;^2.5.1&quot;,</span><br><span class="line">            &quot;lodash&quot;: &quot;^4.17.10&quot;,</span><br><span class="line">            &quot;source-map&quot;: &quot;^0.5.0&quot;,</span><br><span class="line">            &quot;trim-right&quot;: &quot;^1.0.1&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="npm缓存机制"><a href="#npm缓存机制" class="headerlink" title="npm缓存机制"></a><strong>npm缓存机制</strong></h2><p>对于一个依赖包的同一版本进行本地化缓存，是当代依赖包管理工具的一个常见设计。<br>通过<code>npm config get cache</code>可以获得npm缓存配置的路径, 比如:<strong><code>/Users/chen/.npm</code></strong><br>切换到缓存配置的路径以后，可以看到一个<code>_cacache文件夹</code>。该文件夹存放依赖包的缓存。<br>当然你可以通过<code> npm cache clean --force</code>清空缓存。打开_cacache文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cache文件夹下的目录文件:</span><br><span class="line">  - content-v2</span><br><span class="line">    存放二进制文件，将二进制文件的扩展名改为.tgz，然后进行解压，得到的结果其实就是我们的 npm 包资源</span><br><span class="line">  - index-v5</span><br><span class="line">    缓存记录</span><br><span class="line">  - tmp</span><br></pre></td></tr></table></figure><p><strong><em>Npm v5+ 缓存策略如下</em></strong>:</p><p>当 npm install 执行时，通过pacote把相应的包解压在对应的 node_modules 下面。npm 在下载依赖时，先下载到缓存当中，再解压到项目 node_modules 下。pacote 依赖npm-registry-fetch来下载包，npm-registry-fetch 可以通过设置 cache 属性，在给定的路径下根据IETF RFC 7234生成缓存数据。</p><p>接着，在每次安装资源时，根据 package-lock.json 中存储的 integrity、version、name 信息生成一个唯一的 key，这个 key 能够对应到 index-v5 目录下的缓存记录。如果发现有缓存资源，就会找到 tar 包的 hash，根据 hash 再去找缓存的 tar 包，并再次通过pacote把对应的二进制文件解压到相应的项目 node_modules 下面，省去了网络下载资源的开销。</p><p><strong><em>npm v5 版本之前</em></strong>:</p><p>每个缓存的模块在 ~/.npm 文件夹中以模块名的形式直接存储，储存结构是：{cache}/{name}/{version}。</p><h2 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a><strong>npm常用命令</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 shell 脚本输出一个初始化的 package.json 文件</span></span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装所有依赖包</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包安装</span></span><br><span class="line">npm install [package] --save-dev</span><br><span class="line">npm install [package] --save</span><br><span class="line">npm install [package] -g</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重建</span></span><br><span class="line">npm rebuild</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除包</span></span><br><span class="line">npm uninstall [package]</span><br><span class="line">npm uninstall --save [package]</span><br><span class="line">npm uninstall --save-dev [package]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看npm镜像</span></span><br><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置npm的镜像</span></span><br><span class="line"><span class="comment">// ---官方镜像</span></span><br><span class="line">npm config set registry https:<span class="comment">//registry.npmjs.org/</span></span><br><span class="line"><span class="comment">// ---淘宝镜像</span></span><br><span class="line">npm config set registry https:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录</span></span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布个人项目到npm上</span></span><br><span class="line"><span class="comment">// 第一次发布时，需要创建用户：npm adduser</span></span><br><span class="line">npm publish</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建用户</span></span><br><span class="line">npm adduse</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本</span></span><br><span class="line">npm update &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看缓存存放路径</span></span><br><span class="line">npm config get cache</span><br><span class="line"><span class="comment">// 可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</span></span><br><span class="line">npm cache clear --force</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以撤销发布自己发布过的某个版本代码。</span></span><br><span class="line">npm unpublish &lt;package&gt;@&lt;version&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除整个版本</span></span><br><span class="line">npm unpublish &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建立软链接(这个很重要)</span></span><br><span class="line"><span class="comment"> 为目标npm模块创建软链接,</span></span><br><span class="line"><span class="comment"> 将其链接到全局node模块安装路径 &quot;/xxx/lib/node_modules/&quot; 中</span></span><br><span class="line"><span class="comment"> 为目标npm模块的可执行bin文件创建软链接，</span></span><br><span class="line"><span class="comment"> 将其链接到全局node命令安装路径 &quot;/usr/local/bin/&quot; 中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">npm link</span><br></pre></td></tr></table></figure><blockquote><p><strong>关于<code>npm link</code> 这个命令：</strong></p><p>在开发公共包的时候，比如我开发了一个组件库, 现在组件库内新增了一个组件<Swiper/>,但我不能发布新版本，因为不确定这个组件的正确性。那我如何确定这个新增的组件能够在我的业务项目中使用呢？<a href="https://github.com/ChenWoyao/baleExample/tree/master/npmLink">使用教程的代码参考</a></p><ol><li>比较笨的办法就是打包现在的组件库，然后把打包的组件库放入node_modules里面，然后在验证</li><li>正确的做法是通过npm link. (假设我们之前的组件库打包后叫做 <code>npm-package-ui</code>)<ol><li>首先我们进入我们的组件库，执行npm link(这样 npm link 通过链接目录和可执行文件，实现 npm 包命令的全局可执行)。</li><li>然后进入本地的业务项目，执行 <code>npm link npm-package-ui</code>. 它就会去 /usr/local/lib/node_modules/ 这个路径下寻找是否有这个包，如果有就建立软链接.</li><li>这样我本地的业务项目就可以和本地最新的组件库建立软链接了，然后启动程序，我就可以用新组件<Swiper/>了。不过每次npm-package-ui的更新，都需要本地业务项目重新<br>启动，才可以得到新的变化。</li><li>最后测试结束以后， <code>npm unlink</code>取消关联，然后测试没问题就可以发布新版本的组件库包了。</li></ol></li></ol></blockquote><h2 id="npx的用法"><a href="#npx的用法" class="headerlink" title="npx的用法"></a><strong>npx的用法</strong></h2><p><a href="http://www.ruanyifeng.com/blog/2019/02/npx.html">《阮一峰npx教程》</a></p><ul><li>npx 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在，而不需要再在 package.json 中定义相关的 script。通过<code>npm install -g npx</code>命令来安装npx (需要npm V5.2+)</li></ul><p>比如之前需要这样才能执行eslint</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;eslint:init&quot;: &quot;./node_modules/.bin/eslint --init&quot;,</span><br><span class="line">    &quot;eslint:run&quot;: &quot;./node_modules/.bin/eslint yourfile.js&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>使用npx以后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx eslint --init</span><br><span class="line">npx eslint yourfile.js</span><br></pre></td></tr></table></figure><ul><li>另外除了调用项目内部模块，npx 还能避免全局安装的模块。比如，<code>create-react-app</code>这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; npx 将create-react-app下载到一个临时目录，使用以后再删除。</span><br><span class="line">&#x2F;&#x2F; 再次执行下面的命令，会重新下载create-react-app</span><br><span class="line">npx create-react-app my-react-app</span><br></pre></td></tr></table></figure><ul><li>切换node版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nvm 的命令如下</span><br><span class="line">nvm install 14.5.0</span><br><span class="line">nvm use 14.5.0</span><br><span class="line">&#x2F;&#x2F; npx 的命令如下</span><br><span class="line">npx node@14.5.0 -v</span><br></pre></td></tr></table></figure><h2 id="使用nvm-管理-node版本"><a href="#使用nvm-管理-node版本" class="headerlink" title="使用nvm 管理 node版本"></a>使用nvm 管理 node版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装nvm</span><br><span class="line">npm install -g nvm</span><br><span class="line">&#x2F;&#x2F; 下载具体的node包</span><br><span class="line">nvm install 14.5.0</span><br><span class="line">&#x2F;&#x2F; 切换到某个node版本包</span><br><span class="line">nvm use 14.5.0</span><br><span class="line">&#x2F;&#x2F; 查看当前所有的Node包的版本</span><br><span class="line">nvm list</span><br></pre></td></tr></table></figure><h2 id="使用nrm切换npm-源"><a href="#使用nrm切换npm-源" class="headerlink" title="使用nrm切换npm 源"></a>使用nrm切换npm 源</h2><p>有时候我们可能觉得切换比较麻烦，老是要<code>npm config set registry 某npm镜像url </code>. 这时候可以使用nrm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局安装nrm</span><br><span class="line">npm install -g nrm</span><br><span class="line">&#x2F;&#x2F; 列举可以选的源</span><br><span class="line">nrm ls</span><br><span class="line">&#x2F;&#x2F; 切换到想要的源</span><br><span class="line">nrm use taobao</span><br><span class="line">&#x2F;&#x2F; 增加源</span><br><span class="line">nrm add &lt;registry&gt; &lt;url&gt; [home]</span><br><span class="line">&#x2F;&#x2F; 删除源</span><br><span class="line">nrm del &lt;registry&gt;</span><br><span class="line">&#x2F;&#x2F; 测试某源的速度</span><br><span class="line">nrm test taobao</span><br></pre></td></tr></table></figure><h1 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h1><p>Yarn 是一个由 Facebook、Google、Exponent 和 Tilde 构建的新的 JavaScript 包管理器<br>下面是yarn包管理器的优点(个人倾向于使用npm):</p><ul><li><p><strong>确定性</strong>：通过 yarn.lock 等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装。（在 npm v5 之前，没有 package-lock.json 机制，只有默认并不会使用的npm-shrinkwrap.json。）</p></li><li><p>__采用模块扁平安装模式__：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（npm 目前也有相同的优化）。Yarn 在安装依赖时会自动执行 dedupe 命令</p></li><li><p>__网络性能更好__：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制。</p></li><li><p><strong>采用缓存机制</strong>: 实现了离线模式（npm 目前也有类似实现）。</p></li></ul><h2 id="关于yarn的锁文件yarn-lock"><a href="#关于yarn的锁文件yarn-lock" class="headerlink" title="关于yarn的锁文件yarn.lock"></a>关于yarn的锁文件yarn.lock</h2><p>区别于package-lock.json, yarn.lock 并没有使用 JSON 格式，而是采用了一种自定义的标记格式<br>另外和npm lock文件相比， yarn.lock 中子依赖的版本号不是固定版本。这就说明单独一个 yarn.lock<br>确定不了 node_modules 目录结构，还需要和 package.json 文件进行配合。</p><p>不管是 npm 还是 Yarn，说到底它们都是一个包管理工具，在项目中如果想进行 npm/Yarn 切换，并不是一件麻烦的事情。甚至还有一个专门的 synp 工具，它可以将 yarn.lock 转换为 package-lock.json</p><h2 id="yarn的安装机制"><a href="#yarn的安装机制" class="headerlink" title="yarn的安装机制"></a>yarn的安装机制</h2><p>安装过程:  检测（checking）→ 解析包（Resolving Packages） → 获取包（Fetching Packages）→ 链接包（Linking Packages）→ 构建包（Building Packages）</p><h3 id="检测包"><a href="#检测包" class="headerlink" title="检测包"></a>检测包</h3><p>这一步主要是检测项目中是否存在一些 npm 相关文件，比如 package-lock.json 等。如果有，会提示用户注意：这些文件的存在可能会导致冲突。在这一步骤中，也会检查系统 OS、CPU 等信息</p><h3 id="解析包"><a href="#解析包" class="headerlink" title="解析包"></a>解析包</h3><p>这一步会解析依赖树中每一个包的版本信息:</p><p>首先获取当前项目中 package.json 定义的 dependencies、devDependencies、optionalDependencies 的内容，这属于首层依赖</p><p>接着采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析</p><p>对于没有解析过的包 A，首次尝试从 yarn.lock 中获取到版本信息，并标记为已解析<br>如果在 yarn.lock 中没有找到包 A，则向 Registry 发起请求获取满足版本范围的已知最高版本的包信息，获取后将当前包标记为已解析</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e05e1d8e768b4b85b3e72f9abdc1b0e8~tplv-k3u1fbpfcp-zoom-1.image" alt="yarn解析包"></p><h3 id="获取包"><a href="#获取包" class="headerlink" title="获取包"></a>获取包</h3><p>这一步我们首先需要检查缓存中是否存在当前的依赖包，同时将缓存中不存在的依赖包下载到缓存目录<br>如何判断缓存中是否存在当前的依赖包？Yarn 会根据 cacheFolder+slug+node_modules+pkg.name 生成一个 path，判断系统中是否存在该 path，如果存在证明已经有缓存，不用重新下载。这个 path 也就是依赖包缓存的具体路径</p><p>对于没有命中缓存的包，Yarn 会维护一个 fetch 队列，按照规则进行网络请求。如果下载包地址是一个 file 协议，或者是相对路径，就说明其指向一个本地目录，此时调用 Fetch From Local 从离线缓存中获取包；否则调用 Fetch From External 获取包。最终获取结果使用 fs.createWriteStream 写入到缓存目录下<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/829905268ebc47b78543a7ab3be88b88~tplv-k3u1fbpfcp-zoom-1.image" alt="yarn获取包"></p><h3 id="链接包"><a href="#链接包" class="headerlink" title="链接包"></a>链接包</h3><p>将项目中的依赖复制到项目 node_modules 下，同时遵循扁平化原则。在复制依赖前，Yarn 会先解析 peerDependencies (同伴依赖，它用来告知宿主环境需要什么依赖以及依赖的版本范围 )，如果找不到符合 peerDependencies 的包，则进行 warning 提示，并最终拷贝依赖到项目中<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a69ab08ecc0340808b063b503033992d~tplv-k3u1fbpfcp-zoom-1.image" alt="yarn链接包"></p><h3 id="构建包"><a href="#构建包" class="headerlink" title="构建包"></a>构建包</h3><p>如果依赖包中存在二进制包需要进行编译，会在这一步进行</p><h2 id="yarn的常用命令"><a href="#yarn的常用命令" class="headerlink" title="yarn的常用命令"></a>yarn的常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装所有依赖包</span><br><span class="line">yarn install</span><br><span class="line">&#x2F;&#x2F; 添加某一个依赖包</span><br><span class="line">yarn add [package] -dev</span><br><span class="line">yarn add [package]</span><br><span class="line">yarn global add [package]</span><br><span class="line">&#x2F;&#x2F; 重建</span><br><span class="line">yarn install --force</span><br><span class="line">&#x2F;&#x2F; 删除包</span><br><span class="line">yarn remove [package]</span><br><span class="line">yarn global remove [package]</span><br><span class="line">&#x2F;&#x2F; 查看缓存目录</span><br><span class="line">yarn cache dir</span><br><span class="line">&#x2F;&#x2F; 清除缓存</span><br><span class="line">yarn cache clean</span><br></pre></td></tr></table></figure><h1 id="关于包管理工具的扁平化机制"><a href="#关于包管理工具的扁平化机制" class="headerlink" title="关于包管理工具的扁平化机制"></a>关于包管理工具的扁平化机制</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef3eaac17ef1426e9e3603a716d697b9~tplv-k3u1fbpfcp-zoom-1.image" alt="包管理工具的扁平化机制"></p>]]></content>
      
      
      <categories>
          
          <category> 打包系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《打包系列|序章》</title>
      <link href="2021/05/22/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97%E5%BA%8F%E7%AB%A0/"/>
      <url>2021/05/22/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97/%E6%89%93%E5%8C%85%E7%B3%BB%E5%88%97%E5%BA%8F%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前端史"><a href="#前端史" class="headerlink" title="前端史"></a>前端史</h1><p>前端的发展迅速，新技术层出不穷，不跟上步伐，你将成为前浪，被时代所淘汰。<br>依稀记得最开始写MVC框架的快感，简称web1时代。</p><blockquote><p>那时候问得最多的不过是什么是mvc, 路由控制器监听到路径发生变化处理数据<br>更新到数据库，返回携带html文本的报文。页面的交互用ajax,无需刷新页面就可以更新数据，ui用bootstrap响应式布局，还要用jquery写一堆的dom操作,事件处理。聊聊弊端吧:</p><ol><li>ajax请求没有记住事务状态的能力，不向单页面，你弹出一个弹框或者滚动到某处以后，从别的路由回到当前路由，这些状态都会重置。因为路由<br> 发生变化，服务端下发新的响应浏览器解析并渲染，状态全部重置</li><li>jquery是用起来爽，但是一堆的js dom操作,事件操作时很头疼的</li><li>数据交互频繁，一个模块的数据变动，导致很多模板要更新，都得进行很多的人为视图处理操作</li></ol></blockquote><p>到后来的单页面机制的出现，前端出现了mvvm架构，简称web2时代.<br>这个时候前后端开始了分离，程序员的分工更加明显，一个专注于数据的处理，一个专注于用户的交互。这让人的工作量减少很多，而且可以专注于一方面的发展。不管是vue的观察订阅者模式加上Object.defineProperty的代理劫持。还是react的fiber diff render。视图变化的处理工作大大减少，基本上很多dom操作,文本操作都由react.js或者vue.js处理了。jquery也慢慢退出了舞台。另外都有各自的路由处理vue-router,react-router-dom.同样是更新数据不刷新页面但是有了记录页面状态的能力。但是如果单纯的vue.js或者react.js可行吗？比如下面的代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;./index.css&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;./header.css&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;./content.css&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;./slider.css&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;./footer.css&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;./common.css&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./react.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./reactDOM.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&#x27;Header.js&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Content <span class="keyword">from</span> <span class="string">&#x27;Content.js&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Slider <span class="keyword">from</span> <span class="string">&#x27;Slider.js&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">&#x27;Footer.js&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    Class App <span class="keyword">extends</span> React.Component &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> (</span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">Conetent</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">Slider</span>/&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">article</span>/&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>))</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显然如果这个页面内容很多的话，比如会有如下缺点:</p><blockquote><ul><li>css 命名，你得确保这么多内容里面不出现重复的名字,造成样式混乱</li><li>我只能用es6语法写，先不说浏览器支不支持，我想用CommJs或者Amd语法都是不行的(个人认为就应该语法统一，统一规范写EMS)</li><li>js中有句话说的好一切都是对象，那么可不可以说html, css一切都是js呢，我们都知道<br>ast抽象语法树，万语皆可以翻译</li><li>自己可能写了很多无用代码，但是编译的时候都被执行</li><li>我想使用scss, less怎么办</li><li>我的项目上线以后，我希望把css,js压缩，减小包的体积</li><li>等等</li></ul></blockquote><p>于是呢就有了打包工具，市面上常用的有webpack, rollup, gulp 等。虽说打包工具好<br>但是也不得不说说缺点，如果一个应用体积很大，首次打包编译和构建操作时间特别长，然后你修改代码热更新也慢的慌。于是就用了vite的出现，虽说生态不够完善，但是少不了期待的眼神。vite与打包工具的区别:<br><img src="http://121.5.231.10:3000/bale/vite.png" alt="vite"></p><p><img src="http://121.5.231.10:3000/bale/vite2.png" alt="vite1"></p><p>vite是一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 Rollup 打包。</p><p>Vite 在开发环境下并没有打包和构建过程</p><p>开发者在代码中写到的 ESM 导入语法会直接发送给服务器，而服务器也直接将 ESM 模块内容运行处理后，下发给浏览器。接着，现代浏览器通过解析 script module，对每一个 import 到的模块进行 HTTP 请求，服务器继续对这些 HTTP 请求进行处理并响应。</p><p>其实本就应该这样，在开发环境中，代码只需要进行语法翻译不需要打包(根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件)。相应的模块变动的时候，就应该是重新请求响应模块的import请求即可。</p><blockquote><p>Vite Server 所有逻辑基本都依赖中间件实现。这些中间件，拦截请求之后，完成了如下内容：</p><p>处理 ESM 语法，比如将业务代码中的 import 第三方依赖路径转为浏览器可识别的依赖路径(绝对路径就在npm包里面找，相对路径就在项目中找)</p><p>对 .ts、.vue 等文件进行即时编译；</p><p>对 Sass/Less 的需要预编译的模块进行编译；</p><p>和浏览器端建立 socket 连接，实现 HMR。</p></blockquote><p>不过发展依旧没有停止，随着NodeJs的发展，前端工具链，工程化得以发展，前端<br>不再仅仅是csr(客户端渲染)，这种页面完全靠js渲染是不利于seo的，而且初始化数据的时候如果数据多首次渲染会很慢，于是有了ssr技术的出现，通过NodeJs实现一个网关，模块代码同构，在将react渲染成html片段前进行数据的初始化和css的处理以及数据的注水操作。使得搜索引擎访问页面的请求结果不再是一个空的div，而是有内容的html文本。另外数据的初始化已经在网关层实现，所以页面在浏览器首次<br>渲染的时候不需要再重新加载数据然后初始化最后才执行render了。虽说ssr好，但是也加大了前端的学习成本。<br>目前就有了NSR(边缘渲染)的策略：利用了 CDN 能力。ESR会在 CDN 上缓存页面的静态部分，这样在用户访问页面时，可以快速返回给用户静态内容，同时在 CDN 节点上也发起动态部分内容请求，在动态内容获取之后，利用流的方式，继续返回给用户</p>]]></content>
      
      
      <categories>
          
          <category> 打包系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript相关知识</title>
      <link href="2021/05/14/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/javascript%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>2021/05/14/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/javascript%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="关于this指向问题"><a href="#关于this指向问题" class="headerlink" title="关于this指向问题"></a>关于this指向问题</h1><ul><li>默认是全局对象, 严格模式下为 undefined</li><li>普通函数的 this 在调用时确定<ul><li>谁调用, 谁就是this.</li><li>作为对象方法, 原型链方法, 对象的 getter/setter 方法时也是如此.</li><li>使用 bind call apply 可绑定 this. 替代调用时确定的规则.</li></ul></li><li>箭头函数的this继承自作用域链上层</li><li>new 构造函数, this为正在构造的对象</li><li>dom 事件处理函数, this为触发事件的元素.</li><li>on-event 内联函数, this 为绑定的元素.</li></ul><h2 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">global</span>.a = <span class="string">&#x27;global&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">    a: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        log(<span class="string">&#x27;this.a&#x27;</span>, <span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> that = test.b</span><br><span class="line">test.b() <span class="comment">// test 谁调用它this指向谁</span></span><br><span class="line">that.apply(test) <span class="comment">// &#x27;test&#x27; 绑定this</span></span><br><span class="line">that() <span class="comment">// global 默认全局</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line">        .appendChild(btn.innerText = <span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// dom 事件处理函数, this为触发事件的元素.</span></span><br><span class="line">    log(<span class="string">&#x27;this test 5&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">btn.click()</span><br></pre></td></tr></table></figure><h1 id="关于屏幕的适配"><a href="#关于屏幕的适配" class="headerlink" title="关于屏幕的适配"></a>关于屏幕的适配</h1><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@meida</span> screen <span class="keyword">and</span> (<span class="attribute">max-wdith</span>: <span class="number">360px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态修改-rem"><a href="#动态修改-rem" class="headerlink" title="动态修改(rem)"></a>动态修改(rem)</h2><p>在国内一般都是用的rem规范, 默认是1rem指根元素fontSize的值. 国外用的一般em, em是指父元素的fontSize.<br>当然也有用vm, vh的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setBaseFont</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> htmlWidth = <span class="built_in">document</span>.documentElement.clientWidth  || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">    <span class="keyword">let</span> htmlDom = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;html);</span></span><br><span class="line"><span class="string">    // (htmlWidth / 375) 是默认以iphone6机型的屏幕尺寸为基准</span></span><br><span class="line"><span class="string">    // 一般业内的准则是设置1rem = 屏幕尺寸 / 10</span></span><br><span class="line"><span class="string">    // 现在是以750尺寸的iphone6机型为准, 那么1rem = 75</span></span><br><span class="line"><span class="string">    htmlDom.style.fontSize = (htmlWidth / 375) * 75 + &#x27;</span>px<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">window.addEventListener(&#x27;</span>resize<span class="string">&#x27;, setBaseFont)</span></span><br><span class="line"><span class="string">window.addEventListener(&#x27;</span>pageshow<span class="string">&#x27;, setBaseFont)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">setBaseFont()</span></span><br></pre></td></tr></table></figure><p>然后有两中办法使用，一种是用css把所有的px变成rem。 另一种是插件在vscode中下载px2rem插件自动转成rem<br>当然如果是一个模块化工程中，可以通过设置webpack引用的<code>postcss-plugin-px2rem</code>插件来解决</p><ul><li>通过使用css<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@function</span> px2rem(<span class="variable">$px</span>) &#123;</span><br><span class="line">    <span class="variable">$rem</span>: <span class="number">37.5</span>;</span><br><span class="line">    <span class="keyword">@return</span> (<span class="variable">$px</span> / <span class="variable">$rem</span>) + rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过使用webpack<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    loader: <span class="built_in">require</span>.resolve(<span class="string">&quot;postcss-loader&quot;</span>),</span><br><span class="line">    options: &#123;</span><br><span class="line">        postcssOptions: &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&quot;postcss-preset-env&quot;</span>)(&#123;</span><br><span class="line">                    autoprefixer: &#123;</span><br><span class="line">                        overrideBrowderslist: <span class="string">&quot;andoroid &gt;= 4.3&quot;</span>,</span><br><span class="line">                    &#125;, <span class="comment">// 添加webkit, mozilla前缀</span></span><br><span class="line">                    stage: <span class="number">3</span>,</span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&quot;postcss-plugin-px2rem&quot;</span>)(&#123;</span><br><span class="line">                    rootValue: <span class="number">75</span>, <span class="comment">// 根据index.html的doucment fontsize设置</span></span><br><span class="line">                    minPixelValue: <span class="number">2</span>, <span class="comment">// 设置要替换的最小像素值</span></span><br><span class="line">                &#125;),</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><ul><li>原生javascript自带的Event类或者CustomEvent实现</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eve = <span class="keyword">new</span> Event(<span class="string">&#x27;custom&#x27;</span>)</span><br><span class="line">element.addEventListener(<span class="string">&#x27;custom&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;custom&quot;</span>) &#125;</span><br><span class="line">element.dispatchEvent(eve)</span><br></pre></td></tr></table></figure><ul><li>自己编写EventEmitter类实现</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span>() </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    (<span class="built_in">this</span>.events[event] || (<span class="built_in">this</span>.events[event] = [])).push(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">event, ...args</span>)</span> &#123;</span><br><span class="line">    (<span class="built_in">this</span>.events[name] || []).forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(...args))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wrap = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      callback.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      <span class="built_in">this</span>.off(event, wrap)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">this</span>.on(event, wrap)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events[name]</span><br><span class="line">        &amp;&amp; <span class="built_in">this</span>.events[event].splice(<span class="built_in">this</span>.events[event].indexof(callback) &gt;&gt;&gt; <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="各种http请求方式"><a href="#各种http请求方式" class="headerlink" title="各种http请求方式"></a>各种http请求方式</h1><ul><li><p>fetch的方式请求数据,</p><ul><li>fetch 不支持同步请求</li><li>fetch 不支持取消一个请求</li><li>fetch 无法查看请求的进度</li><li>fetch 只有遇到网络错误的时候才会reject这个promise请求<br>对于options、跨域等错误响应，Promise也是resolved状态，需要用response.ok来进行判断</li></ul><p>用法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;/api/user.json?id=2&#x27;</span>, &#123;</span><br><span class="line">  credentials: <span class="string">&#x27;include&#x27;</span> <span class="comment">// 携带cookie信息</span></span><br><span class="line">&#125;)</span><br><span class="line">   .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 返回的response是一个ReadableStream对象，需要调用对象的json方法进行格式化</span></span><br><span class="line">    <span class="keyword">if</span>(!response.ok) <span class="built_in">Promise</span>.reject(<span class="string">&#x27;cannot get data&#x27;</span>)</span><br><span class="line">   <span class="keyword">return</span> response.json();</span><br><span class="line">   &#125;)</span><br><span class="line">   .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(data);</span><br><span class="line">   &#125;)</span><br><span class="line"> .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure></li><li><p>ajax<br>ajax的readState有五种状态:</p><ul><li>0（未初始化）还没有调用open()方法</li><li>1（载入）。已经调用 open()方法，但尚未调用 send()方法</li><li>2（载入完成）send()方法执行完成，</li><li>3（交互）正在解析响应内容</li><li>4（完成）响应内容解析完成，可以在客户端调用了<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ajax = <span class="function"><span class="keyword">function</span> (<span class="params">method, path, headers, data, runCallBack</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(method, path, <span class="literal">true</span>)</span><br><span class="line">    <span class="built_in">Object</span>.entries(headers).forEach(<span class="function">(<span class="params">[header, value]</span>) =&gt;</span> &#123;</span><br><span class="line">        xhr.setRequestHeader(header, value)</span><br><span class="line">    &#125;)</span><br><span class="line">    xhr.onprogress = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">            runCallBack(xhr.response)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关于axios用法<br>axios 是一个流行的http请求库</p><ul><li>默认axios会把要发送的JavaScript对象数据序列化为JSON</li><li>支持请求拦截和响应拦截</li><li>axios.all 方法支持并发</li><li>axios.defaults 可以全局配置默认值</li><li>axios.CancelToken实例支持取消请求</li><li>可以查看请求进度<br>用法如下:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = axios.CancelToken.source()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseConfig = &#123;</span><br><span class="line">    timeout: <span class="string">&#x27;2000&#x27;</span>,</span><br><span class="line">    <span class="comment">// baseURL将自动加在url前面, 除非url是一个绝对URL。</span></span><br><span class="line">    baseURL: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line">    <span class="comment">// 上传处理进度事件</span></span><br><span class="line">    onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`上传进度<span class="subst">$&#123;progressEvent.loaded / progressEvent.total * <span class="number">100</span>&#125;</span>%`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 下载处理进度事件</span></span><br><span class="line">    onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`下载进度<span class="subst">$&#123;progressEvent.loaded / progressEvent.total * <span class="number">100</span>&#125;</span>%`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    cancelToken: source.token</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencode&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    url: <span class="string">&#x27;/user/all&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    withCredentials: <span class="literal">false</span>, <span class="comment">// 跨域请求时是否需要使用凭证(Cookie)</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        username: <span class="string">&#x27;woyao&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createRequest = <span class="function">(<span class="params">baseConfig, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用create创建一个axios实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(baseConfig)</span><br><span class="line"></span><br><span class="line">    instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在发送请求之前做些什么, 比如设置一个全局的loading组件显示</span></span><br><span class="line">        <span class="keyword">switch</span> (config.headers &amp;&amp; config.headers[<span class="string">&#x27;Content-Type&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>:</span><br><span class="line">                <span class="comment">// 这里也可以自己实现一个serialize函数</span></span><br><span class="line">                config.data = qs.stringify(config.data)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;multipart/form-data&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (data <span class="keyword">instanceof</span> HTMLFormElement) &#123;</span><br><span class="line">                    data = <span class="keyword">new</span> FormData(data)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">Promise</span>.reject(<span class="string">&#x27;data type is not valid of your ContentType defined&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;application/json&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">    instance.interceptors.response.use(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 对返回的数据进行拦截处理</span></span><br><span class="line">        <span class="comment">// 比如关闭一个全局的loading组件</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Do something with response error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createRequest(options).then().catch()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动取消请求</span></span><br><span class="line"><span class="comment">// source.cancel(&#x27;Operation canceled by the user.&#x27;)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="EventLoop事件机制"><a href="#EventLoop事件机制" class="headerlink" title="EventLoop事件机制"></a>EventLoop事件机制</h1><p>主线程(javaScript引擎线程)从”任务队列”中读取事件，这个过程是循环不断的, 所以整个的这种运行机制又称为Event Loop(事件循环)。</p><blockquote><p>讲白了这个机制是因为js单线程的原因。</p><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p><p>当事件触发线程执行的时候，此时cpu空闲，如果非要等事件触发线程从阻塞状态变成就绪状态肯定是不行的。我们应该要用并发机制。在一个时间片段中多个线程可以交替执行。尽可能的是cpu跑起来。EventLoop就是一种并发机制策略。</p></blockquote><blockquote><p>在任务队列中:<br>任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</p></blockquote><blockquote><p>EventLoop:</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件发生，找出事件对应的异步任务放入执行栈，主线程结束等待状态，开始执行。</li><li>主线程不断重复上面的第三步</li></ol><p>注意: IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程在读取”任务队列”就是读事件，从而知道哪些异步任务可以放入执行栈。另外如果一个事件被添加了定时器，只有到了规定的时间才能返回主线程</p></blockquote><blockquote><p>另外既然扯到了EventLoop就不得说说<code>Process.nextTick</code>、<code>setImmediate</code>、<code>setTimeout</code>、<code>requestAnimationFrame</code></p><ul><li>Process.nextTick(() =&gt; {})</li></ul><p> 在当前”执行栈”的尾部到下一次主线程读取任务队列之前触发回调函数<br> 也就是说当前执行栈的最后面执行，下一次执行栈之前执行<br> 另外不要写下面的死递归代码</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的执行栈会永远执行不完，而任务队列永远读不了</span></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  process.nextTick(foo);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>setImmediate<br>当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行<br>和setTimeout(() =&gt; {}, 0)很相似</p></li><li><p>setTimeout(() =&gt; {}, time)</p></li></ul><p> 过了time时间点以后, 下一次主线程读取任务队列时触发回调函数</p><ul><li>requestAnimationFrame</li></ul><p> 同setTimeout, 但是更流畅，一般用这个api实现函数节流</p></blockquote><p><img src="https://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png" alt="eventLoop"></p><h1 id="canvas的用法"><a href="#canvas的用法" class="headerlink" title="canvas的用法"></a>canvas的用法</h1><p>canvas怎么用具体还是看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">canvas的mdn文档</a>.  api比较多，功能很强大。比较流行写h5游戏，<br>处理视频, 图表生成。</p><ul><li>画布生成图像</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getQuerySelector(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">  <span class="keyword">let</span> imgUrl = canvas.toDataURL(<span class="string">&#x27;image/png&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">  image.src = imgUrl</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>图像变成灰度图</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filterColor = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> img = <span class="built_in">document</span>.images[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> imageData, data, i, len, average, red, green, blue, alpha</span><br><span class="line"></span><br><span class="line">  context.drawImage(img, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  imageData = context.getImageData(<span class="number">0</span>, <span class="number">0</span>, img.width, img.height)</span><br><span class="line">  data = imageData.data</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>, len = data.length; i &lt; len; i+=<span class="number">4</span>)&#123;</span><br><span class="line">    red = data[i]</span><br><span class="line">    green = data[i+<span class="number">1</span>]</span><br><span class="line">    blue = data[i+<span class="number">2</span>]</span><br><span class="line">    alpha = data[i+<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    average = <span class="built_in">Math</span>.floor((red + green + blue) / <span class="number">3</span>)</span><br><span class="line">    data[i] = data[i+<span class="number">1</span>] = data[i+<span class="number">2</span>] = average</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  imageData.data = data</span><br><span class="line">  context.putImageData(imageData, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承方式与原型链"><a href="#继承方式与原型链" class="headerlink" title="继承方式与原型链"></a>继承方式与原型链</h1><p>首先讲一下javascript中原型链的一些定义:</p><ul><li>每个对象都有 <code>__proto__</code> 属性，用于指向创建它的构造函数的原型对象</li><li>每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象<br>在默认情况下，所有的原型对象都会自动获得一个 constructor(构造函数) 属性</li><li>实例由构造函数初始化，可以继承创建它的构造函数的原型对象的方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</span><br><span class="line"><span class="comment">// Person构造函数 [Function: Person]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;my name:&#x27;</span>, <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> woyao = <span class="keyword">new</span> Person(<span class="string">&#x27;woyao&#x27;</span>)</span><br><span class="line"><span class="comment">// 实例由构造函数初始化，可以继承创建它的构造函数的原型对象的方法</span></span><br><span class="line">woyao.sayName()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得woyao这个实例的构造函数</span></span><br><span class="line">log(woyao.constructor) <span class="comment">// [Function: Person]</span></span><br><span class="line"><span class="comment">// 每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象</span></span><br><span class="line"><span class="comment">// 每个对象都有 `__proto__` 属性，用于指向创建它的构造函数的原型对象</span></span><br><span class="line">log(woyao.__proto__ === Person.prototype)</span><br></pre></td></tr></table></figure><p>了解了上面的定义之后讲讲在new一个构造函数生成一个实例的时候做了什么操作:</p><ul><li>创建一个对象，继承自一个原型对象，就是指定实例对象的<code>__proto__</code>为构造函数的原型对象</li><li>构造函数执行，this指定为这个实例对象</li><li>如果构造函数返回了一个对象，则该对象取代步骤一: 创建的对象</li><li>如果没有，就不替换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是构造函数</span></span><br><span class="line"><span class="keyword">const</span> New = <span class="function">(<span class="params">func, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(func.prototype)</span><br><span class="line">    <span class="keyword">let</span> result = func.call(obj, ...args)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> woyao = New(Person, <span class="string">&#x27;woyao&#x27;</span>)</span><br><span class="line">log(<span class="string">&#x27;woyao&#x27;</span>, woyao)</span><br><span class="line">woyao.sayName()</span><br></pre></td></tr></table></figure><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><ul><li>构造函数继承<br>缺点: 父类的原型对象的方法, 子类拿不到</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行父类的构造函数</span></span><br><span class="line">    Parent1.call(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;child1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原型链对象继承<br>缺点: 实例对象因为都是继承了父类的实例，通过对父类实例的修改<br>会对各个实例之间都产生影响</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;child1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Child2().__proto__ === Child2.prototype === new Parent2()</span></span><br><span class="line"><span class="comment">// 实例能够继承构造函数的原型对象上的属性和方法</span></span><br><span class="line">Child2.prototype = <span class="keyword">new</span> Parent2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child2()</span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> Child2()</span><br><span class="line">child1.arr.push(<span class="number">3</span>)</span><br><span class="line">log(child2.arr)</span><br></pre></td></tr></table></figure><ul><li>组合继承</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版:</span></span><br><span class="line"><span class="comment">// 缺点：父类构造函数执行了2次，第二次构造函数的执行取代了第一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent3.call(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;child3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Child3.prototype = <span class="keyword">new</span> Parent3()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二版:</span></span><br><span class="line"><span class="comment">// 缺点: 实例的constructor指向的是父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent4.call(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;child4&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child4.prototype = Parent4.prototype</span><br><span class="line"><span class="keyword">let</span> c4_1 = <span class="keyword">new</span> Child4()</span><br><span class="line">log(c4_1.constructor) <span class="comment">// Parent4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent5.call(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;child5&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Child5.prototype = <span class="built_in">Object</span>.create(Parent5.prototype)</span><br><span class="line">Child5.prototype.constructor = Child5</span><br></pre></td></tr></table></figure><h1 id="DOM常见操作"><a href="#DOM常见操作" class="headerlink" title="DOM常见操作"></a>DOM常见操作</h1><blockquote><p>节点查找</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e = <span class="function">(<span class="params">element, attribute</span>) =&gt;</span> element.querySelector(attribute)</span><br><span class="line"><span class="keyword">const</span> es = <span class="function">(<span class="params">element, attribute</span>) =&gt;</span> element.querySelectorAll(attribute)</span><br></pre></td></tr></table></figure><blockquote><p>节点创建</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文本节点</span></span><br><span class="line"><span class="built_in">document</span>.createTextNode(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建元素</span></span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">// 克隆节点</span></span><br><span class="line">e(<span class="string">&#x27;.test&#x27;</span>).cloneNode(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><blockquote><p>节点修改(添加，删除，替换)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">parent.appendChild(child)</span><br><span class="line">parentNode.insertBefore(newNode, refNode)</span><br><span class="line"><span class="comment">// insertAdjacentHTML的第一个参数用法如下:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;!-- beforebegin 作为最近的相邻兄弟节点--&gt;</span></span><br><span class="line"><span class="comment">&lt;p class=&quot;block&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;!-- afterbegin --&gt;</span></span><br><span class="line"><span class="comment">  foo</span></span><br><span class="line"><span class="comment">  &lt;!-- beforeend 作为直接子元素中的最后一个--&gt;</span></span><br><span class="line"><span class="comment">&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- afterend --&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">el.insertAdjacentHTML(<span class="string">&#x27;beforeend&#x27;</span>, htmlString)</span><br><span class="line">targetElement.insertAdjacentElement(position, element)</span><br><span class="line"><span class="keyword">let</span> deletedChild = parent.removeChild(node);</span><br><span class="line">parent.replaceChild(newChild, oldChild)</span><br></pre></td></tr></table></figure><blockquote><p>节点属性</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(name, value)</span><br><span class="line"><span class="keyword">let</span> value = element.getAttribute(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> result = element.hasAttribute(name)</span><br><span class="line">e(<span class="string">&#x27;#user&#x27;</span>).dataset.user</span><br></pre></td></tr></table></figure><blockquote><p>节点关系</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">parentNode ：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment；</span><br><span class="line"></span><br><span class="line">parentElement ：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null；</span><br><span class="line"></span><br><span class="line">children ：返回一个实时的 HTMLCollection ，子节点都是Element，IE9以下浏览器不支持；</span><br><span class="line"></span><br><span class="line">childNodes ：返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；</span><br><span class="line"></span><br><span class="line">firstChild ：返回第一个子节点，不存在返回null，与之相对应的还有一个 firstElementChild ；</span><br><span class="line"></span><br><span class="line">lastChild ：返回最后一个子节点，不存在返回null，与之相对应的还有一个 lastElementChild ；</span><br><span class="line"></span><br><span class="line">previousSibling ：节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。</span><br><span class="line"></span><br><span class="line">nextSibling ：节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。</span><br><span class="line"></span><br><span class="line">previousElementSibling ：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。</span><br><span class="line"></span><br><span class="line">nextElementSibling ：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</span><br></pre></td></tr></table></figure><blockquote><p>样式操作</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elem.style.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">elem.style.setProperty(<span class="string">&#x27;font-size&#x27;</span>, <span class="string">&#x27;16px&#x27;</span>);</span><br><span class="line">elem.style.removeProperty(<span class="string">&#x27;color&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.classList.remove(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">div.classList.add(<span class="string">&quot;anotherclass&quot;</span>);</span><br><span class="line">div.classList.toggle(<span class="string">&quot;visible&quot;</span>);</span><br><span class="line">div.classList.replace(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> style = <span class="built_in">window</span>.getComputedStyle(element[, pseudoElt]);</span><br></pre></td></tr></table></figure><h2 id="jquery常用api"><a href="#jquery常用api" class="headerlink" title="jquery常用api"></a>jquery常用api</h2><ul><li><p>选择器</p><ol><li><p>普通选择器</p></li><li><p>find</p></li><li><p>siblings</p></li><li><p>closest, parent</p></li></ol></li><li><p>dom 操作</p><ol><li><p>append</p></li><li><p>remove</p></li><li><p>empty</p></li><li><p>show, hide, toggle</p></li></ol></li><li><p>class 操作</p><ol><li><p>addClass removeClass</p></li><li><p>toggleClass</p></li></ol></li><li><p>属性、特性操作</p><ol><li><p>attr, prop, data ,  prop 用于 true false 这样的布尔值属性</p></li><li><p>removeAttr</p></li></ol></li><li><p>取值</p><ol><li><p>val</p></li><li><p>text</p></li><li><p>html</p></li></ol></li></ul><h1 id="reflect-proxy-Symbol的用法"><a href="#reflect-proxy-Symbol的用法" class="headerlink" title="reflect, proxy, Symbol的用法"></a>reflect, proxy, Symbol的用法</h1><ul><li><p><u>==<em><strong>Proxy</strong></em>==</u> 为其他对象提供一种代理以控制对这个对象的询问<br>大白话就是你要做的事情我给你来做，如果事情我能做的话, 这样事情就可以按照我想要的意愿发生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实也就是个代理模式罢了, es6创建了一个Proxy类</span></span><br><span class="line"><span class="comment">// 对代理模式不懂可以看看我的设计模式文章(https://juejin.cn/post/6960665002449731598)</span></span><br><span class="line"><span class="comment">// 给target对象提供一个代理，通过handler对target做操作</span></span><br><span class="line"><span class="comment">// 大白话就是你要做的事情我给你来做，如果事情我能做的话, 这样事情就可以按照我想要的意愿发生</span></span><br><span class="line"><span class="comment">// Proxy(target, handler)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">es6 实现的Proxy代理类中定义了下面常用的劫持方法:</span></span><br><span class="line"><span class="comment">1. apply(target, thisArgument, ...args):   在代理对象调用的时候劫持</span></span><br><span class="line"><span class="comment">2. construct(target, ...args)： new 操作的时候进行劫持</span></span><br><span class="line"><span class="comment">3. defineProperty(target, prop, attributes)： Object.defineProperty的时候劫持</span></span><br><span class="line"><span class="comment">4. get(target, prop, receiver): 获取属性值的时候劫持</span></span><br><span class="line"><span class="comment">5. has(target, prop): in 操作的时候劫持</span></span><br><span class="line"><span class="comment">6. set(target, prop, value, receiver): 设置属性的时候劫持</span></span><br><span class="line"><span class="comment">7. ownKeys(target): Object.getOwnPropertyNames和Object.geetOwnPropertySymbols调用劫持</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  type: <span class="string">&quot;human&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 我想要获取属性的时候结果是如下的</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&quot;type&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;pig&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return Reflect.get(target, prop, receiver)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 你说他的名字是xxx, 我说他是个xxx</span></span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">      target.name = <span class="string">&quot;万恶的资产阶级&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line"><span class="comment">// 事情按照我想要的情况发生了</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.type) <span class="comment">// pig</span></span><br><span class="line">proxy.name = <span class="string">&#x27;某公司&#x27;</span></span><br><span class="line">log(proxy.name)</span><br></pre></td></tr></table></figure></li><li><p><u>==<em><strong>reflect</strong></em>==</u> 是一个内置的对象，它提供拦截 JavaScript 操作的方法<br>虽然和Proxy一样都是代理拦截。但是reflect不改变事情发生的结果<br>大白话就是你要做的事情我给你来做，如果事情我能做的话，我就帮你做了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实reflect这个对象主要是用来配合Proxy这个构造对象来用的</span></span><br><span class="line"><span class="comment">// 在Proxy的handler中所有的劫持方法, reflect都有</span></span><br><span class="line"><span class="comment">// 一件事情本来是什么样的我可以通过reflect调用来知道</span></span><br><span class="line"><span class="comment">// 大白话就是你要做的事情我给你来做，如果事情我能做的话，我就帮你做了</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 我想要获取属性的时候结果是如下的</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&quot;type&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;pig&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果prop不是type的话，属性值原本是啥样就是啥样</span></span><br><span class="line">    <span class="comment">// return Reflect.get(target, prop, receiver)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> duck = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Maurice&#x27;</span>,</span><br><span class="line">  color: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Quaaaack! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;color&#x27; in duck</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(duck, <span class="string">&#x27;color&#x27;</span>)</span><br><span class="line"><span class="comment">// Object.getOwnPropertyNames(duck)</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(duck)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><u>==<em><strong>Symbol</strong></em>==</u> 生成一个全局唯一的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>)]:<span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>)]:<span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.getOwnPropertyNames 不能获取key为Symbol类型的属性</span></span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>.getOwnPropertySymbols(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;my_key&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for...of, for...in 中也不能获取到Symbol属性</span></span><br><span class="line"><span class="comment">// [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol.for</span></span><br><span class="line"><span class="comment">// 使用给定的key搜索现有的symbol，</span></span><br><span class="line"><span class="comment">// 如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol</span></span><br><span class="line"><span class="comment">// Symbol.for()会被登记在全局环境中</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol.keyFOr</span></span><br><span class="line"><span class="comment">// 从全局symbol注册表中，为给定的symbol检索一个共享的symbol key</span></span><br><span class="line"><span class="comment">// Symbol.for 是的s1登记在全局注册表中</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1)) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="函数防抖与节流"><a href="#函数防抖与节流" class="headerlink" title="函数防抖与节流"></a>函数防抖与节流</h1><p>防抖通常被叫做debounce, 节流叫做throttle. 它们的作用是用来控制事件对应的异步任务的执行频率。<br>简单来讲就是不能让一些异步任务总是在每一轮EventLoop中的主线程中老是执行。因为这样就抢占了<br>其他任务被执行的快慢。而本身自己也不需要执行那么多次。</p><h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><p>这个函数的大白话就是：多次执行只有一次有效，讲白了就是希望当前事件连续发生时对应的所有执行任务的最后一个任务生效，另外有些情况也会希望事件第一次发生的时候也运行一次</p><ul><li>常被用到的场景<ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</span><br><span class="line"><span class="comment">// 场景：</span></span><br><span class="line"><span class="comment">// 鼠标在页面上移动的时候，弹出恶意广告</span></span><br><span class="line"><span class="keyword">let</span> later</span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, timer, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(later)</span><br><span class="line">    later = <span class="built_in">setTimeout</span>(fn, timer, ...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alertAds = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    log(<span class="string">`point at (<span class="subst">$&#123;event.x&#125;</span>, <span class="subst">$&#123;event.y&#125;</span>) ads: 双十一就是淦`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    debounce(alertAds, <span class="number">1000</span>, event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面的debounce的写法不太好</span></span><br><span class="line"><span class="comment">// 因为later暴露在外面了，这样如果把debounce作为一个库函数导出的时候就没有封装的美感</span></span><br><span class="line"><span class="comment">// 所以应该用闭包的机制把later包起来，作为局部的全局变量</span></span><br><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, timer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> later;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        later &amp;&amp; <span class="built_in">clearTimeout</span>(later)</span><br><span class="line">        later = <span class="built_in">setTimeout</span>(fn, timer, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alertAds = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    log(<span class="string">`point at (<span class="subst">$&#123;event.x&#125;</span>, <span class="subst">$&#123;event.y&#125;</span>) ads: 双十一就是淦`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debounceAlertAds = debounce(alertAds, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里必须把它变成实名函数</span></span><br><span class="line"><span class="comment">// debounce(alertAds, 1000)(event)的写法是不会生效的</span></span><br><span class="line"><span class="comment">// 因为事件的回调函数是一个匿名函数</span></span><br><span class="line">    <span class="comment">// 每次事件的发生，都会重新创建一个新的函数作用域</span></span><br><span class="line">    <span class="comment">// 那么debounce运行的时候，都会生成一个新的later</span></span><br><span class="line">  <span class="comment">// 写成具体的debounceAlertAds以后, later就等于是个全局的了</span></span><br><span class="line">    debounceAlertAds(event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面写的debounce都是当前事件连续发生时所对应的执行任务的最后一个任务生效</span></span><br><span class="line"><span class="comment">// 但是有的场景需要事件第一次发生的时候也运行一次</span></span><br><span class="line"><span class="comment">// 场景:</span></span><br><span class="line"><span class="comment">// 鼠标在页面上连续移动的时候，弹出恶意广告</span></span><br><span class="line"><span class="comment">// 哈哈，真心想不到啥场景，就瞎弄了个，凑合下吧, 23333</span></span><br><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alertAds = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    log(<span class="string">`point at (<span class="subst">$&#123;event.x&#125;</span>, <span class="subst">$&#123;event.y&#125;</span>) ads: 双十一就是淦`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func, timer, immediate</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> later</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!later &amp;&amp; immediate) &#123;</span><br><span class="line">            func(...args)</span><br><span class="line">        &#125;</span><br><span class="line">        later &amp;&amp; <span class="built_in">clearTimeout</span>(later)</span><br><span class="line">        later = <span class="built_in">setTimeout</span>(func, timer, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debounceAlertAds = debounce(alertAds, <span class="number">1000</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    debounceAlertAds(event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h2><p>这个函数的大白话就是：技能有cd，只有冷却时间到了以后才能发出技能.讲白了就是希望当前事件连续发生时对应的所有执行任务中满足到了冷却时间点的任务被执行</p><ul><li>常被用到的场景<ul><li>滚动加载，加载更多或滚到底部监听</li><li>谷歌搜索框，搜索联想功能</li><li>高频点击提交，表单重复提交</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好吧，场景还是鼠标在页面上连续移动的时候，弹出恶意广告。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alertAds = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    log(<span class="string">`point at (<span class="subst">$&#123;event.x&#125;</span>, <span class="subst">$&#123;event.y&#125;</span>) ads: 双十一就是淦`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, timer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> later</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (later) <span class="keyword">return</span></span><br><span class="line">        later = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn(...args)</span><br><span class="line">            later = <span class="literal">null</span></span><br><span class="line">        &#125;, timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> throttleAlertAds = throttle(alertAds, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    throttleAlertAds(event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="js内存管理"><a href="#js内存管理" class="headerlink" title="js内存管理"></a>js内存管理</h1><h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放\归还</li></ol><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>这里我是抄的<a href="https://segmentfault.com/a/1190000018605776">这个人的关于垃圾回收机制的文章</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">mdn的js内存管理</a> 写的都挺好的。</p><ul><li>JavaScript 在定义变量时就完成了内存分配</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在js中一切都是对象，对象声明赋值(定义)以后就会自动分配内存</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;azerty&quot;</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li><p>使用值的过程实际上是对分配内存进行读取与写入的操作</p></li><li><p>内存释放-垃圾回收机制(跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它<br>大白话就是：监视所有对象，并删除那些不可访问的对象<br>js的垃圾回收机制算法如下:</p><ul><li><p>引用计数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用计数垃圾收集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">a: &#123;</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line"><span class="keyword">var</span> oa = o2.a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然最初的对象现在已经是零引用了，可以被垃圾回收了</span></span><br><span class="line"><span class="comment">// 但是它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line">o2 = <span class="string">&quot;yo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line"><span class="comment">// 它可以被垃圾回收了</span></span><br><span class="line">oa = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li><li><p>循环引用<br>该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收(通过标记清除算法解决)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注意在js的root中找不到o,o2的定义，会被标记清除 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;azerty&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure></li><li><p>标记清除<br>设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><ul><li><p>垃圾回收器获取根并“标记”(记住)它们。</p></li><li><p>然后它访问并“标记”所有来自它们的引用。</p></li><li><p>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</p></li><li><p>以此类推，直到有未访问的引用(可以从根访问)为止。</p></li><li><p>除标记的对象外，所有对象都被删除。<br>解决了上述的循环引用因为引用计数不会被回收的问题.</p></li></ul></li></ul></li></ul><ul><li><p><strong>具体实例:</strong></p><ol><li>编写一段代码如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function marry (man, woman) &#123;</span><br><span class="line">  woman.husban &#x3D; man;</span><br><span class="line">  man.wife &#x3D; woman;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    father: man,</span><br><span class="line">    mother: woman</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let family &#x3D; marry(&#123;</span><br><span class="line">  name: &quot;John&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: &quot;Ann&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>在引用标记内存结构如下</li></ol><p><img src="http://121.5.231.10:3000/js/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D1.png" alt="内存管理1.png"></p><ol start="3"><li>删除以下引用</li></ol> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> family.father;</span><br><span class="line"><span class="keyword">delete</span> family.mother.husband;</span><br></pre></td></tr></table></figure><ol start="4"><li>删除后的内存结构如下</li></ol></li></ul><pre><code>   ![内存分配2](http://121.5.231.10:3000/js/内存分配2.png)   ​                             ![内存分配3](http://121.5.231.10:3000/js/内存分配3.png)5. 然后删除famlily的引用，根据标记清除的原则后内存结构如下   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">family = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>   ![最终结果](http://121.5.231.10:3000/js/内存分配5.png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制算法</title>
      <link href="2021/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95/"/>
      <url>2021/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>^</code>: 两位相同为0，两位不同为1<br><code>&amp;</code>: 两位全为1则为1，否则为0<br><code>|</code>: 两位中有一位有1则为1，否则为0<br><code>&gt;&gt;</code>: 右移操作相当于除2<br><code>&lt;&lt;</code>: 左移操作相当于乘2</p><h1 id="十进制小数转换为二进制小数规定"><a href="#十进制小数转换为二进制小数规定" class="headerlink" title="十进制小数转换为二进制小数规定"></a>十进制小数转换为二进制小数规定</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 整数部分: 除2取余，逆序排列</span><br><span class="line">## 小数部分: 乘2取整，顺序排列</span><br><span class="line">例子: 173.8125</span><br><span class="line">173 &#x3D;&gt; 101011101</span><br><span class="line">0.8125 &#x3D;&gt; 0.1101</span><br><span class="line">0.8125 * 2 &#x3D; 1.6250(取1) &#x3D;&gt; 0.625 * 2 &#x3D;&gt; 1.2500(取1) &#x3D;&gt; 0.25 * 2 &#x3D;&gt; 0.5(取0) &#x3D;&gt; 0.5 * 2 &#x3D; 1.0(取1)</span><br></pre></td></tr></table></figure><h1 id="负数的二进制表示方法"><a href="#负数的二进制表示方法" class="headerlink" title="负数的二进制表示方法"></a>负数的二进制表示方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">负数以源码的补码表示</span><br><span class="line">负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1</span><br><span class="line">例：-10</span><br><span class="line">       &#x3D;&gt; 10000000 00000000 00000000 00001010 -10的源码</span><br><span class="line">       &#x3D;&gt; 11111111 11111111 11111111 11110101 -10的反码</span><br><span class="line">       &#x3D;&gt; 11111111 11111111 11111111 11110110 -10的反码加一</span><br></pre></td></tr></table></figure><h1 id="左移和右移运算-gt-gt-lt-lt"><a href="#左移和右移运算-gt-gt-lt-lt" class="headerlink" title="左移和右移运算 (&gt;&gt;, &lt;&lt;)"></a>左移和右移运算 (&gt;&gt;, &lt;&lt;)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 二进制的左移: m左移n位，最左边的n位被丢弃，右边补上n个0</span><br><span class="line">&#x2F;&#x2F; 二进制的右移：m右移n位，最右边的n位被丢弃，</span><br><span class="line">&#x2F;&#x2F; 如果数字是一个无符号数值，则用0填补最左边的n位，如果是负数，最左边补n个1</span><br><span class="line">00001010 &gt;&gt; 2 &#x3D;&gt; 00000010</span><br><span class="line">10001010 &gt;&gt; 3 &#x3D;&gt; 11110001</span><br></pre></td></tr></table></figure><h1 id="异或运算符（-）的操作"><a href="#异或运算符（-）的操作" class="headerlink" title="异或运算符（^）的操作"></a>异或运算符（^）的操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使特定位翻转</span><br><span class="line">与0相异或, 保留原值</span><br></pre></td></tr></table></figure><h1 id="无符号右移运算符（-gt-gt-gt-）"><a href="#无符号右移运算符（-gt-gt-gt-）" class="headerlink" title="无符号右移运算符（&gt;&gt;&gt;）"></a>无符号右移运算符（&gt;&gt;&gt;）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运算符把 expression1 的各个位向右移 expression2 指定的位数。右移后左边空出的位用零来填充。移出右边的位被丢弃</span><br></pre></td></tr></table></figure><h1 id="js中操作符的妙用"><a href="#js中操作符的妙用" class="headerlink" title="js中操作符的妙用"></a>js中操作符的妙用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1. 使用&amp;运算符判断一个数的奇偶</span><br><span class="line">例子： 2 &amp; 1 &#x2F;&#x2F; 0</span><br><span class="line">2. 使用~, &gt;&gt;, &lt;&lt;, &gt;&gt;&gt;, |来取整</span><br><span class="line">例子： 6.83 &gt;&gt; 0 &#x2F;&#x2F; 6</span><br><span class="line">3. 使用^来完成值交换</span><br><span class="line">例子： var a &#x3D; 5</span><br><span class="line">      var b &#x3D; 8</span><br><span class="line">      a ^&#x3D; b</span><br><span class="line">      b ^&#x3D; a</span><br><span class="line">      a ^&#x3D; b</span><br><span class="line">      console.log(a)   &#x2F;&#x2F; 8</span><br><span class="line">      console.log(b)   &#x2F;&#x2F; 5</span><br><span class="line">4. 使用&amp;, &gt;&gt;, | 来完成rgb值和16进制颜色值之间的转换</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">    #ffffff rgb(255, 255, 255)</span><br><span class="line">    8位表示一个色度</span><br><span class="line">    function hexToRGB(hex) &#123;</span><br><span class="line">        var hexx &#x3D; hex.replace(&#39;#&#39;, &#39;0x&#39;)</span><br><span class="line">        var r &#x3D; hexx &gt;&gt; 16</span><br><span class="line">        var g &#x3D; hexx &gt;&gt; 8 &amp; 0xff  &#x2F;&#x2F; 去掉r 00 00 ff ff  &amp; 00 00 00 ff</span><br><span class="line">        var b &#x3D; hexx &amp; 0xff      &#x2F;&#x2F; 去掉r, g &#x2F;&#x2F; 00 ff ff ff ff &amp; 00 00 00 ff</span><br><span class="line">        return &#96;rgb($&#123;r&#125;, $&#123;g&#125;, $&#123;b&#125;)&#96;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function RGBToHex(rgb) &#123;</span><br><span class="line">        var rgbArr &#x3D; rgb.split(&#x2F;[^\d]+&#x2F;)</span><br><span class="line">        var color &#x3D; rgbArr[1]&lt;&lt;16 | rgbArr[2]&lt;&lt;8 | rgbArr[3]</span><br><span class="line">        return &#39;#&#39;+ color.toString(16)</span><br><span class="line">    &#125;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">5: (A|B|C|D) &amp; D &#x3D; D, 这个可以检测一个集合中是否有该值存在。</span><br></pre></td></tr></table></figure><h1 id="常见的算法题"><a href="#常见的算法题" class="headerlink" title="常见的算法题"></a>常见的算法题</h1><h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p><a href="https://leetcode-cn.com/problems/hamming-distance/">题目来源</a></p><blockquote><p>思路:<br>xor操作后，右移记录1的个数，右移为0就结束了循环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hammingDistance = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> xor = x ^ y, count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (xor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xor &amp; <span class="number">1</span>) count++</span><br><span class="line">        xor &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h2><p><a href="https://leetcode-cn.com/problems/counting-bits/">题目来源</a></p><blockquote><p>思路:<br>奇数最后一位为1，偶数最后一位为0.<br>所以偶数的右移1位，1的个数不变。<br>奇数右移1位，1个个数减一。<br>因此得出：<br>如果 xx 是偶数，bit[x] = bit[x / 2]<br>如果 xx 是奇数，bit[x] = bit[x / 2] + 1<br>=&gt;<br>bix[x] = bit[x &gt;&gt; 1] + (x &amp; 1)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countBits = <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(num + <span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        result[i] = result[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><p><a href="https://leetcode-cn.com/problems/single-number/">题目来源</a></p><blockquote><p>思路:<br>因为其他的元素都出现过两次，那么两个相同元素进行异或就是0<br>然后0 ^ 只出现一次的数字值不会变: 0000000 ^ 0110101 = 0110101</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleNumber = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc ^= num, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="关于队列"><a href="#关于队列" class="headerlink" title="关于队列"></a>关于队列</h1><p>是一种先进先出的数据结构，在js中删除用shift，添加用push<br>因为队列的数据结构实现过于节点我就不写了</p><h1 id="关于栈"><a href="#关于栈" class="headerlink" title="关于栈"></a>关于栈</h1><p>是一种后进先出的数据结构，在js中删除用pop，添加用push<br>因为栈的数据结构实现过于节点我就不写了</p><h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><blockquote><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">题目来源</a><br>[[5, 0]]-&gt; [[5, 0], [null], [5, 2],  null, [4, 4],  [7, 1]]<br>-&gt; [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4],  [7, 1]]</p></blockquote><p>pepole = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>=&gt; 先h排序, 再k排序<br>=&gt; [[4, 4], [5, 2], [5, 0], [6, 1], [7, 1], [7, 0]]<br>7个人没有排序<br>=&gt; [null, null, null, null, null, null]<br>h:4的person前面有比我高的有4个，那么我肯定是是未排坑位的第四个坑<br>=&gt; [null, null, null, null, [4, 4], null]<br>h:5的person,前面2个比我高，那么我肯定是是未排坑位的第三个坑<br>=&gt; [[5, 0], null, [5, 2], null, [4, 4], null]<br>h:6,前面有一个人比我高， 那么我肯定是是未排坑位的第二个坑<br>=&gt; [[5, 0], null, [5, 2], null, [4, 4], null]<br>=&gt; [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]<br>思路:<br>step1: 先h排序，再k排序<br>一次遍历排序后得数组，按照它的k属性，和未排坑位，决定他的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reconstructQueue = <span class="function"><span class="params">pepole</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> people = pepole.sort(<span class="function">(<span class="params">cur, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">0</span>] - next[<span class="number">0</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> - (cur[<span class="number">1</span>] - next[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[<span class="number">0</span>] - next[<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> unsorted = <span class="keyword">new</span> <span class="built_in">Array</span>(people.length).fill(<span class="literal">null</span>)</span><br><span class="line">    pepole.forEach(<span class="function"><span class="params">person</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> [height, position] = person.slice()</span><br><span class="line">        <span class="comment">// log(&#x27;height, position&#x27;, height, position)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; unsorted.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!unsorted[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">                    unsorted[i] = person</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                position -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// log(&#x27;unsorted&#x27;, unsorted)</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> unsorted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h2 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h2><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h2 id="去出重复字母"><a href="#去出重复字母" class="headerlink" title="去出重复字母"></a>去出重复字母</h2><h2 id="用栈实现队列，用队列实现栈"><a href="#用栈实现队列，用队列实现栈" class="headerlink" title="用栈实现队列，用队列实现栈"></a>用栈实现队列，用队列实现栈</h2><h2 id="合并k个排序链表"><a href="#合并k个排序链表" class="headerlink" title="合并k个排序链表"></a>合并k个排序链表</h2><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组和堆</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E5%92%8C%E5%A0%86/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E5%92%8C%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><blockquote><p><a href="https://leetcode-cn.com/problems/rotate-image/">题目来源</a><br>思路:<br>matrix = Array.from(new Array(m), (item) =&gt; new Array(n).fill(0))<br>所谓的原地右旋: 列-&gt;行 对应的 x : y -&gt; y : x 但是值确倒叙了<br>(0, 2) -&gt; (1, 2) -&gt; (2, 2)  =&gt;  (2, 0) -&gt; (2, 1) -&gt; (2, 2)<br>3 -&gt; 6 -&gt; 9 =&gt; 9 -&gt; 6 -&gt; 3 =&gt; (0, 2) === (2, 2) 所以应该是 x : y -&gt; y : (n - x - 1)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">const</span> matrix_new = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix_new[j][n - i - <span class="number">1</span>] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[i][j] = matrix_new[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h2><blockquote><p><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">题目来源</a><br>思路:<br>遍历数组中每一项，然后在对自己遍历一次求乘积. 然而哈哈哈，超时了。 n * n的算法复杂度都不让通过。想想也是要不太简单了。因此面试的时候如果遇到一个题目觉得太简单，一定要想一想是不是踩坑了^_^<br>正解:</p><ol><li>初始化两个空数组 L 和 R。对于给定索引 i，L[i] 代表的是 i 左侧所有数字的乘积，R[i] 代表的是 i 右侧所有数字的乘积。</li><li>我们需要用两个循环来填充 L 和 R 数组的值。对于数组 L，L[0] 应该是 1，因为第一个元素的左边没有元素。对于其他元素：L[i] = L[i-1] * nums[i-1]。<br>同理，对于数组 R，R[length-1] 应为 1。length 指的是输入数组的大小。其他元素：R[i] = R[i+1] * nums[i+1]。</li><li>当 R 和 L 数组填充完成，我们只需要在输入数组上迭代，且索引 i 处的值为：L[i] * R[i]。</li><li>总结，庶竭驽钝。</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> productExceptSelf = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> L = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length)</span><br><span class="line">    <span class="keyword">const</span> R = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length)</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">            L[i] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L[i] = L[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = R.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === R.length - <span class="number">1</span>) &#123;</span><br><span class="line">            R[i] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            R[i] = R[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        result[i] = L[i] * R[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><blockquote><p><a href="https://leetcode-cn.com/problems/3sum/">题目来源</a><br>思路：</p></blockquote><ol><li>排序</li><li>两数之和就是用集合，三数之和就是对剩余数组做2数之和，用一个指针指向剩余数组左边，一个指针指向剩余数组右边<br>(遍历的时候不需要对大于0的项进行处理)</li><li>左指针每次右移遇到重复的数字继续右移，左移遇到重复的继续左移<br>nums = [-1, 0, 1, 2, -1, -4]<br>// sort<br>nums = [-4, -1, -1, 0, 1, 2]<br>//<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">let</span> L = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> R = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.push([nums[i], nums[L], nums[R]]);</span><br><span class="line">                <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L + <span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R - <span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">                L++;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><h2 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h2><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h2><h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><h2 id="和为S的连续正整数序列"><a href="#和为S的连续正整数序列" class="headerlink" title="和为S的连续正整数序列"></a>和为S的连续正整数序列</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="关于树结构的基本知识"><a href="#关于树结构的基本知识" class="headerlink" title="关于树结构的基本知识"></a>关于树结构的基本知识</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">树中节点数 &#x3D; 总分叉数 + 1</span><br><span class="line">叶子节点的度数为0, 度就是指该节点的直接子节点有几个</span><br><span class="line">树的存储结构：&#123;</span><br><span class="line">    双亲表示法：</span><br><span class="line">    孩子表示法：</span><br><span class="line">    孩子兄弟表示法:</span><br><span class="line">&#125;</span><br><span class="line">完全二叉树：从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</span><br><span class="line"></span><br><span class="line">二叉树第i层最多有2^(i-1)个节点</span><br><span class="line">二叉树深度为k最多有2^k-1个节点</span><br><span class="line">二叉树的终端结点数为n1，度数为2的结点数为n2, 则n1 &#x3D; n2 + 1</span><br><span class="line">完全二叉树的结点数为n,则深度为lg2(n)+1</span><br></pre></td></tr></table></figure><h1 id="二叉树相关的题目"><a href="#二叉树相关的题目" class="headerlink" title="二叉树相关的题目"></a>二叉树相关的题目</h1><h1 id="二叉搜索树相关的题目"><a href="#二叉搜索树相关的题目" class="headerlink" title="二叉搜索树相关的题目"></a>二叉搜索树相关的题目</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>若它的左子树不为空，则左子树上所有节点的值均小于它的根结构的值<br>若它的右子树不为空，则右子树上所有节点的值均大于它的根结构的值<br>它左，右子树也分别是二叉排序树</p><p>二叉搜索树的中序遍历是一个有序数组</p><h1 id="平衡二叉树-AVL-相关的题目"><a href="#平衡二叉树-AVL-相关的题目" class="headerlink" title="平衡二叉树(AVL)相关的题目"></a>平衡二叉树(AVL)相关的题目</h1><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>是一种二叉搜索树，其中每一个节点的左子树和右子树的高度差至多等于1<br>也就是说二叉树上所有节点的平衡因子(BF:节点的左子树深度减去节点右子树深度)只可能是-1，0，1.</p><h2 id="AVL的结构代码"><a href="#AVL的结构代码" class="headerlink" title="AVL的结构代码"></a>AVL的结构代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class BitNode &#123;</span><br><span class="line">    construct(data, lchild, rchild) &#123;</span><br><span class="line">        this.bf &#x3D; 0 &#x2F;&#x2F; 节点的平衡因子</span><br><span class="line">        this.data &#x3D; data</span><br><span class="line">        this.lchild &#x3D; (lchild &#x3D;&#x3D;&#x3D; undefined ? lchild : null)</span><br><span class="line">        this.rightchild &#x3D; (rchild &#x3D;&#x3D;&#x3D; undefined ? rchild : null)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对以p为根的二叉排序树右旋操作，1. 平衡因子大于1需要右旋， 2. 使得平衡因子变成负数</span><br><span class="line">    R_Rotate(p) &#123;</span><br><span class="line">        &#x2F;&#x2F; p的左节点</span><br><span class="line">        const l &#x3D; p.lchild</span><br><span class="line">        &#x2F;&#x2F; 将原来p左节点的右子树变成p的左子树</span><br><span class="line">        p.lchild &#x3D; l.rchild</span><br><span class="line">        &#x2F;&#x2F; 旋转后原来p的左节点的右节点变成p</span><br><span class="line">        l.rchild &#x3D; p</span><br><span class="line">        &#x2F;&#x2F; p指向新的节点</span><br><span class="line">        p &#x3D; l</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 左旋操作</span><br><span class="line">    L_Rotate(p) &#123;</span><br><span class="line">        const r &#x3D; p.rchild</span><br><span class="line">        p.rchild &#x3D; r.lchild</span><br><span class="line">        r.lchild &#x3D; p</span><br><span class="line">        p &#x3D; r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将一颗二叉搜索树变成AVL的过程"><a href="#将一颗二叉搜索树变成AVL的过程" class="headerlink" title="将一颗二叉搜索树变成AVL的过程"></a>将一颗二叉搜索树变成AVL的过程</h2><p><img src="http://121.5.231.10:3000/alogrithm/avl/avl1.png" alt="avl1"><br><img src="http://121.5.231.10:3000/alogrithm/avl/avl2.png" alt="avl1"><br><img src="http://121.5.231.10:3000/alogrithm/avl/avl3.png" alt="avl1"><br><img src="http://121.5.231.10:3000/alogrithm/avl/avl4.png" alt="avl1"></p><h1 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h1><p>树节点的结构代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.left = (left === <span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line">    <span class="built_in">this</span>.val = (val === <span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="built_in">this</span>.right = (right === <span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">    <span class="built_in">this</span>.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> root = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">const</span> levels = [[root]]</span><br><span class="line">        <span class="keyword">let</span> result = [root]</span><br><span class="line">        <span class="keyword">while</span> (levels.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> level = levels.pop()</span><br><span class="line">            <span class="keyword">const</span> ans = []</span><br><span class="line">            <span class="keyword">while</span> (level.length) &#123;</span><br><span class="line">                <span class="keyword">const</span> node = level.pop()</span><br><span class="line">                node.left &amp;&amp; ans.push(node.left)</span><br><span class="line">                node.right &amp;&amp; ans.push(node.right)</span><br><span class="line">            &#125;</span><br><span class="line">            ans.length &amp;&amp; levels.push(ans) &amp;&amp; (result = result.concat(ans.slice()))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.reduce(<span class="function">(<span class="params">acc, node</span>) =&gt;</span></span><br><span class="line">            acc.concat([node ? node.val : <span class="string">&#x27;null&#x27;</span>]),</span><br><span class="line">            [])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><blockquote><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">题目来源</a><br>思路:<br>节点root1存在 &amp; 节点root2存在 =&gt; 两个相加<br>节点root1存在 | 节点root2存在 =&gt; root1 | root2<br>否则 =&gt; null</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeTrees = <span class="function">(<span class="params">root1, root2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> val = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root1 &amp;&amp; root2) &#123;</span><br><span class="line">        val = root1.val + root2.val</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1 || root2) &#123;</span><br><span class="line">        val = (root1 &amp;&amp; root1.val) || (root2 &amp;&amp; root2.val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(val)</span><br><span class="line">    <span class="keyword">const</span> root1l = root1 ? root1.left : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> root1r = root1 ? root1.right : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> root2l = root2 ? root2.left : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> root2r = root2 ? root2.right : <span class="literal">null</span></span><br><span class="line">    node.left = mergeTrees(root1l, root2l)</span><br><span class="line">    node.right = mergeTrees(root1r, root2r)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">题目来源</a><br>思路:<br>就是求一颗树的镜像<br>节点root存在左子树，将其左子树变成节点的右子树<br>节点root存在右子树，将其右子树变成节点的左子树</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invertTree = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || (!root.left &amp;&amp; !root.right)) <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">const</span> lchild = root.left</span><br><span class="line">    <span class="keyword">const</span> rchild = root.right</span><br><span class="line">    root.left = rchild</span><br><span class="line">    root.right = lchild</span><br><span class="line">    root.left &amp;&amp; invertTree(root.left)</span><br><span class="line">    root.right &amp;&amp; invertTree(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><blockquote><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">题目来源</a><br>思路:</p><ol><li>dfs深度遍历每条路径即可</li><li>层次遍历</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxDepth = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">const</span> goLevel = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">        path.push(node.val)</span><br><span class="line">        <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">            result = <span class="built_in">Math</span>.max(result, path.length)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一步往左走</span></span><br><span class="line">        node.left &amp;&amp; goLevel(node.left)</span><br><span class="line">        <span class="comment">// 本次的结果</span></span><br><span class="line">        node.left &amp;&amp; path.pop()</span><br><span class="line">        <span class="comment">// 下一步往右走</span></span><br><span class="line">        node.right &amp;&amp; goLevel(node.right)</span><br><span class="line">        <span class="comment">// 本次的结果</span></span><br><span class="line">        node.right &amp;&amp; path.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    goLevel(root)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><blockquote><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">题目来源</a><br>思路：<br>下一步按照有左选左，没左选右，并记录本次没有左选择的结果，没左没右就结束。<br>depth0:  有左选左，没左选右, 并记录<br>depth1:  有左选左，没左选右, 并记录<br>  .<br>  .<br>no choice: 结束</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderTraversal = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 本次决定下一步选择走左</span></span><br><span class="line">        node.left &amp;&amp; dfs(node.left)</span><br><span class="line">        path.push(node.val)</span><br><span class="line">        <span class="comment">// 本次决定下一步选择走右</span></span><br><span class="line">        node.right &amp;&amp; dfs(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><blockquote><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">题目来源</a><br>思路：<br>对每个节点做了如下处理：左子树变成右子树，右子树变成转变后右子树的最右节点, 该节点的左子树为空</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">root</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> searize = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">const</span> lchild = node.left</span><br><span class="line">        <span class="keyword">const</span> rchild = node.right</span><br><span class="line">        node.right = lchild</span><br><span class="line">        node.left = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">let</span> p = node</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right === <span class="literal">null</span>) <span class="keyword">break</span></span><br><span class="line">            p = p.right</span><br><span class="line">        &#125;</span><br><span class="line">        p.right = rchild</span><br><span class="line">        searize(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">    searize(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从前序和中序遍历序列构造二叉树"><a href="#从前序和中序遍历序列构造二叉树" class="headerlink" title="从前序和中序遍历序列构造二叉树"></a>从前序和中序遍历序列构造二叉树</h2><blockquote><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">题目来源</a><br>思路: 分治法，拆拆拆。<br>前序可以得出数组首元素是根元素<br>中序可以得到左子树和右子树</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buildTree = <span class="function">(<span class="params">preorder, inorder</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> nodeVal = preorder[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> index = inorder.indexOf(nodeVal)</span><br><span class="line">    inorder.indexOf(nodeVal)</span><br><span class="line">    node = <span class="keyword">new</span> TreeNode(nodeVal)</span><br><span class="line">    node.left = buildTree(preorder.slice(<span class="number">1</span>, index + <span class="number">1</span>), inorder.slice(<span class="number">0</span>, index))</span><br><span class="line">    node.right = buildTree(preorder.slice(index + <span class="number">1</span>), inorder.slice(index + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><blockquote><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">题目来源</a><br>思路1：<br>dfs的回溯能求出所有的组合然后对搜有的组合进行判断是否是二叉搜索树，这种显然很耗时间<br>而且特别复杂，在这里总结出了如果有很多种选择的可能，或者逻辑点很多的不要使用回溯，会头痛死<br>思路二:<br>看了官方的动态规划，嗐，感慨还是动态规划好。不要有了新欢就忘了旧爱…..<br>定义公式：<br>G(n): 长度为n的序列能构成的不同二叉搜索树的个数。<br>F(i,n): 以i为根，序列长度为n的不同二叉搜索树个数(1 &lt;= i &lt;= n)<br>则:<br>G(n) = F(1, n) + …. + F(n, n)<br>依次遍历{1..n},当以作为根节点时候将1…(i - 1)作为左子树，i + 1…n 作为右子树<br>其中: G(0)=1, G(1)=1<br>这个遍历的时候有F(i, n) = 左:G(i - 1) * 右: G(n - i)<br>因为：G(n) = F(1, n) + …. + F(n, n)， F(i, n) = G(i - 1) * G(n - i)<br>所以: G(n) = G(1 - 1) * G(n - 1) + … + G(n - 1) * G(0)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numTrees = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> G = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="number">0</span></span><br><span class="line">    G[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    G[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="comment">// 长度为i的集合 = 以j为根长度为i的总集合</span></span><br><span class="line">            <span class="comment">// G[i] = G[i] + F(j, i)</span></span><br><span class="line">            G[i] = G[i] + G[j - <span class="number">1</span>] * G[i - j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="二叉搜索树的第k个节点"><a href="#二叉搜索树的第k个节点" class="headerlink" title="二叉搜索树的第k个节点"></a>二叉搜索树的第k个节点</h2><h2 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h2><h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><h2 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h2><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><h2 id="二叉搜索树与查找表"><a href="#二叉搜索树与查找表" class="headerlink" title="二叉搜索树与查找表"></a>二叉搜索树与查找表</h2><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>思路:<br>每一次循环可以保证将一个最大的数放置末尾（一次至少能排一个）<br>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; list.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[i] &gt; list[j]) &#123;</span><br><span class="line">                [list[i], list[j]] = [list[j], list[i]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>思路:<br>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中<br>从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序<br>最开始已排序好的数组中只有一个元素</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> value = list[i]</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; list[j]) &#123;</span><br><span class="line">                list[j + <span class="number">1</span>] = list[j]</span><br><span class="line">                list[j] = value</span><br><span class="line">            &#125;</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>思路:<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。<br>相比于之前的插入排序的优化是减少了插入的移动次数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shellSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = list.length, gap = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 动态定义间隔序列</span></span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后还是做了间隔为1的插入排序，只是这个时候再插入基本不需要怎么移动了</span></span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 插入排序</span></span><br><span class="line">            temp = list[i]</span><br><span class="line">            <span class="keyword">let</span> j = i - gap</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list[j] &gt; temp) &#123;</span><br><span class="line">                    list[j + gap] = list[j]</span><br><span class="line">                    list[j] = temp</span><br><span class="line">                &#125;</span><br><span class="line">                j -= gap</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>思路:<br>一次遍历，每次确立第i位的元素是什么</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; list.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[j] &lt; list[i]) &#123;</span><br><span class="line">                [list[i], list[j]] = [list[j], list[i]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>思路:<br>从数列中挑出一个元素，称为 “基准”（pivot）<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面<br>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> mid = list[<span class="built_in">Math</span>.floor(list.length / <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">const</span> left = list.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item &lt;= mid &amp;&amp; index !== <span class="built_in">Math</span>.floor(list.length / <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">const</span> right = list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; mid)</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([mid]).concat(quickSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>思路:<br>一种分治法，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>, result = []</span><br><span class="line">        <span class="keyword">while</span> ((i &lt; left.length) &amp;&amp; (j &lt; right.length)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class="line">                result.push(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.concat(left.slice(i)).concat(right.slice(j))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list.length &lt; <span class="number">2</span>) <span class="keyword">return</span> list</span><br><span class="line">    <span class="comment">// 分成小问题,拆到只剩两个最小的序列</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(list.length / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> left = mergeSort(list.slice(<span class="number">0</span>, mid))</span><br><span class="line">    <span class="keyword">let</span> right = mergeSort(list.slice(mid))</span><br><span class="line">    <span class="comment">// 治</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>思路:<br>将数组变成大顶堆以后，只需要每次将堆首和末尾的最后一个元素交换，即可排序</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆调整</span></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function">(<span class="params">arr, i, len</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> root = i, left = <span class="number">2</span> * i + <span class="number">1</span>, right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[right]) &#123;</span><br><span class="line">        root = left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[root]) &#123;</span><br><span class="line">        root = right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root !== i) &#123;</span><br><span class="line">        [arr[i], arr[root]] = [arr[root], arr[i]]</span><br><span class="line">        heapify(arr, root)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建大顶堆</span></span><br><span class="line"><span class="keyword">const</span> buildHeap = <span class="function">(<span class="params">arr, len</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从i=len/2开始，是因为大于len/2没有左和右节点</span></span><br><span class="line">    <span class="comment">// 另外需要从len / 2层往上走才行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i, len)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heapSort = <span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = list.length</span><br><span class="line">    buildHeap(list, len)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = list.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        [list[i], list[<span class="number">0</span>]] = [list[<span class="number">0</span>], list[i]]</span><br><span class="line">        len -= <span class="number">1</span></span><br><span class="line">        buildHeap(list, i, len)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表的结构"><a href="#链表的结构" class="headerlink" title="链表的结构"></a>链表的结构</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = (val === <span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="built_in">this</span>.next = (next === <span class="literal">undefined</span> ? <span class="literal">null</span> : next)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> stack = [<span class="built_in">this</span>.val]</span><br><span class="line">        <span class="keyword">let</span> p = <span class="built_in">this</span>.next</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            stack.push(p.val)</span><br><span class="line">            p = p.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><blockquote><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目来源</a><br>思路1: 分治法<br>对两个节点做如下处理</p><ol><li>当前节点变成下一个节点的下一节点</li><li>当前节点的next是null<br>思路2: 正常的迭代方法<br>依次遍历每个节点，对每个节点作如下处理<br>next = cur.next<br>cur.next = pre<br>pre = cur<br>cur = next</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="params">head</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head</span><br><span class="line">    <span class="comment">// 遍历到链表只有一个节点以后回退，也就是说下一步只剩一个节点就要回退了</span></span><br><span class="line">    <span class="keyword">let</span> p = reverseList(head.next)</span><br><span class="line">    <span class="comment">// 当前节点变成队尾</span></span><br><span class="line">    head.next.next = head</span><br><span class="line">    <span class="comment">// 当前节点的next是null</span></span><br><span class="line">    head.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseList1 = <span class="function"><span class="params">head</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = head, pre = <span class="literal">null</span>, next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        next = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><blockquote><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">题目来源</a><br>思路1：通过next创建一个新的链表，然后新链表与老链表做一一映射关系。f(old[n]) = f(new[n])<br>其实就是用一个映射表存储他们的映射关系就好，然后遍历映射表做处理即可</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">val, next, random</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    <span class="built_in">this</span>.next = next;</span><br><span class="line">    <span class="built_in">this</span>.random = random;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copyRandomList = <span class="function"><span class="params">head</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">let</span> p = head, pre = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// create new list and handle map for old list and new list</span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(p.val)</span><br><span class="line">        map.set(p, node)</span><br><span class="line">        pre &amp;&amp; (pre.next = node)</span><br><span class="line">        pre = node</span><br><span class="line">        p = p.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// log(&#x27;new list&#x27;, map.get(head))</span></span><br><span class="line">    <span class="comment">// traverse map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [oldNode, newNode] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">        <span class="keyword">let</span> key = oldNode.random</span><br><span class="line">        <span class="keyword">let</span> findNode = map.get(key)</span><br><span class="line">        newNode.random = findNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><blockquote><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">题目来源</a><br>思路：<br>两个都有序的话就很好弄了，两个一起遍历，一次比较</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeTwoLists = <span class="function">(<span class="params">l1, l2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> ListNode(<span class="built_in">Math</span>.min(l1.val, l2.val))</span><br><span class="line">        pre &amp;&amp; (pre.next = node)</span><br><span class="line">        !pre &amp;&amp; (head = node)</span><br><span class="line">        pre = node</span><br><span class="line">        l1.val &lt; l2.val ? (l1 = l1.next) : (l2 = l2.next)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pre) <span class="keyword">return</span> l1</span><br><span class="line">        pre.next = l1</span><br><span class="line">        pre = pre.next</span><br><span class="line">        l1 = l1.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pre) <span class="keyword">return</span> l2</span><br><span class="line">        pre.next = l2</span><br><span class="line">        pre = pre.next</span><br><span class="line">        l2 = l2.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表倒数第k个节点"><a href="#链表倒数第k个节点" class="headerlink" title="链表倒数第k个节点"></a>链表倒数第k个节点</h2><blockquote><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">题目来源</a><br>思路：<br>经典的双指针问题</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getKthFromEnd = <span class="function">(<span class="params">head, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head, slow = head</span><br><span class="line">    <span class="comment">// fast先跑</span></span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        fast = fast.next</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一起跑</span></span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        fast = fast.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="画圈中剩下的最后的数字"><a href="#画圈中剩下的最后的数字" class="headerlink" title="画圈中剩下的最后的数字"></a>画圈中剩下的最后的数字</h2><blockquote><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">题目来源</a><br>思路: 使用链表模拟即可<br>0-&gt;1-&gt;2-&gt;3-&gt;4 m = 2<br>1<br>3<br>0<br>4</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会超时</span></span><br><span class="line"><span class="keyword">const</span> lastRemaining1 = <span class="function">(<span class="params">n, m</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// create list ring</span></span><br><span class="line">    <span class="keyword">while</span> (start !== n) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> ListNode(start)</span><br><span class="line">        pre &amp;&amp; (pre.next = node)</span><br><span class="line">        !pre &amp;&amp; (head = node)</span><br><span class="line">        pre = node</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = head</span><br><span class="line">    <span class="comment">// 当只剩一个节点的时候，head === pre</span></span><br><span class="line">    <span class="comment">// count % m === 0 就说明要删除</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (head !== pre) &#123;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (count % m === <span class="number">0</span>) &#123;</span><br><span class="line">            pre.next = head.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = pre.next</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表1"><a href="#环形链表1" class="headerlink" title="环形链表1"></a>环形链表1</h2><blockquote><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">题目来源</a><br>思路：快慢指针，能相遇就是环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会超时</span></span><br><span class="line"><span class="keyword">const</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">let</span> slow = head</span><br><span class="line">    <span class="keyword">let</span> quick = head.next</span><br><span class="line">    <span class="keyword">while</span> ((quick !== slow)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!quick || !slow || !quick.next) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next</span><br><span class="line">        quick = quick.next.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (quick === slow) &#123;</span><br><span class="line">        result = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表2"><a href="#环形链表2" class="headerlink" title="环形链表2"></a>环形链表2</h2><blockquote><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">题目来源</a><br>思路：在这里快慢指针需要进行数学分析一般来说阻碍比较大<br>这里需要使用集合存储节点，当存在一个节点的下一个节点再集合里面说明是环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> detectCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> pos</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.has(head)) &#123;</span><br><span class="line">            pos = head</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(head)</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h1><p>从n个不同元素中，任取m个不同的元素按照一定的顺序排成一列,叫做从n个不同元素中取出m个元素的一个排列. 从n个不同元素中取出m(m≤n）个元素的所有排列的个数，叫做从n个不同元素中取出m个元素的排列数，用符号<code>A(n, m)</code>表示，此外规定<code>0! = 1</code><br><img src="https://bkimg.cdn.bcebos.com/formula/ac0926e610dce08b12a0c0c42b835cb0.svg" alt="计算公式"></p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>从n个不同元素中，任取m(m≤n）个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m≤n）个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。用符号<code>C(n,m)</code> 表示<code>C(n,m)=C(n,n-m)</code><br><img src="https://bkimg.cdn.bcebos.com/formula/620a7d43cbc2c75ca47802b017929910.svg" alt="计算公式"></p><h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><blockquote><p><a href="https://leetcode-cn.com/problems/subsets/">题目来源</a><br>思路:<br>深度:    选择<br>depth0: [1], []<br>depth1: [2], []<br>depth2: [3], []<br>depth3: back</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subsets = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="comment">// 当前路径</span></span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">depth</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 走到第nums.length的时候就不需要往下走了</span></span><br><span class="line">        <span class="keyword">if</span> (depth === nums.length) &#123;</span><br><span class="line">            result.push(path.slice())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 采用当前节点值并往下走</span></span><br><span class="line">        path.push(nums[depth])</span><br><span class="line">        dfs(depth + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 不采用当前值并往下走</span></span><br><span class="line">        path.pop()</span><br><span class="line">        dfs(depth + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><blockquote><p><a href="https://leetcode-cn.com/problems/permutations/">题目来源</a><br>思路:<br>[1, 2, 3] -&gt; [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]<br>深度:      选择:<br>depth0: [[1], [2], [3]] intersection used[]<br>depth1: [[1], [2], [3]] intersection used[choice1]<br>depth2: [[1], [2], [3]] intersection used[choice1, choice2]<br>depth3: 结束</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permute = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> used = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">depth</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth === nums.length) &#123;</span><br><span class="line">            result.push(path.slice())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used.has(i)) &#123;</span><br><span class="line">                used.add(i)</span><br><span class="line">                path.push(nums[i])</span><br><span class="line">                dfs(depth + <span class="number">1</span>)</span><br><span class="line">                used.delete(i)</span><br><span class="line">                path.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><blockquote><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">题目来源</a><br>思路:<br>n = 3 [“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>depth0:<br>        =&gt; 左 &amp;&amp; (left &lt; n) 或者 右 &amp;&amp; (right &lt; left)<br>depth1:<br>        =&gt; 左 &amp;&amp; (left &lt; n) 或者 右 &amp;&amp; (right &lt; left)<br>depth2:<br>        =&gt; 左 &amp;&amp; (left &lt; n) 或者 右 &amp;&amp; (right &lt; left)<br>  .<br>  .<br>  .<br>depth2n:  结束</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generateParenthesis = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function"><span class="params">depth</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth === <span class="number">2</span> * n) &#123;</span><br><span class="line">            result.push(path.slice().join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; n) &#123;</span><br><span class="line">            path.push(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            left++</span><br><span class="line">            dfs(depth + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">            left--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">            right++</span><br><span class="line">            path.push(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            dfs(depth + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><blockquote><p><a href="https://leetcode-cn.com/problems/combination-sum/">题目来源</a><br>思路:<br>candidates = [2,3,6,7], target = 7, result = [[7], [2,2,3]]<br>candidates = [2,3,5], target = 8, result = [[2,2,2,2],[2,3,3],[3,5]]<br>depth0: choice in candidates<br>depth1: choice in candidates<br>  .<br>  .<br>depth sum &gt; target: back</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combinationSum = <span class="function">(<span class="params">candidates, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">depth</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> cp = path.slice()</span><br><span class="line">        <span class="keyword">const</span> sum = cp.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc + item, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            result.push(cp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            path.push(candidates[i])</span><br><span class="line">            dfs(depth + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">return</span> result.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val = item.sort().join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (!set.has(val)) &#123;</span><br><span class="line">            set.add(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>(<a href="https://leetcode-cn.com/problems/restore-ip-addresses/">https://leetcode-cn.com/problems/restore-ip-addresses/</a>)</p><h2 id="图像渲染"><a href="#图像渲染" class="headerlink" title="图像渲染"></a>图像渲染</h2><p>(<a href="https://leetcode-cn.com/problems/flood-fill/">https://leetcode-cn.com/problems/flood-fill/</a>)</p><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><p>(<a href="https://leetcode-cn.com/problems/word-search/">https://leetcode-cn.com/problems/word-search/</a>)</p><h2 id="复原IP地址-1"><a href="#复原IP地址-1" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><p>(<a href="https://leetcode-cn.com/problems/restore-ip-addresses/">https://leetcode-cn.com/problems/restore-ip-addresses/</a>)</p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>(<a href="https://leetcode-cn.com/problems/n-queens/">https://leetcode-cn.com/problems/n-queens/</a>)</p><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>(<a href="https://leetcode-cn.com/problems/number-of-islands/">https://leetcode-cn.com/problems/number-of-islands/</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ensure = <span class="function"><span class="keyword">function</span>(<span class="params">condition, message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">        log(<span class="string">&#x27;*** 测试失败&#x27;</span>, message)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log(<span class="string">&#x27;+++ 测试成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = []</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">101</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">hash</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> val = s[i]</span><br><span class="line">            <span class="keyword">let</span> v = val.charCodeAt(<span class="number">0</span>)</span><br><span class="line">            v = v * <span class="number">10</span> ** i</span><br><span class="line">            r += v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">index</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> l = <span class="built_in">this</span>.hash(s)</span><br><span class="line">        <span class="keyword">let</span> i = l % <span class="built_in">this</span>.size</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">this</span>.index(key)</span><br><span class="line">        <span class="keyword">let</span> tag = <span class="built_in">this</span>.data[index]</span><br><span class="line">        <span class="keyword">let</span> ans = []</span><br><span class="line">        <span class="keyword">if</span> (tag === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            ans.push([key, value])</span><br><span class="line">            <span class="built_in">this</span>.data[index] = ans</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">let</span> status = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">for</span> (i; i &lt; tag.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> k = t[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> (k === key) &#123;</span><br><span class="line">                    t[<span class="number">1</span>] = value</span><br><span class="line">                    status = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!status &amp;&amp; i === tag.length) &#123;</span><br><span class="line">                tag.push([key, value])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = value</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">this</span>.index(key)</span><br><span class="line">        <span class="keyword">let</span> tags = <span class="built_in">this</span>.data[index]</span><br><span class="line">        <span class="keyword">if</span> (tags === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> tag <span class="keyword">of</span> tags) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag[<span class="number">0</span>] === key) &#123;</span><br><span class="line">                result = tag[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">this</span>.index(key)</span><br><span class="line">        <span class="keyword">let</span> tags = <span class="built_in">this</span>.data[index]</span><br><span class="line">        <span class="keyword">if</span> (tags === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> tag <span class="keyword">of</span> tags) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tag[<span class="number">0</span>] === key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><h2 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h2><h2 id="宝石与石头"><a href="#宝石与石头" class="headerlink" title="宝石与石头"></a>宝石与石头</h2>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><h2 id="搜索二维矩阵II"><a href="#搜索二维矩阵II" class="headerlink" title="搜索二维矩阵II"></a>搜索二维矩阵II</h2><h2 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h2><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><h2 id="最小k个数"><a href="#最小k个数" class="headerlink" title="最小k个数"></a>最小k个数</h2><h2 id="排序矩阵查找"><a href="#排序矩阵查找" class="headerlink" title="排序矩阵查找"></a>排序矩阵查找</h2><h2 id="漂亮数组"><a href="#漂亮数组" class="headerlink" title="漂亮数组"></a>漂亮数组</h2><h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><h2 id="为运算表达式设计优先级"><a href="#为运算表达式设计优先级" class="headerlink" title="为运算表达式设计优先级"></a>为运算表达式设计优先级</h2>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><blockquote><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">题目来源</a><br>思路：<br>dp(i)(j) 从左上角到(i, j)位置的最小路径<br>// 当只能竖着走的时候<br>dp(i)(0) = dp(i-1)(0) + grid[i][0]<br>// 当只能横着走的时候<br>dp(0)(i) = dp(0)(i-1) + grid[0][i]<br>// 当上一步可以通过向右或者向下到当前(i, j)位置的时候<br>dp(i)(j) = Math.min(dp(i-1)(j), dp(i)(j-1)) + grid[i][j]</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> minPathSum = <span class="function"><span class="params">grid</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid === <span class="literal">null</span> || grid.length === <span class="number">0</span> || grid[<span class="number">0</span>].length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> rows = grid.length</span><br><span class="line">    <span class="keyword">const</span> cols = grid[<span class="number">0</span>].length</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(rows), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(cols).fill(<span class="number">0</span>))</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; cols; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[rows - <span class="number">1</span>][cols - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h2 id="最长上升子序列-1"><a href="#最长上升子序列-1" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全简介</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="说说什么是SQL注入？如何防止SQL注入？"><a href="#说说什么是SQL注入？如何防止SQL注入？" class="headerlink" title="说说什么是SQL注入？如何防止SQL注入？"></a>说说什么是SQL注入？如何防止SQL注入？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">就是通过把&#96;SQL&#96;命令插入到&#96;Web&#96;表单递交或输入域名或页面请求的查询字符串，</span><br><span class="line">最终达到欺骗服务器执行恶意的SQL命令。</span><br><span class="line">因此永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。</span><br><span class="line">所谓的参数化查询（Parameterized Query 或 Parameterized Statement）是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数 (Parameter) 来给值。</span><br></pre></td></tr></table></figure><h1 id="说说XSS的原理及防范"><a href="#说说XSS的原理及防范" class="headerlink" title="说说XSS的原理及防范?"></a>说说XSS的原理及防范?</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">攻击指的是攻击者往Web页面里插入恶意&#96;html&#96;标签或者javascript代码。</span><br><span class="line">因此代码里用户输入的地方和变量都需要仔细检查长度和对&quot;&lt;&quot;、&quot;&quot;&gt;&quot;、&quot;;&quot;、&quot;’&quot;等字符做过滤；</span><br><span class="line">其次任何内容写到页面之前都必须加以&#96;encode&#96;，避免不小心把&#96;html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS攻击。</span><br></pre></td></tr></table></figure><h1 id="跨站请求伪造-csrf"><a href="#跨站请求伪造-csrf" class="headerlink" title="跨站请求伪造 csrf"></a>跨站请求伪造 csrf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">攻击者盗用了你的身份，以你的名义发送恶意请求。</span><br><span class="line">要完成一次CSRF攻击，受害者必须依次完成两个步骤：</span><br><span class="line">a、登录受信任网站A，并在本地生成Cookie。</span><br><span class="line">b、在不登出A的情况下，访问危险网站B。</span><br><span class="line"></span><br><span class="line">网站A ：为恶意网站。</span><br><span class="line">网站B ：用户已登录的网站。</span><br><span class="line">当用户访问 A站 时，A站 私自访问 B站 的操作链接，模拟用户操作。</span><br><span class="line">设B站有一个删除评论的链接：http:&#x2F;&#x2F;b.com&#x2F;comment&#x2F;?type&#x3D;delete&amp;id&#x3D;81723</span><br><span class="line">A站 直接访问该链接，就能删除用户在 B站 的评论。</span><br><span class="line"></span><br><span class="line">解决办法: 使用验证码验证身份</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输层协议简介</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="tcp协议"><a href="#tcp协议" class="headerlink" title="tcp协议"></a>tcp协议</h1><p>该协议的作用是保证数据通信的完整性和可靠性，防止丢包。<br>特点如下:<br><strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>面向字节流的</strong>、<strong>有流量控制</strong>、<strong>阻塞控制</strong>、<strong>负载较高</strong></p><h1 id="upd协议"><a href="#upd协议" class="headerlink" title="upd协议"></a>upd协议</h1><p><strong>面向无连接的</strong>、<strong>不可靠的</strong>、<strong>面向数据报的</strong>、<strong>无流量控制</strong>、<strong>无阻塞控制</strong>、<strong>负载相对较低</strong></p><h1 id="tcp与udp的区别"><a href="#tcp与udp的区别" class="headerlink" title="tcp与udp的区别"></a>tcp与udp的区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）TCP协议在传送数据段的时候要给段标号；UDP协议不</span><br><span class="line">（2）TCP协议可靠；UDP协议不可靠</span><br><span class="line">（3）TCP协议是面向连接；UDP协议采用无连接</span><br><span class="line">（4）TCP协议负载较高，采用虚电路；UDP采用无连接</span><br><span class="line">（5）TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</span><br><span class="line">（6）TCP协议采用窗口技术和流控制</span><br></pre></td></tr></table></figure><h2 id="tcp的流量控制"><a href="#tcp的流量控制" class="headerlink" title="tcp的流量控制"></a>tcp的流量控制</h2><p>为了提高信道的利用率TCP协议不使用停止等待协议，而是使用滑动窗口协议(连续ARQ协议)<br>意思就是可以连续发出若干个分组然后等待确认,而不是发送一个分组就停止并等待该分组的确认。<br>而所谓流量控制就是让发送端发送的数据过多或者数据发送速率过快，接收端来不及处理，则会造成数据在接收端的丢弃。<br>利用滑动窗口（零窗口，坚持定时器）机制就可以实施流量控制。<br>关于滑动窗口机制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">接收端可以用大小为0的窗口(目前不能在接受数据了)通知发送端停止发送数据流。</span><br><span class="line">但是如果下一次窗口不为0的应答在传输过程丢失，发送者一直等待下去</span><br><span class="line">而接收者以为发送者已经收到该应答等待接收新数据，这样双方就相互等待，从而产生死锁。</span><br><span class="line">所以还需要用定时器机制处理，每当发送者收到一个零窗口的应答后就启动该计时器</span><br><span class="line">发送端定时发送探测报文段，接收端应答不为0，就继续定时发送，直到接收端缓存不为空。</span><br></pre></td></tr></table></figure><h2 id="tcp的阻塞控制"><a href="#tcp的阻塞控制" class="headerlink" title="tcp的阻塞控制"></a>tcp的阻塞控制</h2><p>为什么会产生TCP的阻塞呢, 其实就是发送端发送的报文速度要比接收端处理数据速率大。<br>TCP对于阻塞控制一共有四种算法，分别是<strong>慢开始</strong>，<strong>阻塞避免</strong>，<strong>快重传</strong>，<strong>快恢复</strong>四种算法。<br>由于需要考虑拥塞控制和流量控制两个方面的内容, 因此TCP的真正的发送窗口=min(rwnd, cwnd)(接受窗口, 拥塞窗口)</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>怎么知道接收方线路的理想速率是多少呢，需要慢启动慢慢试<br>始的时候，发送得较慢，然后根据丢包的情况调整速率，如果不丢包，就加快发送速度；如果丢包，就降低发送速度。</p><h3 id="阻塞避免"><a href="#阻塞避免" class="headerlink" title="阻塞避免"></a>阻塞避免</h3><p>到达阈值以后，加法增加。<br>从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，<br>但是cwnd不能一直这样无限增长下去，一定需要某个限制。<br>TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。<br>拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。<br>此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，<br>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。</p><p><img src="http://121.5.231.10:3000/computerNetwork/%E9%98%BB%E5%A1%9E%E6%9C%BA%E5%88%B6.jpg" alt="阻塞避免的图片"></p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>收到三次同样的ack以后，立即发送该syn报文，并启用快恢复<br>ack是指：一个确认消息，携带了期待要收到下一个数据包的编号和接收方的接收窗口的剩余容量<br><img src="http://121.5.231.10:3000/computerNetwork/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg" alt="快重传"></p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>如果发送方设置定时器超时，那么很可能是网络出现了拥塞，<br>致使TCP报文段在网络中的某处被丢弃。在这种情况下<br>开始门限值减半，然后使用阻塞避免的增加法</p><h2 id="面向连接的-tcp的三次握手）"><a href="#面向连接的-tcp的三次握手）" class="headerlink" title="面向连接的(tcp的三次握手）"></a>面向连接的(tcp的三次握手）</h2><p>序列号:seq, 确认号:ack, syn:报文<br>客户端发送SYN报文，置发序列号为X<br>服务端发送SYN+ACK报文，并置发序列号为Y，确认序列号X+1<br>客户端发送ACK报文，并置发序列号为Z，确认号Y+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一次握手：建立连接时，客户端A发送SYN包(SYN&#x3D;j)到服务器B，并进入SYN_SEND状态，等待服务器B确认。</span><br><span class="line"></span><br><span class="line">第二次握手：服务器B收到SYN包，必须确认客户A的SYN(ACK&#x3D;j+1)，同时自己也发送一个SYN包(SYN&#x3D;k)，即SYN+ACK包，此时服务器B进入SYN_RECV状态</span><br><span class="line"></span><br><span class="line">第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK(ACK&#x3D;k+1)，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</span><br></pre></td></tr></table></figure><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>主动发送Fin+Ack报文，并置发序列号为X<br>被发送方发送ACK报文，并只发送序列号为Z，确认号X+1<br>被动方发送Fin+Ack报文，并只发送序列号Y，确认号为X<br>主动发发送ack报文，并只发送序列号X，确认号Y</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一次挥手:客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送(报文段4)。[A告诉B我要和你断开连接了]</span><br><span class="line">第二次挥手: 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1(报文段5)。和SYN一样，一个FIN将占用一个序号。 [B发送发可能还有数据没有发送完给A，把剩余的数据发送出去]</span><br><span class="line">第三次挥手: 与客户端A的连接，发送一个FIN给客户端A(报文段6)。 [B发送方告诉A我要断开和你的连接了]</span><br><span class="line">第四次挥手: CK报文确认，并将确认序号设置为收到序号加1(报文段7)。 [A告诉B我收到了你要和我断开连接的消息]</span><br></pre></td></tr></table></figure><h2 id="为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"><a href="#为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？" class="headerlink" title="为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？"></a>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</h2><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，<br>它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。<br>但关闭连接时，当收到对方的FIN报文通知时，<br><code>它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了</code><br>所以你可能未必会马上会关闭SOCKET, 以及你可能还需要发送一些数据给对方之后，<br>再发送FIN报文给对方来表示你同意现在可以关闭连接了，<br>所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层协议简介</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="ARP（地址解析协议）"><a href="#ARP（地址解析协议）" class="headerlink" title="ARP（地址解析协议）"></a>ARP（地址解析协议）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。</span><br><span class="line">ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，</span><br><span class="line">在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个&quot;广播&quot;地址。</span><br><span class="line">它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。</span><br><span class="line">如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</span><br><span class="line">总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，</span><br><span class="line">可以把数据包发送到任意一台主机之上了。</span><br></pre></td></tr></table></figure><h1 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从Mac地址定位到IP地址的一种协议</span><br></pre></td></tr></table></figure><h1 id="广播和多播"><a href="#广播和多播" class="headerlink" title="广播和多播"></a>广播和多播</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">广播：主机号全为1或0，广播中又有直接广播</span><br><span class="line">网络地址192.168.0.0&#x2F;24 -&gt; 192.168.1.255&#x2F;24目标发送IP包</span><br><span class="line">收到这个包的路由器将数据发送给192.168.1.0&#x2F;24</span><br><span class="line">使得192.168.1.1-192.168.1.254的主机都能就收到这个包</span><br><span class="line">广播会带来不必要的流量，而且不能穿透路由，不能再其他网段发送数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多播：使用D类地址</span><br><span class="line">224.0.0.0-239.255.255.255</span><br></pre></td></tr></table></figure><h1 id="子网，子网掩码"><a href="#子网，子网掩码" class="headerlink" title="子网，子网掩码"></a>子网，子网掩码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip地址 + 子网掩码 &#x3D; 网络地址</span><br></pre></td></tr></table></figure><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">面向无连接的，</span><br><span class="line">ip负责把数据发送给目标主机，tcp负责保证对端主机收到数据</span><br></pre></td></tr></table></figure><h2 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP地址是一个32位的二进制数，由四个八位字段组成。每个IP地址包括两部分：一部分为网络标识，一部分为主机标识。  </span><br><span class="line">IP又分为4大类，A类地址，B类地址，C类地址，D类地址</span><br></pre></td></tr></table></figure><h3 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h3><p>A类地址前8位为网络标识。后24位为主机标识。网段与主机数的计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">根据规定，A类地址的网络标识必须以“0”开头。</span><br><span class="line">那么其网段数应该为0XXXXXXX．YYYYYYYY．YYYYYYYY．YYYYYYYY即后面有七位数字，因为是二进制数，</span><br><span class="line">所以网段数应该为： 2^7，即2的7次幂个网段，等于128，即网段应该是0—127之间。</span><br><span class="line">而网络空间计算都必须“减2”，这是因为要扣除两个保留地址：二进制数里全是“0”和全是“1”的要保留。“0”做为网络号，“1”做为广播号。所以A类地址的网段为1—126. A类主机数计算： </span><br><span class="line">因为后面24位是主机标识，所以主机数应该是2^24，即2的24次幂 2^24&#x3D;16777216，扣除两个保留地址后，主机最大数应该是16777214个。</span><br><span class="line">综上所述，A类IP地址范围应该是：1.0.0.1~126.255.255.254  </span><br></pre></td></tr></table></figure><h3 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h3><p>A类地址前16位为网络标识。后16位为主机标识。网段与主机数的计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">根据规定，B类地址的网络标识必须以“10”开头。</span><br><span class="line">那么其网段数应该为10XXXXXX．XXXXXXXX．YYYYYYYY．YYYYYYYY即后面有14位数字，</span><br><span class="line">因为是二进制数，所以网段数应该为： </span><br><span class="line">2^14，即2的14次幂个网段，等于16384，扣除两个全“0”，全“1”的保留地址，所以B类网络可以有16382个网段。 </span><br><span class="line">而转换成十进制后， IP地址的第一个小数点前的数字区间应该是多少呢？因为第一段是10XXXXXX，所以应该是2^6个，</span><br><span class="line">即2的6次幂，等于64个。127是被保留网段暂不使用。</span><br><span class="line">B类网段应该是从128开始，所以128+64-1&#x3D;191.即十进制IP的第一段数字是在128—191之间。 </span><br><span class="line">B类主机数计算： </span><br><span class="line">因为后面16位是主机标识，所以主机数应该是2^16，即2的16次幂 2^16&#x3D;65536，扣除两个保留地址后，主机最大数应该是65534个。  </span><br><span class="line">综上所述，B类IP地址范围应该是：128.0.0.1~191.255.255.254  </span><br></pre></td></tr></table></figure><h3 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h3><p>A类地址前24位为网络标识。后8位为主机标识。网段与主机数的计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">根据规定，C类地址的网络标识必须以“110”开头。那么其网段数应该为110XXXXX．XXXXXXXX．XXXXXXXX．YYYYYYYY即后面有21位数字，因为是二进制数，所以网段数应该为： </span><br><span class="line">2^21，即2的21次幂个网段，等于2097152，扣除两个全“0”，全“1”的保留地址，所以B类网络可以有2097150个网段。 </span><br><span class="line">而转换成十进制后，IP地址的第一个小数点前的数字区间应该是多少呢？因为第一段是110XXXXX，所以应该是2^5个，即2的5次幂，等于32个。C类网段应该是从192开始</span><br><span class="line"></span><br><span class="line">所以192+32-1&#x3D;223。也就是说，十进制IP的第一位在192和223之间。C类主机计数：</span><br><span class="line">因为最后的8位是主机标识，所以主机的数目应该是2^8，也就是说，2的8次方是2^8&#x3D;256。扣除两个保留地址后，主机的最大数量应为254个。</span><br><span class="line">综上所述，C类IP地址范围应为192.0.0.1~223.255.255.254。</span><br></pre></td></tr></table></figure><h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址:"></a>私有地址:</h3><p>私有ip属于非注册地址，专门为组织机构内部使用。RFC1918定义了私有IP地址范围：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A: 10.0.0.0~10.255.255.255 即10.0.0.0&#x2F;8</span><br><span class="line">B: 172.16.0.0~172.31.255.255即172.16.0.0&#x2F;12</span><br><span class="line">C:192.168.0.0~192.168.255.255 即192.168.0.0&#x2F;16</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层协议简介</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>为用户提供服务通信活动</p><h1 id="常见的协议：http-websocket-dns，-smtp"><a href="#常见的协议：http-websocket-dns，-smtp" class="headerlink" title="常见的协议：http, websocket, dns， smtp"></a>常见的协议：http, websocket, dns， smtp</h1><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>特点: <strong>简单快速</strong>,<strong>灵活</strong>,<strong>无连接(链接一次就会断掉)</strong>,<strong>无状态(不能区分两边连接者的身份)</strong><br>一个请求的过程:域名解析-&gt;发起tcp三次握手-&gt;发送http请求-&gt;服务器响应http请求-&gt;浏览器解析响应<br>关于http协议是无状态协议是因为对于事务处理没有记忆能力。<br>缺少状态意味着如果后续处理需要前面的信息.所以需要通过Cookie或者session保存信息<br>相对于<code>http1.0</code>关于<code>http1.1</code>的优点:</p><ol><li>默认是<code>Connection: keep-alive</code>不会主动关闭连接</li><li>引入了管道机制(pipelining),即在同一个TCP连接里面,客户端可以同时发送多个请求<br>不过http1版本的协议缺点也很明显：头部内容携带过多，多个消息头都是重复的，在安全上都是明文传输，</li></ol><p>相对于<code>http1</code>关于<code>http2</code>的优点:</p><ol><li>安全上更优越，内容都是二进制传输也就是帧的形式发送</li><li>一个消息的多个帧可以无序发送，传输效率更快</li><li>多路复用，可以在一个tcp链接上承载多个双向数据流<br>缺点：http2只会建立一次tcp连接，连接上出现丢包现象就需要等待重传</li></ol><p>相对于<code>http2</code>关于<code>http3</code>的优点:</p><ol><li>基于udp进行链接的，不会因为丢包发生等待重传的事情</li></ol><h2 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h2><blockquote><p><strong>请求报文格式:</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: hacker.jp</span><br><span class="line">Connection: keep-alive（持久连接，减少通讯量的开销）</span><br><span class="line">Content-Type: applicaiton&#x2F;x-ww-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br><span class="line"></span><br><span class="line">name&#x3D;ueno&amp;age&#x3D;37</span><br></pre></td></tr></table></figure><blockquote><p><strong>响应报文格式:</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 VERY OK</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line">Content-Length: 355</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>关于请求方式:</strong><br>其中get和post的区别:</p><ol><li>get的发送数据是放在url的后面的</li><li>post是有body的，参数是放在body里的</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET 请求访问已经被URI识别的资源</span><br><span class="line">POST 传输实体主体</span><br><span class="line">PUT 传输文件</span><br><span class="line">DELETE 删除文件</span><br><span class="line">HEAD 获取报文首部</span><br><span class="line">OPTIONS 查询针对请求URI指定的资源支持方法</span><br><span class="line">TRACE 追踪路径</span><br><span class="line">CONNECT 要求用隧道协议链接代理</span><br><span class="line">LINK 建立与资源之间的联系</span><br><span class="line">UNLINK 断开连接关系</span><br></pre></td></tr></table></figure><blockquote><p><strong>常见状态码:</strong></p></blockquote><table><thead><tr><th>状态码</th><th>状态名称</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>ok</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建成功,请求并创建了新的资源</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替,也就是替换成了Location字段指定的URI</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。不管原请求是什么方法，重定向请求的方法都是 GET</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。协商缓存命中返回304.所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>307 的定义实际上和 302 是一致的，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上</td></tr><tr><td>308</td><td>permanent Redirect</td><td>永久重定向，308 的定义实际上和 301 是一致的，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr></tbody></table><h2 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h2><p>上面刚说完http的状态码，就不等不说浏览器的缓存机制了</p><ul><li>浏览器在加载资源时，根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。</li><li>如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过<code>last-modified</code>和<code>etag</code>验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源</li><li>如果前面两者都没有命中，直接从服务器加载资源<blockquote><p>另外解释以下<code>expires</code>,<code>cache-control</code>,<code>etag</code>,<code>last-modified</code>.这几个字段:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># expires</span><br><span class="line">Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。</span><br><span class="line">Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</span><br><span class="line"></span><br><span class="line"># Cache-Control</span><br><span class="line">Cache-Control 出现于 HTTP &#x2F; 1.1，优先级高于 Expires ,表示的是相对时间</span><br><span class="line"></span><br><span class="line"># Last-Modified，If-Modified-Since</span><br><span class="line">Last-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），</span><br><span class="line">询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</span><br><span class="line"></span><br><span class="line"># ETag、If-None-Match</span><br><span class="line">Etag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的</span><br><span class="line">If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来</span><br><span class="line"></span><br><span class="line"># 关于etag</span><br><span class="line">当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。</span><br><span class="line"></span><br><span class="line">情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。</span><br><span class="line"></span><br><span class="line">情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间和Etag</span><br><span class="line">然后进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag判断文件内容自上一次请求之后有没有发生变化</span><br><span class="line"></span><br><span class="line">情形三：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，</span><br><span class="line">直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。</span><br><span class="line"></span><br><span class="line">情形四：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①</span><br><span class="line">① 只有get请求会被缓存，post请求不会</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="http优化："><a href="#http优化：" class="headerlink" title="http优化："></a>http优化：</h2></li></ul><ol><li>利用负载均衡优化和加速HTTP应用</li><li>利用HTTP Cache来优化网站</li></ol><h2 id="关于https"><a href="#关于https" class="headerlink" title="关于https"></a>关于https</h2><p>对称加密算法加密数据+非对称加密算法交换秘钥+数字证书验证身份<br>对称加密数据：发送发的报文通过ssl加密，接收方通过ssl套接字进行解密<br>下面是https协议的加密过程:<br><img src="http://121.5.231.10:3000/computerNetwork/https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B.png" alt="https加密过程"><br>下面是https的ssl过程:<br><img src="http://121.5.231.10:3000/computerNetwork/https%E7%9A%84ssl%E8%BF%87%E7%A8%8B.png" alt="https加密过程"></p><h2 id="https的通讯方式"><a href="#https的通讯方式" class="headerlink" title="https的通讯方式"></a>https的通讯方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">客户端发送请求</span><br><span class="line">服务端向客户端发送数字证书</span><br><span class="line">客户端验证数字证书，验证成功生成一个会话秘钥</span><br><span class="line">服务器拿到会话秘钥然后用自己的私钥解密</span><br><span class="line">客户端与服务端进行加密通讯</span><br><span class="line"></span><br><span class="line">大白话就是数字证书保证了：</span><br><span class="line">1. 客户端这边能造一个箱子然后这个箱子可以用服务端的🔑 打开也可以用自己的公钥打开。</span><br><span class="line">2. 客户端确认服务端就是自己要找的那个人，身份是对的</span><br><span class="line">其中:这个箱子就是指对数据进行加密和解密的编码算法(随机对称密钥)，这种编码算法可以对数据进行加密和解密.服务端的🔑 就是指服务端的秘钥</span><br></pre></td></tr></table></figure><h2 id="https的ssl过程"><a href="#https的ssl过程" class="headerlink" title="https的ssl过程"></a>https的ssl过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</span><br><span class="line">（2）Web服务器收到客户端请求后，会生成一对公钥和私钥，并把公钥放在证书中发给客户端浏览器。</span><br><span class="line">（3）客户端判断证书是否有效，无效弹出警告，有效生成一个随机值。并用证书的公钥对随机值进行加密</span><br><span class="line">    加密后的随机值称为密钥，发送给服务端。</span><br><span class="line">（4）Web服务器用私钥解密密钥。然后用该密钥加密数据。发送给客户端</span><br><span class="line">（5）客户端用密钥解密数据</span><br></pre></td></tr></table></figure><h2 id="关于dns解析过程"><a href="#关于dns解析过程" class="headerlink" title="关于dns解析过程"></a>关于dns解析过程</h2><p>浏览器搜索自己的dns缓存-》查询wins服务器-》进行广播查找-》读取host文件</p><h2 id="dns查询过程"><a href="#dns查询过程" class="headerlink" title="dns查询过程"></a>dns查询过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请求主机首先向本地DNS服务器查询目标域名，</span><br><span class="line">首先查看本地缓存是否有目标域名的IP地址列表</span><br><span class="line">否则查看本地DNS服务器没有目标域名的IP地址列表(即目标域名在该服务器上)</span><br><span class="line">否则本地DNS服务器向跟DNS服务器获取该域名的TLD(域名后面的后缀.cn&#x2F;.edu&#x2F;etc)的IP地址列表</span><br><span class="line">然后本地DNS服务器向TLD DNS服务器 发送查询报文</span><br><span class="line">最后获得了该域名所在的权威DNS服务器所在地址，并向它做查询，获得到该ip地址的响应报文</span><br></pre></td></tr></table></figure><h2 id="关于smtp协议"><a href="#关于smtp协议" class="headerlink" title="关于smtp协议"></a>关于smtp协议</h2><p>smtp是邮箱访问协议，它是一个推送协议，只能够进行下面的操作：</p><ol><li>将邮件从发送方的邮件服务器传输到接收方的邮件服务器</li><li>将邮件从发送方的用户代理传送到发送方的邮件服务器<br>所以当接收方的用户代理想要从接收方的邮件服务器获取邮件需要用到下面的协议<br>pop3(第三版的邮局协议) 或 imap(因特网邮件访问协议) 或 http协议</li></ol><h2 id="websocket协议"><a href="#websocket协议" class="headerlink" title="websocket协议"></a>websocket协议</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP协议通信只能由客户端发起，于是有了websocket进行p2p的模式。</span><br><span class="line">websocket协议是向网络发送报文和从网络接收报文的软件接口</span><br><span class="line">特点：</span><br><span class="line">1. 数据格式比较轻量，性能开销小，通信高效。</span><br><span class="line">2. 可以发送文本，也可以发送二进制数据。</span><br><span class="line">3. 没有同源限制，客户端可以与任意服务器通信。</span><br><span class="line">4. 协议标识符是ws（如果加密，则为wss），服务器网址就是URL。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基本概要简介</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边缘部分：互联网上的主机(端系统), 主机是为用户进行信息处理</span><br><span class="line">核心部分: 网络与连接网络的路由器,路由器是用来转发分组的</span><br><span class="line">边缘部分端系统之间的通信方式：</span><br><span class="line">1. 客户-服务器</span><br><span class="line">2. 对等连接(p2p)</span><br><span class="line">核心部分的通信方式：</span><br><span class="line">1. 电路交换: 电话机与交换机（源点直达终点）</span><br><span class="line">2. 分组交换: 运用存储转发技术，将报文分组并为每个分组加入包含控制信息的首部构成包。(将包传送到邻接点)</span><br><span class="line">3. 报文交换: 电报通讯(将报文传送到邻接点)</span><br></pre></td></tr></table></figure><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交换机有时被称为多端口网桥,应用在链路层</span><br><span class="line">基于MAC地址识别，能完成封装转发数据帧功能的网络设备。</span><br><span class="line">交换机可以“学习”MAC地址，并把其存放在内部地址表中，</span><br><span class="line">通过在数据帧的始发者和目标接收者之间建立临时的交换路径，</span><br><span class="line">使数据帧直接由源地址到达目的地址。</span><br><span class="line">因为可以同一时刻可进行多个端口对之间的数据传输，所以提高了网络带宽</span><br></pre></td></tr></table></figure><h1 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">网卡是工作在链路层的网络组件,是局域网中连接计算机和传输介质的接口</span><br><span class="line">不仅能实现与局域网传输介质之间的物理连接和电信号匹配，</span><br><span class="line">还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码</span><br><span class="line">以及数据缓存的功能等。总之将双绞线中的电信号转为二进制的数据信号</span><br></pre></td></tr></table></figure><h1 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 速率：</span><br><span class="line">&gt; 带宽：（单位时间内，某信道能通过的最大数据率）</span><br><span class="line">&gt; 吞吐量：</span><br><span class="line">&gt; 时延：(发送时延，传播时延，处理时延，排队时延)</span><br><span class="line">&gt; 时延带宽积（传播时延 * 带宽）</span><br><span class="line">&gt; 往返时间RTT</span><br><span class="line">&gt; 利用率</span><br></pre></td></tr></table></figure><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法,语义,同步</span><br></pre></td></tr></table></figure><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 应用层：为用户提供服务的通信的活动</span><br><span class="line">&gt; 传输层：处于网络连接中的两台计算机之间的数据传输</span><br><span class="line">&gt; 网络层：处理网络上的流动数据包</span><br><span class="line">&gt; 链路层：链接网络的硬件部分（操作系统，网卡，光纤）</span><br><span class="line">&gt; 物理层</span><br><span class="line">网络中数据传输的变化: http报文-&gt;用户数据报(报文段)-&gt;包-&gt;帧</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpu调度</title>
      <link href="2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cpu%E8%B0%83%E5%BA%A6/"/>
      <url>2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cpu%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="本次讲解CPU调度常见概念，CPU调度算法以及特点"><a href="#本次讲解CPU调度常见概念，CPU调度算法以及特点" class="headerlink" title="本次讲解CPU调度常见概念，CPU调度算法以及特点"></a>本次讲解CPU调度常见概念，CPU调度算法以及特点</h1><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="cpu调度决策发生的情况："><a href="#cpu调度决策发生的情况：" class="headerlink" title="cpu调度决策发生的情况："></a>cpu调度决策发生的情况：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（就绪状态 &lt;- 运行状态 &lt;-&gt; 等待状态）</span><br><span class="line">a 当一个进程从运行态到等待状态 (请求)</span><br><span class="line">b 运行状态到就绪状态 （中断）</span><br><span class="line">c 等待状态到运行态</span><br><span class="line">d 一个进程终止</span><br><span class="line"></span><br><span class="line">b&amp;c是抢占，a&amp;d是非抢占</span><br></pre></td></tr></table></figure><h2 id="调度准则："><a href="#调度准则：" class="headerlink" title="调度准则："></a>调度准则：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cpu使用率： cpu利用时间 &#x2F; 开机运行时间</span><br><span class="line">吞吐量 （单位时间内可以完成的进程数量）</span><br><span class="line">周转时间 （进程提交到完成所需要的总时间）</span><br><span class="line">等待时间 （进程在就绪队列中等待所花费的总时间）</span><br><span class="line">响应时间 （提交请求道第一响应的时间）</span><br><span class="line"></span><br><span class="line">带权周转时间是指作业周转时间与作业实际运行时间的比值</span><br><span class="line">带权周转时间 &#x3D; 作业周转时间 &#x2F; 作业实际运行时间</span><br></pre></td></tr></table></figure><h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="先到先服务（FCFS）："><a href="#先到先服务（FCFS）：" class="headerlink" title="先到先服务（FCFS）："></a>先到先服务（FCFS）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">处于就绪态的进程按先后顺序链入到就绪队列中，</span><br><span class="line">而FCFS调度算法按就绪进程进入就绪队列的先后次序选择当前最先进入就绪队列的进程来执行</span><br><span class="line">直到此进程阻塞或结束，才进行下一次的进程选择调度。</span><br><span class="line">FCFS调度算法采用的是不可抢占的调度方式，一旦一个进程占有处理机</span><br><span class="line">就一直运行下去，直到该进程完成其工作，或因等待某一事件而不能继续执行时，才释放处理机。</span><br></pre></td></tr></table></figure><h2 id="最短作业优先调度（SJF）："><a href="#最短作业优先调度（SJF）：" class="headerlink" title="最短作业优先调度（SJF）："></a>最短作业优先调度（SJF）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法</span><br><span class="line">短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，</span><br><span class="line">将它们调入内存运行。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，</span><br><span class="line">将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</span><br><span class="line"></span><br><span class="line">（1）SRTF抢占式：又称最短剩余优先，当新进来的进程的CPU区间比当前执行的进程所剩的CPU区间短，则抢占。</span><br><span class="line"></span><br><span class="line">（2）非抢占：称为下一个最短优先，因为在就绪队列中选择最短CPU区间的进程放在队头。</span><br><span class="line"></span><br><span class="line">SJF调度算法的特点是吞吐率高，平均等待时间、平均周转时间最少；但算法对长作业十分不利，也完全未考虑作业的紧迫程度。</span><br></pre></td></tr></table></figure><h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><h2 id="时间片轮转调度（RR）"><a href="#时间片轮转调度（RR）" class="headerlink" title="时间片轮转调度（RR）"></a>时间片轮转调度（RR）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">适用于分时系统，系统将所有的就绪进程按照到达时间的先后顺序排成一个队列</span><br><span class="line">进程调度程序总是选择就绪队列中第一个进程执行，即先到先服务的原则。</span><br><span class="line">但仅能运行一个时间片。在使用完第一个时间片后，即使进程并没完成其运行</span><br><span class="line">他也必须释放出处理机给下一个就绪的进程。而被捕哦多的进程返回到就绪队列</span><br><span class="line">的末尾重新排队，等待再次运行。</span><br><span class="line"></span><br><span class="line">在时间片轮转调度算法中，时间片的大小对系统性能的影响很大，如果时间足够大。</span><br><span class="line">则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大</span><br><span class="line"></span><br><span class="line">时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。</span><br><span class="line"></span><br><span class="line">时间片q &#x3D; 系统对相应时间的要求RT &#x2F; 最大进程数N</span><br><span class="line"></span><br><span class="line">（经验表明，时间片的取值，应该使得80%的进程在时间内完成所需的一次CPU运行活动。）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多级反馈队列调度（MLFQ）"><a href="#多级反馈队列调度（MLFQ）" class="headerlink" title="多级反馈队列调度（MLFQ）"></a>多级反馈队列调度（MLFQ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">设置多个就绪队列，并为各个队列赋予不同的优先级。</span><br><span class="line">第一个队列的优先级最高，第二队次之，其余队列优先级依次降低。</span><br><span class="line">仅当第1～i-1个队列均为空时，操作系统调度器才会调度第i个队列中的进程运行</span><br><span class="line">在优先级越高的队列中，每个进程的执行时间片就越小或越大</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当一个就绪进程需要链入就绪队列时，操作系统首先将它放入第一队列的末尾，</span><br><span class="line">按FCFS的原则排队等待调度。若轮到该进程执行且在一个时间片结束时尚未完成</span><br><span class="line">，则操作系统调度器便将该进程转入第二队列的末尾，再同样按先来先服务原则等待调度执行。</span><br><span class="line">如此下去，当一个长进程从第一队列降到最后一个队列后，在最后一个队列中，</span><br><span class="line">可使用FCFS或RR调度算法来运行处于此队列中的进程。</span><br><span class="line"></span><br><span class="line">如果处理机正在第i（i&gt;1）队列中为某进程服务时，</span><br><span class="line">又有新进程进入第k（k&lt;i）的队列，则新进程将抢占正在运行进程的处理机，</span><br><span class="line">即由调度程序把正在执行进程放回第i队列末尾，</span><br><span class="line">重新将处理机分配给处于第k队列的新进程。</span><br></pre></td></tr></table></figure><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">假设系统中有3个反馈队列Q1,Q2,Q3，时间片分别为2，4，8。 [1]</span><br><span class="line">设有3个作业J1,J2,J3分别在时间 0 ，1，3时刻到达。而它们所需要的CPU时间分别是3，2，1个时间片。</span><br><span class="line">1、时刻0 J1到达。于是进入到队列1 ， 运行1个时间片 ， 时间片还未到，此时J2到达。</span><br><span class="line">2、时刻1 J2到达。 由于同一队列采用先来先服务，于是J2等待。 J1在运行了1个时间片后，已经完成了在Q1中的2个时间片的限制，于是J1置于Q2等待被调度。当前处理机分配给J2。</span><br><span class="line">3、时刻2 J1进入Q2等待调度，J2获得CPU开始运行。</span><br><span class="line">4、时刻3 J3到达，由于同一队列采用先来先服务，故J3在Q1等待调度，J1也在Q2等待调度。</span><br><span class="line">5、时刻4 J2处理完成，由于J3，J1都在等待调度，但是J3所在的队列比J1所在的队列的优先级要高，于是J3被调度，J1继续在Q2等待。</span><br><span class="line">6、时刻5 J3经过1个时间片，完成。</span><br><span class="line">7、时刻6 由于Q1已经空闲，于是开始调度Q2中的作业，则J1得到处理器开始运行。 J1再经过一个时间片，完成了任务。于是整个调度过程结束。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件管理</title>
      <link href="2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="文件管理系统的功能"><a href="#文件管理系统的功能" class="headerlink" title="文件管理系统的功能"></a>文件管理系统的功能</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件系统的管理功能是通过把它所管理的程序和数据组织成一系列文件的方法来实现的。</span><br><span class="line">可以把数据组成分为数据项、记录、文件。</span><br><span class="line"></span><br><span class="line">当前OS所提供的大多数对文件的操作，</span><br><span class="line">其过程大致都是这样两步：首先，检索文件目录来找到指定文件的属性及其在外存上的位置；</span><br><span class="line">然后，对文件实施相应的操作，如读&#x2F;写文件等，当用户要求对一个文件实施多次读&#x2F;写或其他操作时，</span><br><span class="line">每次都要从检索目录开始，为了避免多次重复地检索目录，</span><br><span class="line">在大多数OS中都引入了打开这一文件系统调用，当用户第一次请求对某文件系统进行操作时，</span><br><span class="line">先利用open系统调用将该文件打开。</span><br></pre></td></tr></table></figure><h1 id="文件的逻辑结构：无结构文件-流式文件-和有结构文件-记录式文件"><a href="#文件的逻辑结构：无结构文件-流式文件-和有结构文件-记录式文件" class="headerlink" title="文件的逻辑结构：无结构文件(流式文件)和有结构文件(记录式文件)"></a>文件的逻辑结构：无结构文件(流式文件)和有结构文件(记录式文件)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构是从实现观点出发，又称为文件的存储结构，是指文件在外存上的存储组织形式。</span><br><span class="line">文件的逻辑结构与存储介质特性无关，但文件的物理结构与存储介质的特性有很大关系。</span><br><span class="line">按逻辑结构，文件有无结构文件和有结构文件两种类型：无结构文件和有结构文件。</span><br></pre></td></tr></table></figure><h1 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无结构文件是最简单的文件组织形式。无结构文件将数据按顺序组织成记录并积累保存，</span><br><span class="line">它是有序相关信息项的集合，以字节(Byte)为单位。由于无结构文件没有结构，因而对记录的访问只能通过穷举搜索的方式，故这种文件形式对大多数应用不适用。但字符流的无结构文件管理简单，用户可以方便地对其进行操作。所以，那些对基本信息单位操作不多的文件较适于釆用字符流的无结构方式，如源程序文件、目标代码文件等。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">顺序文件:</span><br><span class="line">文件中的记录一个接一个地顺序排列，记录可以是定长的或变长的，可以顺序存储或以链表形式存储，</span><br><span class="line"></span><br><span class="line">索引文件:</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要包括虚地址、地址变换、内存分配和回收、内存扩充、内存共享和保护等功能。</span><br><span class="line">连续分配是指为一个用户程序分配连续的内存空间。连续分配有单一连续存储管理和分区式储管理两种方式</span><br></pre></td></tr></table></figure><h2 id="内存分配的方式"><a href="#内存分配的方式" class="headerlink" title="内存分配的方式"></a>内存分配的方式</h2><h3 id="单一连续存储管理"><a href="#单一连续存储管理" class="headerlink" title="单一连续存储管理"></a>单一连续存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。</span><br><span class="line">其特点是，最简单，适用于单用户、单任务的操作系统。</span><br><span class="line">CP／M和 DOS 2．0以下就是采用此种方式。这种方式的最大优点就是易于管理。</span><br></pre></td></tr></table></figure><h3 id="分区式存储管理"><a href="#分区式存储管理" class="headerlink" title="分区式存储管理"></a>分区式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分区式存储管理是把内存分为一些大小相等或不等的分区，</span><br><span class="line">操作系统占用其中一个分区，其余的分区由应用程序使用，</span><br><span class="line">每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，</span><br><span class="line">但难以进行内存分区的共享。</span><br></pre></td></tr></table></figure><h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">固定式分区的特点是把内存划分为若干个固定大小的连续分区。</span><br><span class="line">分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：</span><br></pre></td></tr></table></figure><h3 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，</span><br><span class="line">则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，</span><br><span class="line">而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。</span><br><span class="line">动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。</span><br><span class="line"></span><br><span class="line">最先适配法(nrst-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。</span><br><span class="line">该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。</span><br><span class="line"></span><br><span class="line">下次适配法(循环首次适应算法 next fit)：按分区在内存的先后次序，从上次分配的分区起查找(到最后&#123;区时再从头开始&#125;，</span><br><span class="line">找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。</span><br><span class="line"></span><br><span class="line">最佳适配法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。</span><br><span class="line">从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。</span><br><span class="line"></span><br><span class="line">最坏适配法(worst- fit)：按分区在内存的先后次序从头查找，</span><br><span class="line">找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。</span><br></pre></td></tr></table></figure><h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">固定分区和动态分区的折中方法</span><br><span class="line">当需要为进程分配一个长度为n的存储空间时:</span><br><span class="line">首先计算一个 i 值，使 2 ^ (i－1) &lt; n ≤ 2 ^ i，</span><br><span class="line">然后在空闲分区大小为2 ^ i的空闲分区链表中查找。</span><br><span class="line">若找到，即把该空闲分区分配给进程。</span><br><span class="line">否则，表明长度为2 ^ i的空闲分区已经耗尽，则在分区大小为2 ^ (i ＋ 1)的空闲分区链表中寻找。</span><br><span class="line">若存在 2 ^ (i ＋ 1)的一个空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙伴，其中的一个分区用于配，</span><br><span class="line">而把另一个加入分区大小为2 ^ i的空闲分区链表中。</span><br><span class="line">若大小为2 ^ (i ＋ 1)的空闲分区也不存在，则需要查找大小为2 ^ (i ＋ 2)的空闲分区， 若找到则对其进行两次分割：</span><br><span class="line">第一次，将其分割为大小为 2 ^ (i ＋ 1)的两个分区，一个用于分配，一个加入到大小为 2^(i ＋ 1)的空闲分区链表中；</span><br><span class="line">第二次，将第一次用于分配的空闲区分割为 2^i的两个分区，一个用于分配，一个加入到大小为 2^i的空闲分区链表中。</span><br><span class="line">若仍然找不到，则继续查找大小为 2 ^ (i ＋ 3)的空闲分区，以此类推。</span><br></pre></td></tr></table></figure><h3 id="内存紧缩（地址变换）"><a href="#内存紧缩（地址变换）" class="headerlink" title="内存紧缩（地址变换）"></a>内存紧缩（地址变换）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将各个占用分区向内存一端移动, 然后将各个空闲分区合并成为一个空闲分区。</span><br></pre></td></tr></table></figure><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引入覆盖 (overlay)技术的目标是在较小的可用内存中运行较大的程序。</span><br><span class="line">这种技术常用于多道程序系统之中，与分区式存储管理配合使用。</span><br></pre></td></tr></table></figure><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交换 (swapping)技术在多个程序并发执行时，可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程），</span><br><span class="line">或读人保存在外存中而处于就绪状态的程序。交换单位为整个进程的地址空间。交换技术常用于多道程序系统或小型分时系统中，</span><br><span class="line">因为这些系统大多采用分区存储管理方式。与分区式存储管理配合使用又称作“对换”或“滚进／滚出” (roll-in／roll-out)。</span><br><span class="line">暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），</span><br><span class="line">而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，</span><br><span class="line">并将该进程送到就绪队列（换入swap in）。</span><br></pre></td></tr></table></figure><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="页式和段式存储管理"><a href="#页式和段式存储管理" class="headerlink" title="页式和段式存储管理"></a>页式和段式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">地址空间：将源程序经过编译后得到的目标程序，</span><br><span class="line">存在于它所限定的地址范围内，这个范围称为地址空间。地址空间是逻辑地址的集合。</span><br><span class="line"></span><br><span class="line">存储空间：指主存中一系列存储信息的物理单元的集合，</span><br><span class="line">这些单元的编号称为物理地址存储空间是物理地址的集合。</span><br><span class="line"></span><br><span class="line">根据分配时所采用的基本单位不同，可将离散分配的管理方式分为以下三种：</span><br><span class="line">页式存储管理、段式存储管理和段页式存储管理。其中段页式存储管理是前两种结合的产物。</span><br></pre></td></tr></table></figure><h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">将程序的逻辑地址空间划分为固定大小的页(page)，</span><br><span class="line">而物理内存划分为同样大小的页框(page frame)。</span><br><span class="line">程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。</span><br><span class="line">该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。</span><br><span class="line">在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）</span><br><span class="line"></span><br><span class="line">没有外碎片，每个内碎片不超过页</span><br><span class="line">一个程序不必连续存放。</span><br><span class="line">便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。</span><br></pre></td></tr></table></figure><h3 id="页式管理的数据结构"><a href="#页式管理的数据结构" class="headerlink" title="页式管理的数据结构"></a>页式管理的数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在页式系统中，指令所给出的地址分为两部分：逻辑页号和页内地址。</span><br><span class="line">原理：</span><br><span class="line">CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，</span><br><span class="line">将物理页框号与页内地址相加形成物理地址</span><br><span class="line">逻辑页号，页内偏移地址－&gt;查进程页表，得物理页号－&gt;物理地址</span><br><span class="line"></span><br><span class="line">若给定一个逻辑地址为A，页面大小为L，则</span><br><span class="line">页号P&#x3D;INT[A&#x2F;L]，页内地址W&#x3D;A  MOD  L</span><br><span class="line">物理地址：物理块号 * 页面大小+ 页内偏移&#x3D; 28683</span><br></pre></td></tr></table></figure><h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">页面是主存物理空间中划分出来的等长的固定区域。分页方式的优点是页长固定，因而便于构造页表、易于管理，且不存在外碎片。</span><br><span class="line">但分页方式的缺点是页长与程序的逻辑大小不相关。例如，某个时刻一个子程序可能有一部分在主存中，另一部分则在辅存中。</span><br><span class="line">这不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。</span><br><span class="line"></span><br><span class="line">另一种划分可寻址的存储空间的方法称为分段。段是按照程序的自然分界划分的长度可以动态改变的区域。</span><br><span class="line">通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。</span><br><span class="line"></span><br><span class="line">作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例程序段、数据段等。每个段都从0开始编址，</span><br><span class="line">并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。</span><br><span class="line">整个作业的地址空间是二维的。</span><br><span class="line"></span><br><span class="line">每个程序设置一个段表，段表的每一个表项对应一个段，每个表项至少包括三个字段：</span><br><span class="line">有效位（指明该段是否已经调入主存）、段起址(该段在实存中的首地址)和段长（记录该段的实际长度）。</span><br><span class="line"></span><br><span class="line">绝对地址&#x3D;根据段号找到段表中的起始地址+段内地址 (如果段内地址超过限长则产生“地址越界”程序性中断事件达到存储保护)</span><br></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">已知逻辑空间地址为2^m个字节（也就是说逻辑地址的长度是m位），</span><br><span class="line">已知页大小是2^n字节。那么一共可以有2^(m-n)个页。</span><br><span class="line">因此页码部分会占m-n位，之后的n位，用来存储页偏移。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举个例子， 页大小为4B，而逻辑内存为32B（8页），</span><br><span class="line">逻辑地址0的页号为0，页号0对应帧5，</span><br><span class="line">因此逻辑地址映射为物理地址5*4+0&#x3D;20。逻辑地址3映射物理地址5*4+3&#x3D;23。</span><br><span class="line">逻辑地址13(4*3+1，页号为3，偏移为1，因为帧号为5)，映射到物理地址21。</span><br><span class="line">13 &#x2F; 4 &#x3D; 3</span><br><span class="line">13 mod 4 &#x3D; 1</span><br><span class="line">5 * 4 + 1 &#x3D; 21</span><br><span class="line"></span><br><span class="line">页式的逻辑地址是连续的，段式的逻辑地址可以不连续</span><br><span class="line">页式的地址是一维的，段式的地址是二维的</span><br><span class="line">分页是操作系统进行的，分段是用户确定的</span><br><span class="line"></span><br><span class="line">段页式管理中，地址映像表是每个进程一张段表，每个段一张页表</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程和协程</title>
      <link href="2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/"/>
      <url>2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程的出现是为了更好的利用CPU资源使到并发成为可能。</span><br><span class="line">是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。</span><br><span class="line">进程是表示资源分配的的基本单位，又是调度运行的基本单位，是系统中的并发执行的单位。</span><br></pre></td></tr></table></figure><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。</span><br><span class="line">进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，</span><br><span class="line">保证程序执行的可再现性。一般进程同步的方法有这几种: **计时器**,**信号量**,**事件**,**互斥锁**.</span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行：初始化，P操作(-)和V操作(+)，</span><br><span class="line">这三种操作都是原子操作。P操作(-)可以用于阻塞一个进程，V操作(+)可以用于解除阻塞一个进程。</span><br><span class="line">一个信号量可以初始化为非负数,</span><br><span class="line">semWait操作使信号量s减1.若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。</span><br><span class="line">semSignal操作使信号量加1，若值大于或等于零，则被semWait操作阻塞的进程被解除阻塞。</span><br></pre></td></tr></table></figure><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">就绪→执行 调度程序选一个优先权最高的进程占有处理机；</span><br><span class="line">执行→就绪 处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。&#39;</span><br><span class="line">当前运行进程时间片用完；</span><br><span class="line">执行→阻塞 当前运行进程等待键盘输入，进入了睡眠状态；</span><br><span class="line">正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。</span><br><span class="line">阻塞→就绪</span><br><span class="line">I&#x2F;O操作完成，被中断处理程序唤醒。</span><br><span class="line">处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。</span><br></pre></td></tr></table></figure><h2 id="进程通讯"><a href="#进程通讯" class="headerlink" title="进程通讯"></a>进程通讯</h2><p>进程通讯的目的是：数据传输，共享数据，通知事件，资源共享，进程控制。通讯的方式有如下几种</p><h3 id="管道pipe"><a href="#管道pipe" class="headerlink" title="管道pipe"></a>管道pipe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">管道是一种半双工的通信方式，数据只能单向流动，</span><br><span class="line">而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</span><br></pre></td></tr></table></figure><h3 id="命名管道FIFO"><a href="#命名管道FIFO" class="headerlink" title="命名管道FIFO"></a>命名管道FIFO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</span><br></pre></td></tr></table></figure><h3 id="消息队列MessageQueue"><a href="#消息队列MessageQueue" class="headerlink" title="消息队列MessageQueue"></a>消息队列MessageQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。</span><br><span class="line">消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</span><br></pre></td></tr></table></figure><h3 id="共享存储SharedMemory"><a href="#共享存储SharedMemory" class="headerlink" title="共享存储SharedMemory"></a>共享存储SharedMemory</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">共享内存就是映射一段能被其他进程所访问的内存，</span><br><span class="line">这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的**IPC**方式，</span><br><span class="line">它是针对其他进程间通信方式运行效率低而专门设计的。</span><br><span class="line">它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</span><br></pre></td></tr></table></figure><h3 id="信号量Semaphore："><a href="#信号量Semaphore：" class="headerlink" title="信号量Semaphore："></a>信号量Semaphore：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</span><br><span class="line">它常作为一种锁机制，防止某进程正在访问共享资源时，</span><br><span class="line">其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</span><br></pre></td></tr></table></figure><h3 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</span><br></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</span><br></pre></td></tr></table></figure><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。</span><br><span class="line">一个线程只能属于一个进程，但是一个进程可以拥有多个线程。</span><br><span class="line">多线程处理就是允许一个进程中在同一时刻执行多个任务。</span><br><span class="line">线程是一种轻量级的进程，与进程相比，线程给操作系统带来侧创建、维护、和管理的负担要轻，意味着线程的代价或开销比较小。</span><br><span class="line">线程没有地址空间，线程包含在进程的地址空间中。线程上下文只包含一个堆栈、一个寄存器、一个优先权，</span><br><span class="line">线程文本包含在他的进程的文本片段中，进程拥有的所有资源都属于线程。所有的线程共享进程的内存和资源。</span><br><span class="line">同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。</span><br><span class="line">但是每个线程拥有自己的栈段， 寄存器的内容，栈段又叫运行时段，用来存放所有局部变量和临时变量。</span><br><span class="line">父和子进程使用进程间通信机制，同一进程的线程通过读取和写入数据到进程变量来通信。</span><br><span class="line">进程中任何线程都可以通过销毁主线程来销毁进程，销毁主线程将导致该进程的销毁，对主线程的修改可能影响所有的线程。</span><br></pre></td></tr></table></figure><h1 id="进程与线程共同点"><a href="#进程与线程共同点" class="headerlink" title="进程与线程共同点:"></a>进程与线程共同点:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程和线程都有ID&#x2F;寄存器组、状态和优先权、信息块，创建后都可更改自己的属性，</span><br><span class="line">都可与父进程共享资源、都不能直接访问其他无关进程或线程的资源。</span><br></pre></td></tr></table></figure><h1 id="协程："><a href="#协程：" class="headerlink" title="协程："></a>协程：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个程序可以包含多个协程，可以对比与一个进程包含多个线程，</span><br><span class="line">因而下面我们来比较协程和线程。我们知道多个线程相对独立，</span><br><span class="line">有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，</span><br><span class="line">但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。</span><br></pre></td></tr></table></figure><h1 id="并行："><a href="#并行：" class="headerlink" title="并行："></a>并行：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">并行就是指同一时刻有两个或两个以上的“工作单位”在同时执行，</span><br><span class="line">从硬件的角度上来看就是同一时刻有两条或两条以上的指令处于执行阶段。</span><br><span class="line">所以，多核是并行的前提</span><br></pre></td></tr></table></figure><h1 id="并发："><a href="#并发：" class="headerlink" title="并发："></a>并发：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使多个操作可以在重叠的时间段内进行</span><br></pre></td></tr></table></figure><h1 id="并行与并发的关系"><a href="#并行与并发的关系" class="headerlink" title="并行与并发的关系:"></a>并行与并发的关系:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并发的设计使到并发执行成为可能，而并行是并发执行的其中一种模式。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统简介</title>
      <link href="2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"/>
      <url>2021/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统:"></a>什么是操作系统:</h1><p>一个程序，管理计算机硬件，给应用程序提供一个环境</p><h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><ol><li>内存管理：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有的应用程序需要使用内存时都要向操作系统去申请和注册</span><br><span class="line">由操作系统的内存管理模块来分配内存给你使用</span><br><span class="line">保证内存使用不会冲突。</span><br></pre></td></tr></table></figure></li><li>进程调度：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作系统的进程调度模块负责在各个进程之间进行切换。</span><br></pre></td></tr></table></figure></li><li>硬件设备管理：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有了操作系统后操作系统本身会去控制各个硬件</span><br><span class="line">应用程序就不用考虑硬件的具体细节了。操作系统的硬件设备管理模块就是驱动模块。</span><br></pre></td></tr></table></figure></li><li>文件管理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件系统是管理存储设备的一种方式。存储设备是由很多个扇区组成的</span><br><span class="line">存储设备要以扇区为单位进行读写。如果没有文件系统，程序要自己去读写扇区，就得记得哪个文件在哪个扇区。</span><br><span class="line">有了文件系统之后我们人不用再关注扇区，人只用关注文件系统中的目录和文件名，而不用管这个文件在物理磁盘的哪个扇区</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式系列之行为性模式</title>
      <link href="2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A1%8C%E4%B8%BA%E6%80%A7%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A1%8C%E4%B8%BA%E6%80%A7%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>对在不同的对象之间划分责任和算法的抽象化，行为型模式不仅仅关注类和对象的结构，而且重点关注他们之间的相互作用，通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互</p><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个<br>算法的结构即可重定义该算法的某些特定步骤</p><blockquote><p>这个主要用在基类，比如你可以把公共的方法写进一个基类，这样就不需要重复实现功能了</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> template(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.operation1();</span><br><span class="line">        <span class="built_in">this</span>.hookMethod() &amp;&amp; <span class="built_in">this</span>.operation2();</span><br><span class="line">        <span class="built_in">this</span>.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> operation1(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;使用了方法operation1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> operation2(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;使用了方法operation2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> operation3(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;使用了方法operation3&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 钩子方法</span></span><br><span class="line">    <span class="keyword">protected</span> hookMethod(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClassA</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> operation2(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;对该方法operation2进行了修改再使用&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> operation3(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;对该方法operation3进行了修改再使用&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClassB</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖钩子方法</span></span><br><span class="line">    <span class="keyword">protected</span> hookMethod(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> class1: AbstractClass = <span class="keyword">new</span> ConcreteClassA();</span><br><span class="line">    <span class="keyword">const</span> class2: AbstractClass = <span class="keyword">new</span> ConcreteClassB();</span><br><span class="line"></span><br><span class="line">    class1.template();</span><br><span class="line">    class2.template();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求<br>排或者记录请求日志，可以提供命令的撤销和恢复功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Command &#123;</span><br><span class="line">    execute(): <span class="built_in">void</span>;</span><br><span class="line">    undo(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommandOn</span> <span class="title">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> receiver: Receiver;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">receiver: Receiver</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行命令的方法</span></span><br><span class="line">    <span class="keyword">public</span> execute(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver.actionOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销命令的方法</span></span><br><span class="line">    <span class="keyword">public</span> undo(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver.actionOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommandOff</span> <span class="title">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> receiver: Receiver;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">receiver: Receiver</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行命令的方法</span></span><br><span class="line">    <span class="keyword">public</span> execute(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver.actionOff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销命令的方法</span></span><br><span class="line">    <span class="keyword">public</span> undo(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver.actionOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空命令（省去判空操作）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="title">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> execute(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> undo(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> actionOn(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是命令接收者，开启了某动作&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> actionOff(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是命令接收者，关闭了某动作&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> onCommands: <span class="built_in">Array</span>&lt;Command&gt;;</span><br><span class="line">    <span class="keyword">private</span> offCommands: <span class="built_in">Array</span>&lt;Command&gt;;</span><br><span class="line">    <span class="keyword">private</span> undoCommand: Command;</span><br><span class="line">    <span class="keyword">private</span> slotNum: <span class="built_in">number</span> = <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.undoCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        <span class="built_in">this</span>.onCommands = [];</span><br><span class="line">        <span class="built_in">this</span>.offCommands = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.slotNum; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.onCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">            <span class="built_in">this</span>.offCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> setCommand(index: <span class="built_in">number</span>, <span class="attr">onCommand</span>: Command, <span class="attr">offCommand</span>: Command): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onCommands[index] = onCommand;</span><br><span class="line">        <span class="built_in">this</span>.offCommands[index] = offCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启</span></span><br><span class="line">    <span class="keyword">public</span> on(index: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onCommands[index].execute();<span class="comment">// 调用相应方法</span></span><br><span class="line">        <span class="comment">//记录这次操作，用于撤销</span></span><br><span class="line">        <span class="built_in">this</span>.undoCommand = <span class="built_in">this</span>.onCommands[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="keyword">public</span> off(index: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.offCommands[index].execute();</span><br><span class="line">        <span class="built_in">this</span>.undoCommand = <span class="built_in">this</span>.offCommands[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销</span></span><br><span class="line">    <span class="keyword">public</span> undo(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.undoCommand.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建接收者</span></span><br><span class="line">    <span class="keyword">const</span> receiver: Receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建命令</span></span><br><span class="line">    <span class="keyword">const</span> commandOn: Command = <span class="keyword">new</span> ConcreteCommandOn(receiver);</span><br><span class="line">    <span class="keyword">const</span> commandOff: Command = <span class="keyword">new</span> ConcreteCommandOff(receiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建调用者</span></span><br><span class="line">    <span class="keyword">const</span> invoker: Invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">    invoker.setCommand(<span class="number">0</span>, commandOn, commandOff);</span><br><span class="line"></span><br><span class="line">    invoker.on(<span class="number">0</span>);</span><br><span class="line">    invoker.off(<span class="number">0</span>);</span><br><span class="line">    invoker.undo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>定义一组算法，将每个算法都封装起来，并且使他们之间可以互换</p><blockquote><p>这个主要用在写测试类的时候，比如有8种排序算法，每次只需要改变当前的策略，即可实现相应的测试检查</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Strategy &#123;</span><br><span class="line">    <span class="comment">// 策略模式运算法则</span></span><br><span class="line">    doSomething(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> <span class="title">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> doSomething(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;使用的策略1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy2</span> <span class="title">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> doSomething(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;使用的策略2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextofStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _strategy: Strategy;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">strategy: Strategy</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">strategy</span>(<span class="params">strategy: Strategy</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装后的策略方法</span></span><br><span class="line">    doOperation(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._strategy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strategy1: Strategy = <span class="keyword">new</span> ConcreteStrategy1();</span><br><span class="line">    <span class="keyword">const</span> strategy2: Strategy = <span class="keyword">new</span> ConcreteStrategy2();</span><br><span class="line">    <span class="keyword">const</span> context: ContextofStrategy = <span class="keyword">new</span> ContextofStrategy(strategy1);</span><br><span class="line">    context.doOperation();</span><br><span class="line">    context.strategy = strategy2;</span><br><span class="line">    context.doOperation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>这个也是一个比较流行的模式，比如跟事件类有关的类。通过某一个事件，触发对该事件订阅的模型发生数据变化。</p><blockquote><p> 比如在一个游戏框架中，键盘和鼠标事件的触发，会使得全局订阅者集合中相对应的事件的订阅者触发自己的行为事件<br>又比如在mvvm模型中，Object.defineProperty中通过set方法调用的时候，会触发所有订阅这的更新</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Observer &#123;</span><br><span class="line">    update(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者模式</span></span><br><span class="line"><span class="keyword">interface</span> AbstractSubject &#123;</span><br><span class="line">    <span class="comment">// 注册订阅者</span></span><br><span class="line">    registerObserver(observer: Observer): <span class="built_in">void</span>;</span><br><span class="line">    remove(observer: Observer): <span class="built_in">void</span>;</span><br><span class="line">    <span class="comment">// 通知订阅者,让每个订阅者调用自己的update方法</span></span><br><span class="line">    notifyObservers(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="title">implements</span> <span class="title">AbstractSubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> observers: <span class="built_in">Array</span>&lt;Observer&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> registerObserver(observer: Observer): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.push(observer);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> remove(observer: Observer): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> observerIndex = <span class="built_in">this</span>.observers.findIndex(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value == observer;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        observerIndex &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.observers.splice(observerIndex, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> notifyObservers(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer.update())</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="title">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> update(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;已经执行更新操作1，值为&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="title">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> update(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;已经执行更新操作2，值为&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布订阅模式</span></span><br><span class="line"><span class="keyword">interface</span> Publish &#123;</span><br><span class="line">    registerObserver(eventType: <span class="built_in">string</span>, <span class="attr">subscribe</span>: Subscribe): <span class="built_in">void</span>;</span><br><span class="line">    remove(eventType: <span class="built_in">string</span>, subscribe?: Subscribe): <span class="built_in">void</span>;</span><br><span class="line">    notifyObservers(eventType: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SubscribesObject &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">Array</span>&lt;Subscribe&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePublish</span> <span class="title">implements</span> <span class="title">Publish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> subscribes: SubscribesObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subscribes = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registerObserver(eventType: <span class="built_in">string</span>, <span class="attr">subscribe</span>: Subscribe): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.subscribes[eventType]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.subscribes[eventType] = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.subscribes[eventType].push(subscribe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove(eventType: <span class="built_in">string</span>, subscribe?: Subscribe): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> subscribeArray = <span class="built_in">this</span>.subscribes[eventType];</span><br><span class="line">        <span class="keyword">if</span> (subscribeArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!subscribe) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="built_in">this</span>.subscribes[eventType];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subscribeArray.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (subscribe === subscribeArray[i]) &#123;</span><br><span class="line">                        subscribeArray.splice(i, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifyObservers(eventType: <span class="built_in">string</span>, ...args: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> subscribes = <span class="built_in">this</span>.subscribes[eventType];</span><br><span class="line">        <span class="keyword">if</span> (subscribes) &#123;</span><br><span class="line">            subscribes.forEach(<span class="function"><span class="params">subscribe</span> =&gt;</span> subscribe.update(...args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Subscribe &#123;</span><br><span class="line">    update(...value: <span class="built_in">any</span>[]): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubscribe1</span> <span class="title">implements</span> <span class="title">Subscribe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> update(...value: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;已经执行更新操作1，值为&#x27;</span>, ...value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubscribe2</span> <span class="title">implements</span> <span class="title">Subscribe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> update(...value: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;已经执行更新操作2，值为&#x27;</span>, ...value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> publish = <span class="keyword">new</span> ConcretePublish();</span><br><span class="line">    <span class="keyword">const</span> subscribe1 = <span class="keyword">new</span> ConcreteSubscribe1();</span><br><span class="line">    <span class="keyword">const</span> subscribe2 = <span class="keyword">new</span> ConcreteSubscribe2();</span><br><span class="line"></span><br><span class="line">    publish.registerObserver(<span class="string">&#x27;1&#x27;</span>, subscribe1);</span><br><span class="line">    publish.registerObserver(<span class="string">&#x27;2&#x27;</span>, subscribe2);</span><br><span class="line"></span><br><span class="line">    publish.notifyObservers(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;22222&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式系列之结构型模式</title>
      <link href="2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>为了解决怎样组装现有的类，设计他们的交互方式，从而实现一定的功能</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将一个类的接口变换为客户端所期待的另一个接口<br>从而使原本因接口不匹配而无法在一起工作的两个类能够一起工作<br>也就是说原本的类或者实例通过适配器的方式添加了新的功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口，定义了多种方法</span></span><br><span class="line"><span class="keyword">interface</span> Target &#123;</span><br><span class="line">    request(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> specificRequest(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配器给原类添加新的接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="title">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> request(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.specificRequest()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>动态的将新功能附加到对象上<br>装饰者模式也是一种非常常见的模式，其实也就是我们日常使用的装饰器，将公共的方法变成一个装饰方法或者装饰类。<br>这样就能简化代码量。</p><blockquote><p>比如在后端中每个接口都需要判断用户是否登录，可以写一个装饰方法定义用户的登录状态<br>这样每个需要判断用户登录态的接口直接用装饰器装饰即可。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> operate(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> method(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> operate(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.method()</span><br><span class="line">        <span class="built_in">super</span>.operate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>主要用来描述部分和整体的关系，将对象组合成树形结构表示部分-整体的结构层次</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> doOperation(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">public</span> add(component: Component): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> remove(component: Component): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> getChildren(): <span class="built_in">Array</span>&lt;Component&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> componentList: <span class="built_in">any</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">        <span class="built_in">this</span>.componentList = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> doOperation(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> add(component: Component): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentList.push(component)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> remove(component: Component): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> componentIndex = <span class="built_in">this</span>.componentList.findIndex(<span class="function">(<span class="params">value: Component, index: <span class="built_in">Number</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value == component;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.componentList.splice(componentIndex, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> getChildren(): <span class="built_in">Array</span>&lt;Component&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.componentList</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> doOperation(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root: Component = <span class="keyword">new</span> Composite(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> node1: Component = <span class="keyword">new</span> Leaf(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> node2: Component = <span class="keyword">new</span> Composite(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> node3: Component = <span class="keyword">new</span> Leaf(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    root.add(node1);</span><br><span class="line">    root.add(node2);</span><br><span class="line">    root.add(node3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> node2_1: Component = <span class="keyword">new</span> Leaf(<span class="string">&quot;2_1&quot;</span>);</span><br><span class="line">    node2.add(node2_1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> children1 = root.getChildren();</span><br><span class="line">    <span class="built_in">console</span>.log(children1);</span><br><span class="line"></span><br><span class="line">    root.remove(node2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> children2 = root.getChildren();</span><br><span class="line">    <span class="built_in">console</span>.log(children2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>为其他对象提供一种代理以控制对这个对象的询问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理</span></span><br><span class="line"><span class="keyword">interface</span> Subject &#123;</span><br><span class="line">    doOperation(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="title">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> doOperation(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;RealSubject running&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProxy</span> <span class="title">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> target: Subject;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">realSubject: Subject</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = realSubject</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">doOperation</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;proxy class&#x27;</span>)</span><br><span class="line">        <span class="built_in">this</span>.target.doOperation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> realSubject: Subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">    <span class="keyword">const</span> myProxy: Subject = <span class="keyword">new</span> MyProxy(realSubject);</span><br><span class="line"></span><br><span class="line">    myProxy.doOperation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式系列之创建型模式</title>
      <link href="2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>创建型模式就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。也就说对创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>一个类仅有一个实例，不管什么时候我们要确保该类的只有一个对象实例存在。</p><blockquote><p>这个在游戏中用的比较多，比如打砖块游戏中，在砖块类中和挡板类中都使用了小球这个类。<br>但是小球这个类的属性都是变化的，而小球只能是一个单独的实例。这个时候就需要单例模式</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> instance: Singleton = <span class="keyword">new</span> Singleton()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> getInstance(): Singleton &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>一个创建对象的类，这个类封装实例化对象行为</p><blockquote><p>这个在游戏中用的比较多，比如打飞机游戏中有多种飞机，可以用工厂模式创建相应的飞机实例</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Product &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1</span> <span class="title">implements</span> <span class="title">Product</span> </span>&#123; <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2</span> <span class="title">implements</span> <span class="title">Product</span> </span>&#123; <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> createProduct(<span class="keyword">type</span>: <span class="built_in">number</span>): Product &#123;</span><br><span class="line">        <span class="keyword">const</span> mp = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="keyword">new</span> Product1(),</span><br><span class="line">            <span class="number">2</span>: <span class="keyword">new</span> Product2()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[<span class="keyword">type</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模式, 定义了一个创建对象的抽象方法, 由子类决定实例化的类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> createProduct(<span class="keyword">type</span>: <span class="built_in">number</span>): Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> createProduct(<span class="keyword">type</span>: <span class="built_in">number</span>): Product &#123;</span><br><span class="line">        <span class="keyword">const</span> mp = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="keyword">new</span> Product1(),</span><br><span class="line">            <span class="number">2</span>: <span class="keyword">new</span> Product2()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[<span class="keyword">type</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sass用法大全</title>
      <link href="2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/sass%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
      <url>2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/sass%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这是一篇关于sass的语法大全</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="comment">/* 默认变量: */</span></span><br><span class="line"><span class="variable">$color</span>: <span class="number">#fff</span> !default;</span><br><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">2</span>;</span><br><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">1.5</span> !default;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="variable">$baseLineHeight</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">        <span class="selector-tag">header</span> &amp; &#123;</span><br><span class="line">            <span class="attribute">color</span>:green;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后的css代码：</span></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性嵌套"><a href="#属性嵌套" class="headerlink" title="属性嵌套"></a>属性嵌套</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: &#123;</span><br><span class="line">        top: <span class="number">1px</span> solid red;</span><br><span class="line">        <span class="attribute">bottom</span>: <span class="number">1px</span> solid green;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">编译后的css代码：</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明混合宏（复用的公共样式）"><a href="#声明混合宏（复用的公共样式）" class="headerlink" title="声明混合宏（复用的公共样式）"></a>声明混合宏（复用的公共样式）</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> border-radius(<span class="variable">$radius</span>: <span class="number">5px</span>)&#123;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@mixin</span> box-shadow(<span class="variable">$shadow</span>...) &#123;</span><br><span class="line">    <span class="comment">/* @if @else 用法 */</span></span><br><span class="line">    <span class="keyword">@if</span> length(<span class="variable">$shadow</span>) &gt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">@include</span> prefixer(box-shaow, <span class="variable">$shadow</span>);</span><br><span class="line">    &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="variable">$shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">4px</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">3</span>)</span><br><span class="line">        @include prefixer(box-shaow, <span class="variable">$shadow</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用混合宏"><a href="#调用混合宏" class="headerlink" title="调用混合宏"></a>调用混合宏</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> border-radius(<span class="number">3px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展和继承"><a href="#扩展和继承" class="headerlink" title="扩展和继承"></a>扩展和继承</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-primary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f36</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="keyword">@extend</span> .btn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sass-占位符"><a href="#sass-占位符" class="headerlink" title="[sass]占位符%"></a>[sass]占位符%</h2><p>编译出来的代码会将相同的代码合并在一起</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%mt5&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %mt5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %mt5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//   编译后的css代码：</span></span><br><span class="line"><span class="selector-class">.btn</span>, <span class="selector-class">.block</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其他-插值-逻辑运算-加减乘除"><a href="#其他-插值-逻辑运算-加减乘除" class="headerlink" title="其他(插值: #{}, 逻辑运算: 加减乘除)"></a>其他(插值: #{}, 逻辑运算: 加减乘除)</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$col-width</span>: <span class="number">60px</span>;</span><br><span class="line"><span class="variable">$col-gap</span>: <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* for循环</span></span><br><span class="line"><span class="comment">*@for $i from &lt;start&gt; through &lt;end&gt;</span></span><br><span class="line"><span class="comment">*@for $i from &lt;start&gt; to &lt;end&gt;</span></span><br><span class="line"><span class="comment">*through 表示包括 end 这个数，而 to 则不包括 end 这个数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">12</span> &#123;</span><br><span class="line">    <span class="selector-class">.col-</span>#&#123;<span class="variable">$i</span>&#125;&#123;</span><br><span class="line">        <span class="attribute">width</span>: (<span class="variable">$col-width</span> + <span class="variable">$col-gap</span>) * <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*列表 用()表示一组列表*/</span></span><br><span class="line"><span class="variable">$properties</span>: (margin, padding);</span><br><span class="line"><span class="keyword">@mixin</span> set-value(<span class="variable">$side</span>, <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="comment">/* each 遍历列表 */</span></span><br><span class="line">    <span class="keyword">@each</span> <span class="variable">$prop</span> in <span class="variable">$properties</span> &#123;</span><br><span class="line">        #&#123;<span class="variable">$prop</span>&#125;-#&#123;<span class="variable">$side</span>&#125;: <span class="variable">$value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.login-box</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> set-value(top, <span class="number">14px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> e(<span class="variable">$element</span>, <span class="variable">$content</span>) &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="string">&#x27;yellow&#x27;</span>;</span><br><span class="line">    &amp;__#&#123;<span class="variable">$element</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">        <span class="keyword">@each</span> <span class="variable">$k</span>, <span class="variable">$v</span> in <span class="variable">$content</span> &#123;</span><br><span class="line">            #&#123;<span class="variable">$k</span>&#125;: <span class="variable">$v</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@include e(<span class="string">&#x27;content&#x27;</span>, (<span class="string">&#x27;display&#x27;</span>: flex, <span class="string">&#x27;height&#x27;</span>: <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">/* while */</span><br><span class="line"><span class="variable">$types</span>: <span class="number">4</span>;</span><br><span class="line"><span class="variable">$type-width</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="keyword">@while</span> <span class="variable">$types</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="selector-class">.while-</span>#&#123;<span class="variable">$types</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">$type-width</span> + <span class="variable">$types</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$types</span>: <span class="variable">$types</span> - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*颜色可以相加*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    color: #010203 + #040506 /* #050709; */</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*函数*/</span></span><br><span class="line"><span class="keyword">@function</span> widthFn(<span class="variable">$n</span>) &#123;</span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$n</span> * <span class="variable">$twoWidth</span> + (<span class="variable">$n</span> - <span class="number">1</span>) * <span class="variable">$oneWidth</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 特殊函数</span></span><br><span class="line"><span class="comment">* unquote($string) 删除字符串中的引号</span></span><br><span class="line"><span class="comment">* quote($string) 给字符串添加引号</span></span><br><span class="line"><span class="comment">* to-upper-case() 字符串小写字母转换成大写字母</span></span><br><span class="line"><span class="comment">* to-lower-case() 字符串大写字母转换成小写字母</span></span><br><span class="line"><span class="comment">* percentage() 将一个不带单位的数字转换成百分比形式</span></span><br><span class="line"><span class="comment">* round() 函数可以将一个数四舍五入为一个最接近的整数</span></span><br><span class="line"><span class="comment">* ceil() 函数将一个数转换成最接近于自己的整数</span></span><br><span class="line"><span class="comment">* floor() 函数刚好与 ceil() 函数功能相反，其主要将一个数去除其小数部分</span></span><br><span class="line"><span class="comment">* abs() 函数会返回一个数的绝对值</span></span><br><span class="line"><span class="comment">* min()函数功能主要是在多个数之中找到最小的一个 min(1px,2,3px)</span></span><br><span class="line"><span class="comment">* random() 获取一个随机数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*列表函数</span></span><br><span class="line"><span class="comment">* nth($list,$n) 用来指定列表中某个位置的值</span></span><br><span class="line"><span class="comment">* join() 函数是将两个列表连接合并成一个列表 join (10px) (20px)</span></span><br><span class="line"><span class="comment">* length() 计算列表长度</span></span><br><span class="line"><span class="comment">* append() 用来将某个值插入到列表中，并且处于最末位</span></span><br><span class="line"><span class="comment">* index() 你找到某个值在列表中所处的位置 index(solid red, red)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html和css相关知识</title>
      <link href="2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/html%E5%92%8Ccss%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/html%E5%92%8Ccss%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="块格式化上下文-BFC"><a href="#块格式化上下文-BFC" class="headerlink" title="块格式化上下文(BFC)"></a>块格式化上下文(BFC)</h1><p>元素包含下面的css属性就会变成bfc元素</p><ul><li>浮动元素</li><li>绝对定位元素(position为absolute或fixed)</li><li>行内块元素(display: inline-block)</li><li>表格单元格(display: table-cell)</li><li>表格标题(display: table-caption)</li><li>overflow值不为visible的块元素</li><li>display值为<code>flow-root</code>的元素</li><li>contain 值为<code>layout</code>、<code>content</code>、<code>strict</code>的元素</li><li>弹性元素(display为flex 或 inline-flex元素的直接子元素)</li><li>网格元素(display为grid或inline-grid元素的直接子元素)</li><li>多列容器</li><li>column-span为all的元素始终会创建一个BFC</li></ul><h2 id="BFC元素会有下面这些特性"><a href="#BFC元素会有下面这些特性" class="headerlink" title="BFC元素会有下面这些特性"></a>BFC元素会有下面这些特性</h2><ol><li><strong>BFC元素和float元素不会叠加在一起</strong></li><li><strong>BFC元素的子元素如果是float元素，那么BFC元素会包住float元素</strong><ul><li>用于处理float子元素的内容能够撑开父元素</li></ul></li><li><strong>同一个BFC元素里面的相邻元素不会发生外边距叠加</strong></li></ol><h1 id="关于link和-import的区别"><a href="#关于link和-import的区别" class="headerlink" title="关于link和@import的区别"></a>关于link和@import的区别</h1><ol><li>@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。</li><li>加载顺序区别<br>加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</li><li>兼容性区别<br>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。</li><li>DOM可控性区别<br>可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。</li><li>权重区别(该项有争议，下文将详解)<br>link引入的样式权重大于@import引入的样式。</li></ol><h1 id="css-bem规范"><a href="#css-bem规范" class="headerlink" title="css bem规范"></a>css bem规范</h1><p>Bem 是块(block)、元素(element)、修饰符(modifier)的简写, 是一种css命名规范.<br>规范如下:</p><ul><li>block__element: 双下划线用来连接block与block的子元素</li><li>block–modifier: 双连接符用来修饰元素的状态或者版本</li><li>block-block: 单连接符用来连接两个block</li></ul><p>其实也就是写scss更加规范</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">1200px</span>;</span><br><span class="line">    &amp;__body &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &amp;--error &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">      &amp;__button &#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#e2e2e2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &amp;__button &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">8px</span>;</span><br><span class="line">        &amp;--primary &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">        &amp;--success &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><blockquote><p>在IE浏览器和其他浏览器里盒模型的定义是不一样的<br>IE浏览器中盒模型的宽高是内容和padding和border区域一起算的。也就是说 <code>box-sizing: border-box</code><br>默认其他浏览器中宽高是内容区域宽高. <code>box-sizing: content-box</code></p></blockquote><h2 id="盒模型的宽高计算"><a href="#盒模型的宽高计算" class="headerlink" title="盒模型的宽高计算"></a>盒模型的宽高计算</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dom.style.height/<span class="function"><span class="params">width</span> =&gt;</span> 只有内联样式设置后生效</span><br><span class="line">dom.currentStyle.width/<span class="function"><span class="params">height</span> =&gt;</span> ie的盒模型生效</span><br><span class="line">dom.getBoundingClientRect().width/<span class="function"><span class="params">height</span> =&gt;</span> ie or 其他浏览器</span><br><span class="line"><span class="built_in">window</span>.getComputedStyle(dom).width/<span class="function"><span class="params">height</span> =&gt;</span> 计算生效后的盒模型的宽高</span><br></pre></td></tr></table></figure><h1 id="各种元素"><a href="#各种元素" class="headerlink" title="各种元素"></a>各种元素</h1><ul><li><p>行内元素： span, img, input, button, select, textarea</p></li><li><p>块级元素： div, ul, li, dl, dt, h1-h6, blockquote</p></li><li><p>空元素（即没有内容的元素）input img  br hr link meta</p></li></ul><h1 id="关于offsetX-clientHeight等属性"><a href="#关于offsetX-clientHeight等属性" class="headerlink" title="关于offsetX, clientHeight等属性"></a>关于offsetX, clientHeight等属性</h1><p>不太好用文字表述，直接上图简单明了</p><p><img src="http://121.5.231.10:3000/html/offsetXY.png" alt="offsetX"></p><p><img src="http://121.5.231.10:3000/html/evntXY.png" alt="eventxy"></p><p><img src="http://121.5.231.10:3000/html/layerXY.png" alt="layerXY"></p><p><img src="http://121.5.231.10:3000/html/clientHeight.png" alt="clientHeight"></p>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域通信</title>
      <link href="2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/"/>
      <url>2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是同源策略及限制"><a href="#什么是同源策略及限制" class="headerlink" title="什么是同源策略及限制"></a>什么是同源策略及限制</h1><blockquote><p>如果两个uri的协议, 域名, 端口三者完全相同，就称之为同源。<br>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互<br>这是一个用于隔离潜在恶意文件的关键安全机制:</p><ol><li>cookie,localstorage,indexdb无法读取</li><li>dom无法获得</li><li>ajax请求不能发送</li></ol></blockquote><h2 id="跨域通信的几种方式"><a href="#跨域通信的几种方式" class="headerlink" title="跨域通信的几种方式"></a>跨域通信的几种方式</h2><ul><li>JSONP:  callback后面的参数是函数，返回的字段是函数的参数，原理src的元素不会被同源策略拦截(img, link, script这些元素)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不会被拦截，请求发送出去 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 比如服务端返回add(1, 2) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;a and b&#x27;</span>, a, b, a + b)&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:2000/api/todo/all/jsonp?callback=add&amp;param1=10&amp;param2=20&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/api/todo/all/jsonp&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> query = &#123; reqeust &#125;</span><br><span class="line">  <span class="keyword">let</span> &#123;callback, param1, param2&#125; = &#123; query &#125;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;param1&#125;</span>, <span class="subst">$&#123;param2&#125;</span>)`</span></span><br><span class="line">  response.send(s)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>Hash:  hash改变页面不刷新</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景: 当前页面a通过iframe嵌入了页面b</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;iframe&#x27;</span>)</span><br><span class="line">b.src = b.src + <span class="string">&#x27;#&#x27;</span> + <span class="string">&#x27;json.stringify(data)&#x27;</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> data = <span class="built_in">window</span>.location.hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>postMessage: 窗口A向窗口B发送信息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bwindow.postMessage(<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;http://B.com&#x27;</span>)</span><br><span class="line">Awindow.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  log(event.origin) <span class="comment">// http://A.com</span></span><br><span class="line">  log(event.source) <span class="comment">// Bwindow</span></span><br><span class="line">  log(event.data) <span class="comment">// data</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>WebSocket</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;wss://localhost:8080&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection open ...&quot;</span>);</span><br><span class="line">  ws.send(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">&quot;Received Message: &quot;</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>CORS</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;@koa/cors&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(cors(&#123;</span><br><span class="line">    origin: <span class="string">&#x27;*&#x27;</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>nginx配置</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">9000</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/host.access.log  main;</span><br><span class="line">    <span class="attribute">error_log</span>  /var/log/nginx/error.log  <span class="literal">error</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /api/ &#123;</span><br><span class="line">      <span class="attribute">rewrite</span>  /api/(.*)  /<span class="variable">$1</span>  <span class="literal">break</span>;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://49.234.21.254:8562;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="在跨域通讯的CORS方式中浏览器做了什么处理"><a href="#在跨域通讯的CORS方式中浏览器做了什么处理" class="headerlink" title="在跨域通讯的CORS方式中浏览器做了什么处理"></a>在跨域通讯的CORS方式中浏览器做了什么处理</h2><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request) 然后它会给请求报文和响应报文的头部添加一些字段</p><ul><li><p>简单请求, 同时满足以下两大条件</p><ul><li><p>请求方法是以下三种方法之一</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul></li><li><p>HTTP的头信息不超出以下几种字段</p><ul><li><p>Accept</p></li><li><p>Accept-Language</p></li><li><p>Content-Language</p></li><li><p>Last-Event-ID</p></li><li><p>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></p></li></ul></li></ul></li></ul><h3 id="简单请求的相关头部字段"><a href="#简单请求的相关头部字段" class="headerlink" title="简单请求的相关头部字段"></a>简单请求的相关头部字段</h3><ul><li>请求报文的头部字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br></pre></td></tr></table></figure><ul><li>响应报文的头部字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line"># 表示是否允许发送Cookie</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line"># XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：</span><br><span class="line"># Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。</span><br><span class="line"># 如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br></pre></td></tr></table></figure><h3 id="非简单请求的相关头部字段"><a href="#非简单请求的相关头部字段" class="headerlink" title="非简单请求的相关头部字段"></a>非简单请求的相关头部字段</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求<br>关于预检请求：<br>    浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><h4 id="预检请求的相关字段"><a href="#预检请求的相关字段" class="headerlink" title="预检请求的相关字段"></a>预检请求的相关字段</h4><ul><li>请求报文的头部字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line"># 指定浏览器CORS请求会额外发送的头信息字段</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure><ul><li>响应报文的头部字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line"># 表明服务器支持的所有跨域请求的方法</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line"># 表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript语法大全</title>
      <link href="2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/typescript%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
      <url>2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/typescript%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是一篇typescript的语法说明书</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br><span class="line">tsc hello.ts 编译ts文件</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boolean:</span></span><br><span class="line">    <span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// number, string, void, null, undefined,any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// union:</span></span><br><span class="line">    <span class="keyword">let</span> myFavoriateNumber: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces: 对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）</span></span><br><span class="line">    <span class="keyword">interface</span>: Person &#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        age?: <span class="built_in">number</span>; <span class="comment">// age是可选属性, 用 ？表示可选</span></span><br><span class="line">        [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 允许有任意的属性</span></span><br><span class="line">        <span class="keyword">readonly</span> id: <span class="built_in">number</span> <span class="comment">// 只读属性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array:</span></span><br><span class="line">    <span class="keyword">let</span> fibonacci: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = <span class="string">&#x27;cat&#x27;</span>, lastName?:<span class="built_in">string</span>, ...items: <span class="built_in">any</span>[]</span>):<span class="title">string</span></span>&#123;</span><br><span class="line">      <span class="keyword">let</span> r: <span class="built_in">number</span>[] = []</span><br><span class="line">      items.forEach(<span class="function"><span class="params">item</span> =&gt;</span> r.push(item))</span><br><span class="line">      <span class="keyword">return</span> lastName ? firstName + lastName : firstName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    run(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    swim(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">animal: Cat | Fish</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用类型断言 &quot;值 as&quot; 的方式解决了联合类型变量只能访问共有属性的问题</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> (animal <span class="keyword">as</span> Fish).swim === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).foo = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="声明与导出"><a href="#声明与导出" class="headerlink" title="声明与导出"></a>声明与导出</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span></span><br><span class="line"><span class="comment">// 声明全局方法</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">// 声明全局类</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">class</span></span></span><br><span class="line"><span class="function">// 声明全局枚举类型</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">enum</span></span></span><br><span class="line"><span class="function">// 声明（含有子属性的）全局对象</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">namespace</span></span></span><br><span class="line"><span class="function">// 声明全局类型</span></span><br><span class="line"><span class="function"><span class="title">interface</span> 和 <span class="title">type</span></span></span><br><span class="line"><span class="function">// 导出变量</span></span><br><span class="line"><span class="function"><span class="title">export</span></span></span><br><span class="line"><span class="function">// 导出（含有子属性的）对象</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">namespace</span></span></span><br><span class="line"><span class="function">// <span class="title">ES6</span> 默认导出</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">default</span></span></span><br><span class="line"><span class="function">// 导出模块</span></span><br><span class="line"><span class="function"><span class="title">export</span> = <span class="title">commonjs</span></span></span><br><span class="line"><span class="function">// <span class="title">UMD</span> 库声明全局变量</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">as</span> <span class="title">namespace</span></span></span><br><span class="line"><span class="function">// 扩展全局变量</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">global</span></span></span><br><span class="line"><span class="function">// 扩展模块</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">module</span></span></span><br><span class="line"><span class="function">/// &lt;<span class="title">reference</span> /&gt; 三斜线指令</span></span><br><span class="line"><span class="function">// 在引入外部文件的时候，比如<span class="title">jquery</span>,因为<span class="title">ts</span>中在编译过程的时候，需要每个变量进行定义</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">var</span> <span class="title">jQuery</span>: (<span class="params">selector: <span class="built_in">string</span></span>) =&gt; <span class="title">any</span></span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">namespace</span> <span class="title">JQuery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function">() =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver</span><br></pre></td></tr></table></figure><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventNames = <span class="string">&#x27;click&#x27;</span> | <span class="string">&#x27;scroll&#x27;</span> | <span class="string">&#x27;mousemove&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;hello&#x27;</span>), <span class="string">&#x27;scroll&#x27;</span>);  <span class="comment">// 没问题</span></span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;world&#x27;</span>), <span class="string">&#x27;dblclick&#x27;</span>); <span class="comment">// 报错，event 不能为 &#x27;dblclick&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tom: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;tom&#x27;</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认第一个是0，依次递增加一</span></span><br><span class="line"><span class="built_in">enum</span> Days &#123;sun, mon, tue, wed, thr, fir, sat&#125;</span><br><span class="line"><span class="built_in">enum</span> Days &#123;sun=<span class="number">7</span>, mon=<span class="number">1</span>, tue, wed, thr, fri, sat&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类的抽象方法，继承的类要具体实现</span></span><br><span class="line"><span class="keyword">public</span>, <span class="keyword">private</span>, protect, <span class="keyword">static</span>, <span class="keyword">readonly</span>, <span class="keyword">abstract</span></span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口可以继承接口</span></span><br><span class="line"><span class="comment">// 一个类可以实现多个接口</span></span><br><span class="line"><span class="comment">// 接口可以继承类</span></span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert():<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;securitydoor&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法</span></span><br><span class="line"><span class="comment">// 但是可以通过约束的办法解决这个问题</span></span><br><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>):<span class="title">Array</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">create&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">tuple: [T, U]</span>): [<span class="title">U</span>, <span class="title">T</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([<span class="number">7</span>, <span class="string">&#x27;seven&#x27;</span>]); <span class="comment">// [&#x27;seven&#x27;, 7]</span></span><br><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line">nterface CreateArrayFunc&lt;T&gt; &#123;</span><br><span class="line">    (length: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createArray: CreateArrayFunc&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">createArray = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span></span><br><span class="line"><span class="comment">// 泛型参数的默认类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span> = <span class="title">string</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    price: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的相关知识</title>
      <link href="2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>2021/04/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/javascript%E7%B3%BB%E5%88%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器对象模型-BOM"><a href="#浏览器对象模型-BOM" class="headerlink" title="浏览器对象模型(BOM)"></a>浏览器对象模型(BOM)</h1><p>BOM包含5个东西:</p><ul><li>location        管理 URL</li><li>navigator      管理浏览器</li><li>history          管理历史记录</li><li>screen          管理屏幕</li><li>window         管理浏览器所有的东西</li></ul><h2 id="location相关操作"><a href="#location相关操作" class="headerlink" title="location相关操作"></a>location相关操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改变 href 属性就可以跳转页面, 相对路径就是放在原url的后面拼接，绝对路径就是替换</span></span><br><span class="line">location.href = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">location.href = <span class="string">&#x27;#shabi&#x27;</span></span><br><span class="line"><span class="comment">// reload 刷新页面</span></span><br><span class="line">location.reload()</span><br><span class="line"><span class="comment">// replace 替换当前页面</span></span><br><span class="line">location.replace(location.href, <span class="string">&#x27;www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="navigator相关操作"><a href="#navigator相关操作" class="headerlink" title="navigator相关操作"></a>navigator相关操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较需要关注的是userAgent这个属性</span></span><br><span class="line"><span class="comment">// 通过对navigator.userAgent的处理可以判断当前的平台环境（andoriod, ios, web)</span></span><br><span class="line"><span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line"><span class="keyword">var</span> isAndroid = u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Adr&#x27;</span>) &gt; -<span class="number">1</span>; <span class="comment">//android终端</span></span><br><span class="line"><span class="keyword">var</span> isiOS = !!u.match(<span class="regexp">/(i[^;]+;( U;)? CPU.+Mac OS X/</span>); <span class="comment">//ios终端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> browser=&#123;</span><br><span class="line">    versions: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            trident: u.indexOf(<span class="string">&#x27;Trident&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//IE内核</span></span><br><span class="line">            presto: u.indexOf(<span class="string">&#x27;Presto&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//opera内核</span></span><br><span class="line">            webKit: u.indexOf(<span class="string">&#x27;AppleWebKit&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//苹果、谷歌内核</span></span><br><span class="line">            gecko: u.indexOf(<span class="string">&#x27;Gecko&#x27;</span>) &gt; -<span class="number">1</span> &amp;&amp; u.indexOf(<span class="string">&#x27;KHTML&#x27;</span>) == -<span class="number">1</span>,<span class="comment">//火狐内核</span></span><br><span class="line">            mobile: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>), <span class="comment">//是否为移动终端</span></span><br><span class="line">            ios: !!u.match(<span class="regexp">/(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span></span><br><span class="line">            android: u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Adr&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//android终端</span></span><br><span class="line">            iPhone: u.indexOf(<span class="string">&#x27;iPhone&#x27;</span>) &gt; -<span class="number">1</span> , <span class="comment">//是否为iPhone或者QQHD浏览器</span></span><br><span class="line">            iPad: u.indexOf(<span class="string">&#x27;iPad&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//是否iPad</span></span><br><span class="line">            webApp: u.indexOf(<span class="string">&#x27;Safari&#x27;</span>) == -<span class="number">1</span>, <span class="comment">//是否web应该程序，没有头部与底部</span></span><br><span class="line">            weixin: u.indexOf(<span class="string">&#x27;MicroMessenger&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//是否微信 （2015-01-22新增）</span></span><br><span class="line">            qq: u.match(<span class="regexp">/sQQ/i</span>) == <span class="string">&quot; qq&quot;</span> <span class="comment">//是否QQ</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;(),</span><br><span class="line">    language:(navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否IE内核</span></span><br><span class="line"><span class="keyword">if</span>(browser.versions.trident)&#123; alert(<span class="string">&quot;is IE&quot;</span>); &#125;</span><br><span class="line"><span class="comment">//判断是否webKit内核</span></span><br><span class="line"><span class="keyword">if</span>(browser.versions.webKit)&#123; alert(<span class="string">&quot;is webKit&quot;</span>); &#125;</span><br><span class="line"><span class="comment">//判断是否移动端</span></span><br><span class="line"><span class="keyword">if</span>(browser.versions.mobile||browser.versions.android||browser.versions.ios)&#123; alert(<span class="string">&quot;移动端&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="history相关操作"><a href="#history相关操作" class="headerlink" title="history相关操作"></a>history相关操作</h2><p>history对象是用来处理历史记录的， 在 HTML5 它增加了一些 API 使得它也可以做单页应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pushState的 三个参数分别是:</span></span><br><span class="line"><span class="comment">自定义对象, 新页面的标题, 新页面的地址</span></span><br><span class="line"><span class="comment">跳转到新页面地址的时候，浏览器不会刷新页面</span></span><br><span class="line"><span class="comment">history.pushState 并不会触发popstate事件, 除了将数据push进入历史栈</span></span><br><span class="line"><span class="comment">它还会改变loaction当前的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">history.pushState(<span class="literal">null</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&quot;/profile&quot;</span>)</span><br><span class="line"><span class="comment">// 用户点击前进和后退按钮的时候, 会触发window的popstate事件</span></span><br><span class="line"><span class="comment">// 前进：history.forward(), history.go()</span></span><br><span class="line"><span class="comment">// 后退：history.back()</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;popstate&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// state 就是 pushState 的第一个参数</span></span><br><span class="line">    <span class="keyword">var</span> state = e.state;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;pop state&#x27;</span>, state)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// replaceState的作用和pushState一样, 只是不生成一条历史纪录</span></span><br><span class="line">history.replaceState(state1, state2)</span><br><span class="line"><span class="comment">// 表示会话历史中元素的数目</span></span><br><span class="line">history.length</span><br></pre></td></tr></table></figure><h3 id="spa的原理机制"><a href="#spa的原理机制" class="headerlink" title="spa的原理机制"></a>spa的原理机制</h3><p>这里有两种实现方式, 一种是哈希路由的方式，另一种是history的机制.<br>所谓单页Web应用, 就是只有一张Web页面的应用. 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序. 不像以前所有的页面跳转都要新开窗口,用户体验不好.另外最重要的一点是不会刷新页面(也就是说减少了不必要的刷新操作). 另外为啥不用ajax实现spa因为ajax的<br>实现方式没有记住页面状态的能力</p><blockquote><p>哈希路由的方式, hash值得改变不会导致浏览器向服务器发送请求，并且改变的时候会触发hashchange事件, hashchange可以捕捉url的变化从而实现spa.</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>spa hash demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/arena&quot;</span>&gt;</span>arena<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/questions?name=woyao&quot;</span>&gt;</span>questions<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/classroom?name=woyao&amp;height=171&quot;</span>&gt;</span>classroom<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;route&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderHtml = <span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> element = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.route&#x27;</span>)</span><br><span class="line">  element.innerHTML = text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> responseForPath = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> mapper = &#123;</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span>: <span class="string">&#x27;home page&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/arena&#x27;</span>: <span class="string">&#x27;arena page&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/questions&#x27;</span>: <span class="string">&#x27;question page&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/classroom&#x27;</span>: <span class="string">&#x27;classroom page&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (path <span class="keyword">in</span> mapper) &#123;</span><br><span class="line">    <span class="keyword">return</span> mapper[path]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;not found&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argsFromQuery = <span class="function">(<span class="params">query</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> o = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> qs = query.split(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  qs.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> [k, v] = e.split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    o[k] = v</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parsedUrl = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> query = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> index = url.indexOf(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    path = url.slice(<span class="number">0</span>, index)</span><br><span class="line">    <span class="keyword">let</span> q = url.slice(index + <span class="number">1</span>)</span><br><span class="line">    query = argsFromQuery(q)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    path = url</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    path,</span><br><span class="line">    query,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  log(<span class="string">&#x27;location.hash&#x27;</span>, location.hash)</span><br><span class="line">  <span class="comment">// 再用 parsedUrl 解析这个地址, 得到 path 和 query</span></span><br><span class="line">  <span class="keyword">let</span> &#123; path, query &#125; = parsedUrl(location.hash.slice(<span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> r = responseForPath(path)</span><br><span class="line">  renderHtml(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindEventHashChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// event.oldURL 表示变化之前的 URL, event.newURL 表示变化之后（也就是现在）的 URL</span></span><br><span class="line">    log(<span class="string">&#x27;event url&#x27;</span>, event.oldURL, event.newURL)</span><br><span class="line">    render()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindEvents = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    bindEventHashChange()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> __main = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">bindEvents()</span><br><span class="line">  <span class="comment">// 初始化渲染</span></span><br><span class="line">render()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOMContentLoaded 事件表示 HTML 已经加载(渲染)到页面中, 这个时候操作 DOM 元素就没有问题</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  __main()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>history spa</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>spa history demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/arena&quot;</span>&gt;</span>arena<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/questions?name=gua&quot;</span>&gt;</span>questions<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/classroom?name=gua&amp;height=169&quot;</span>&gt;</span>classroom<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;route&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码几乎和hash的那段js代码一样，只是事件机制这边处理不一样, 我就不再重复写一次了</span></span><br><span class="line"><span class="keyword">const</span> bindEventPopState = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 注意: 调用 history.pushState 并不会触发 popstate 事件</span></span><br><span class="line">  <span class="comment">// 当使用浏览器的前进、后退功能时会触发这个事件</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// event.state 的值是 history.pushState 调用时传入的第一个参数</span></span><br><span class="line">    log(<span class="string">&#x27;pop state&#x27;</span>, event.state)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindEventLink = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> links = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> l <span class="keyword">of</span> links) &#123;</span><br><span class="line">    l.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      event.preventDefault()</span><br><span class="line">      <span class="keyword">let</span> self = event.target</span><br><span class="line">      <span class="keyword">let</span> path = self.href</span><br><span class="line">      <span class="keyword">let</span> state = &#123;</span><br><span class="line">        <span class="string">&#x27;path&#x27;</span>: path</span><br><span class="line">      &#125;</span><br><span class="line">      history.pushState(state, <span class="string">&#x27;&#x27;</span>, path)</span><br><span class="line">      render()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindEvents = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  bindEventPopState()</span><br><span class="line">  bindEventLink()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="screen相关操作"><a href="#screen相关操作" class="headerlink" title="screen相关操作"></a>screen相关操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可用的屏幕的宽度和高度</span></span><br><span class="line">screen.availWidth; screen.availHeight</span><br></pre></td></tr></table></figure><h1 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h1><ul><li><p>回流</p><p>renderTree: 简单的理解就是DOM Tree和我们写的CSS结合在一起之后，渲染出了render tree</p><p>回流: 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。</p><ul><li><p>导致回流的操作</p><ol><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除可见的DOM元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ol></li><li><p>如何避免</p><ol><li><p>避免使用table布局。</p></li><li><p>尽可能在DOM树的最末端改变class。</p></li><li><p>避免设置多层内联样式。</p></li><li><p>将动画效果应用到position属性为absolute或fixed的元素上。</p></li><li><p>避免使用CSS表达式（例如：calc()）</p></li><li><p>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</p></li><li><p>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</p></li><li><p>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</p></li><li><p>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</p></li></ol></li></ul></li></ul><ul><li><p>重绘</p><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格.<br>而不会影响布局的，比如background-color。浏览器会将新样式赋予给元素并重新绘制它<br>这个过程称为重绘</p><ul><li>导致重绘的操作<ol><li>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等）</li></ol></li></ul></li></ul><h1 id="url输入到渲染过程"><a href="#url输入到渲染过程" class="headerlink" title="url输入到渲染过程"></a>url输入到渲染过程</h1><ul><li><p>DNS域名解析，根据url找到对应的服务地址</p></li><li><p>三次握手构建TCP连接</p></li><li><p>发送HTTP请求</p></li><li><p>服务端响应请求，返回相应的资源文件</p></li><li><p>解析文档</p></li><li><p>构建 DOM 树和 CSSOM（css object modal）</p></li><li><p>生成渲染树(render tree)：从DOM树的根节点开始遍历每个可见节点，对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们，根据每个可见节点以及其对应的样式，组合生成渲染树</p></li><li><p>Layout（回流）：根据生成的渲染树，进行回流（Layout），得到节点的集合信息</p></li><li><p>Painting（重绘）：根据渲染树及其回流得到的集合信息，得到节点的绝对像素</p></li><li><p>绘制，在页面上展示，这一步还涉及到绘制层级、GPU相关的知识点</p></li><li><p>加载js脚本，加载完成解析js脚本</p></li></ul><h1 id="浏览器的多进程"><a href="#浏览器的多进程" class="headerlink" title="浏览器的多进程"></a>浏览器的多进程</h1><p>一般情况下在浏览器中每个tab页面可以算作一个进程。可以通过打开chorme浏览器的更多工具-&gt;任务管理器<br>查看当前浏览器中正在运行哪些进程</p><h2 id="chorme-浏览器的主要进程和职责"><a href="#chorme-浏览器的主要进程和职责" class="headerlink" title="chorme 浏览器的主要进程和职责"></a>chorme 浏览器的主要进程和职责</h2><ul><li><strong>Browser Process</strong> 浏览器的主进程（负责协调、主控）<ul><li>负责包括地址栏，书签栏，前进后退按钮等部分的工作</li><li>负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问</li><li>负责各个页面的管理，创建和销毁其他进程</li></ul></li><li><strong>Renderer Process</strong>负责一个 tab 内关于网页呈现的所有事情，页面渲染，脚本执行，事件处理等</li><li><strong>Plugin Process</strong>负责控制一个网页用到的所有插件，如 flash 每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li><strong>GPU Process</strong> 负责处理 GPU 相关的任务</li></ul><h3 id="Renderer-Process进程里的多个线程"><a href="#Renderer-Process进程里的多个线程" class="headerlink" title="Renderer Process进程里的多个线程"></a>Renderer Process进程里的多个线程</h3><ul><li><p>GUI渲染线程</p><p>负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行,在Javascript引擎运行脚本期间,GUI渲染线程都是处于就绪状态的</p></li><li><p>javaScript引擎线程</p><p>JS内核，负责处理Javascript脚本程序。 一直等待着任务队列中任务的到来，然后解析Javascript脚本，运行代码。GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</p></li><li><p>定时触发器线程</p><p>定时器setInterval与setTimeout所在线程。浏览器定时计数器并不是由JavaScript引擎计数的 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</p></li><li><p>事件触发线程</p><p>用来控制事件轮询，JS引擎自己忙不过来，需要浏览器另开线程协助<br>当JS引擎执行代码块如鼠标点击、AJAX异步请求等，会将对应任务添加到事件触发线程中<br>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理任务队列的队尾，等待JS引擎的处理<br>由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p></li><li><p>异步http请求线程</p><p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。</p></li></ul><h4 id="关于js单线程"><a href="#关于js单线程" class="headerlink" title="关于js单线程"></a>关于js单线程</h4><p>上面所说的线程是不能并行的, 是一个单线程，原因如下：</p><p>​    假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。如果没懂可以看看<a href="https://www.ruanyifeng.com/blog/2014/10/event-loop.html">阮一峰的博客</a><br>学过操作系统的进程调度知道可以用锁的机制解决，但是会使得javascript的实现变得复杂，想想当初javascript是一天就搞出来的</p>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法思想</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口，"><a href="#滑动窗口，" class="headerlink" title="滑动窗口，"></a>滑动窗口，</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用在数组和字符串的操作上面。</span><br><span class="line">可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续(单调递增或者单调递减)</span><br><span class="line">因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。</span><br><span class="line">往往类似于“ 请找到满足 xx 的最 x 的区间（子串、子数组）的 xx ”</span><br></pre></td></tr></table></figure><h1 id="动态规划，"><a href="#动态规划，" class="headerlink" title="动态规划，"></a>动态规划，</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是一种暴力方法，下一步的操作时通过上一步的某条件达到的。</span><br><span class="line">写出表达式和约束条件即可达到目的</span><br><span class="line">动态规划一般会超出时间限制，如果是dp就生成一维数组，如果是dp[i][j]就生成二维数组。</span><br><span class="line">反正就是个多维数组保存每一种情况下的办法。</span><br></pre></td></tr></table></figure><h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个问题可以拆成两个或多个“相似”的小问题，就一定要用分治法。</span><br><span class="line">因为小问题可以拆到简单的直接求解</span><br></pre></td></tr></table></figure><h1 id="回朔法，深度遍历dfs"><a href="#回朔法，深度遍历dfs" class="headerlink" title="回朔法，深度遍历dfs"></a>回朔法，深度遍历dfs</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是一种暴力方法</span><br><span class="line">试探性一步一步的看能否到达终点。</span><br><span class="line">如果当前的方法可行满足约束条件，且下一步操作也可行。就往下走</span><br><span class="line">如果下一步是死路就不往下一步走，悔棋，更换当前的可行方法是自己满足约束条件</span><br></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">维护一个单调递增或者单调递减的栈。如果是递减栈，遇到一个比栈顶元素还要小的元素，</span><br><span class="line">就一直推出元素直到这个元素作为栈顶元素时依旧是一个递减栈。</span><br><span class="line">通常用这种数据结构解决一种公共区间内最大或最小值。</span><br><span class="line">比如木板长短不一怎样能打最多的水,柱状图的最大矩形。</span><br></pre></td></tr></table></figure><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种搜索方法，在一种具有单调性的队列中，快速搜索目标</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>如果遇到必须用暴力的算法来解决的问题，一般都会用一个栈来进行维护减少重复操作。<br>就比如回朔法，给之前走过的可行步骤做一个存储，如果下一步骤可行的操作在存储里存在<br>就调用存储的方法</li><li>能用dp算法的一般也能用回朔法。如果当前可选择的方法量比较少推荐用回溯</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的题目"><a href="#常见的题目" class="headerlink" title="常见的题目"></a>常见的题目</h1><h2 id="匹配字符串之kmp"><a href="#匹配字符串之kmp" class="headerlink" title="匹配字符串之kmp"></a>匹配字符串之kmp</h2><blockquote><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">题目来源</a><br>思路：<br>这里使用了一个《部分匹配表》的数据结构<br>字符串与搜索词依次比较，通过‘移动位数=已知匹配字符串数-对应的部分匹配值’来<br>移动搜索词。注意这里的移动是指移动字符串的索引位数。<br>“前缀”指除了最后一个字符以外，一个字符串的全部头部组合<br>“后缀”指除了第一个字符以外，一个字符串的全部尾部组合<br>部分匹配值：前缀与后缀的最长的共有元素长度<br>字符串：‘abcdabd’<br>前缀:[a, ab, abc, abcd, abcda, abcdb],<br>后缀: [bcdabd, cdabd, dabd, abd, bd, d]<br>部分匹配值: 0<br>字符串：‘abcda’<br>前缀:[a, ab, abc, abcd],<br>后缀: [bcda, cda, da, a]<br>部分匹配值: 1<br>str: bbc abcdab abcdabcdabde<br>search: abcdabd<br>=&gt;<br>bbc abcdab abcdabcdabde<br>____abcdabd(4 = 6 - 2)(移动位数=已知匹配字符串数-对应的部分匹配值)<br>=&gt;<br>bbc abcdab abcdabcdabde<br>________abcdabd(2 = 2 - 0)<br>=&gt;<br>bbc abcdab abcdabcdabde<br>__________abcdabd<br>=&gt;<br>bbc abcdab abcdabcdabde<br>___________abcdabd(4 = 6 - 2)<br>=&gt;<br>bbc abcdab abcdabcdabde<br>_______________abcdabd(4 = 6 - 2)<br>=&gt;<br>over</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取前缀</span></span><br><span class="line"><span class="keyword">const</span> getPrefix = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    arr.splice(str.length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">            result.push(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr.slice(<span class="number">0</span>, index + <span class="number">1</span>).join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取后缀</span></span><br><span class="line"><span class="keyword">const</span> getSuffix = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s = str.slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> s) &#123;</span><br><span class="line">        result.push(s.slice(key))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取前缀与后缀的最长公共子集的长度</span></span><br><span class="line"><span class="keyword">const</span> commonFix = <span class="function">(<span class="params">prefix, suffix</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> pre <span class="keyword">of</span> prefix) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> suff <span class="keyword">of</span> suffix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre === suff) &#123;</span><br><span class="line">                maxLen = pre.length &gt; maxLen ? pre.length : maxLen</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到部分匹配表</span></span><br><span class="line"><span class="keyword">const</span> getMatchTable = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        map.set(i + <span class="number">1</span>, commonFix(</span><br><span class="line">            getPrefix(str.slice(<span class="number">0</span>, i + <span class="number">1</span>)),</span><br><span class="line">            getSuffix(str.slice(<span class="number">0</span>, i + <span class="number">1</span>))</span><br><span class="line">        ))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> match = <span class="function">(<span class="params">str, search</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> matchedLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> table = getMatchTable(search)</span><br><span class="line">    <span class="keyword">let</span> jump = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jump) &#123;</span><br><span class="line">            jump -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (char === search[matchedLen]) &#123;</span><br><span class="line">            matchedLen += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (matchedLen === search.length) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (matchedLen) &#123;</span><br><span class="line">                <span class="comment">// ‘移动位数=已知匹配字符串数-对应的部分匹配值’</span></span><br><span class="line">                jump = matchedLen - table.get(matchedLen)</span><br><span class="line">                matchedLen = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><blockquote><p>[题目来源](<a href="https://leetcode-cn.com/problems/ti-huan-kon">https://leetcode-cn.com/problems/ti-huan-kon</a> g-ge-lcof/)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> replaceSpace = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&#x27; &#x27;</span>).join(<span class="string">&#x27;%20&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><blockquote><p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">题目来源</a><br>思路：使用有限状态自动机<br>状态自动机:<br>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：<br>有一个特殊的状态，被称作「初始状态」。<br>还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。<br>起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝</p><p>枚举字符类型：空格 「 」、数字「 0—9 」 、正负号 「 +- 」 、小数点 「 . 」 、幂符号 「 eE 」<br>按照字符串从左到右的顺序，定义以下 9 种状态。<br>0: 开始的空格<br>1: 幂符号前的正负号<br>2: 小数点前的数字<br>3: 小数点、小数点后的数字<br>4: 当小数点前为空格时，小数点、小数点后的数字<br>5: 幂符号<br>6: 幂符号后的正负号<br>7: 幂符号后的数字<br>8: 结尾的空格</p><p>数值（按顺序）可以分成以下几个部分：<br>1: 若干空格<br>2: 一个小数或者整数<br>3:（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个整数<br>4: 若干空格</p><p>小数的定义：<br>1:（可选）一个符号字符（’+’ 或 ‘-‘）<br>2: 下述格式之一：<br>至少一位数字，后面跟着一个点 ‘.’ 比如’1.’<br>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字 比如’1.1’<br>一个点 ‘.’ ，后面跟着至少一位数字 比如’.1’</p><p>整数的定义：<br>1:（可选）一个符号字符（’+’ 或 ‘-‘）<br>2: 至少一位数字<br>其中终点为2，3，7，8的状态都是接受状态<br>*/<br>// ‘5.2e-3 ‘</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CharType = &#123;</span><br><span class="line">    <span class="string">&#x27;blank&#x27;</span>: <span class="string">&#x27;blank&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;sign&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;digit&#x27;</span>: <span class="string">&#x27;digit&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dot&#x27;</span>: <span class="string">&#x27;dot&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 状态转移表2, 3, 7</span></span><br><span class="line"><span class="comment">// 状态转移表显示了所有的路线方案</span></span><br><span class="line"><span class="keyword">const</span> states = [</span><br><span class="line">    <span class="comment">// 0: 开始的空格</span></span><br><span class="line">    &#123; <span class="string">&#x27;blank&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;sign&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;digit&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;dot&#x27;</span>: <span class="number">4</span> &#125;,</span><br><span class="line">    <span class="comment">// 1: 幂符号前的正负号</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;dot&#x27;</span>: <span class="number">4</span> &#125;,</span><br><span class="line">    <span class="comment">// 2: 小数点前的数字</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;dot&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;blank&#x27;</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    <span class="comment">// 3: 小数点、小数点后的数字</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;blank&#x27;</span>: <span class="number">8</span> &#125;,</span><br><span class="line">    <span class="comment">// 4: 当小数点前为空格时，小数点、小数点后的数字</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="comment">// 5: 幂符号</span></span><br><span class="line">    &#123; <span class="string">&#x27;sign&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;digit&#x27;</span>: <span class="number">7</span> &#125;,</span><br><span class="line">    <span class="comment">// 6: 幂符号后的正负号</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">7</span> &#125;,</span><br><span class="line">    <span class="comment">// 7: 幂符号后的数字</span></span><br><span class="line">    &#123; <span class="string">&#x27;digit&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;blank&#x27;</span>: <span class="number">8</span> &#125;,</span><br><span class="line">    <span class="comment">// 8: 结尾的空格</span></span><br><span class="line">    &#123; <span class="string">&#x27;blank&#x27;</span>: <span class="number">8</span> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> isNumber = <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> t = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// 状态转移循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= char &amp;&amp; <span class="string">&#x27;9&#x27;</span> &gt;= char) &#123;</span><br><span class="line">            t = <span class="string">&#x27;digit&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;+-&#x27;</span>.includes(char)) &#123;</span><br><span class="line">            t = <span class="string">&#x27;sign&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;eE&#x27;</span>.includes(char)) &#123;</span><br><span class="line">            t = <span class="string">&#x27;e&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            t = <span class="string">&#x27;dot&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            t = <span class="string">&#x27;blank&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = <span class="string">&#x27;?&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!states[p][t]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        p = states[p][t]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>].includes(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><blockquote><p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">题目来源</a><br>思路:<br>深度:    选择<br>depth0: a or b or c<br>depth1: a or b or c<br>depth2: a or b or c<br>depth3: back</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permutation = <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> path = []</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">depth</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.length === s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!result.has(path.join(<span class="string">&#x27;&#x27;</span>))) &#123;</span><br><span class="line">                result.add(path.join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.has(i)) &#123;</span><br><span class="line">                path.push(s[i])</span><br><span class="line">                visited.add(i)</span><br><span class="line">                dfs(depth + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">                visited.delete(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><blockquote><p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">题目来源</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseLeftWords = <span class="function"><span class="keyword">function</span> (<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.slice(n) + s.slice(<span class="number">0</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法和数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="2021/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这是一个linux常用命令大全</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl+d</td><td>键盘输入结束或退出终端</td></tr><tr><td>Ctrl+s</td><td>暂停当前程序，暂停后按下任意键恢复运行</td></tr><tr><td>Ctrl+z</td><td>将当前程序放到后台运行，恢复到前台为命令fg</td></tr><tr><td>Ctrl+a</td><td>将光标移至输入行头，相当于Home键</td></tr><tr><td>Ctrl+e</td><td>将光标移至输入行末，相当于End键</td></tr><tr><td>Ctrl+k</td><td>删除从光标所在位置到行末</td></tr><tr><td>Ctrl+c</td><td>使用键来强行终止当前程序</td></tr><tr><td>Alt+Backspace</td><td>向前删除一个单词</td></tr><tr><td>Shift+PgUp</td><td>将终端显示向上滚动</td></tr><tr><td>Shift+PgDn</td><td>将终端显示向下滚动</td></tr></tbody></table><h2 id="功能手册（man"><a href="#功能手册（man" class="headerlink" title="功能手册（man)"></a>功能手册（man)</h2><p>可以使用功能手册查看一个命令的具体用法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ man &lt;command_type&gt; &lt;command_name&gt;</span><br><span class="line"><span class="comment"># `man 1 ls` 这条命令可以查看`ls`有哪些用法</span></span><br><span class="line"><span class="comment"># comman_type 的选择如下</span></span><br><span class="line"><span class="comment"># 1一般命令</span></span><br><span class="line"><span class="comment"># 2系统调用</span></span><br><span class="line"><span class="comment"># 3库函数，涵盖了C标准函数库</span></span><br><span class="line"><span class="comment"># 4特殊文件（通常是/dev中的设备）和驱动程序</span></span><br><span class="line"><span class="comment"># 5文件格式和约定</span></span><br><span class="line"><span class="comment"># 6游戏和屏保</span></span><br><span class="line"><span class="comment"># 7杂项</span></span><br><span class="line"><span class="comment"># 8系统管理命令和守护进程</span></span><br></pre></td></tr></table></figure><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul><li>查看用户<br>具体的用法可以： <code>man 1 who</code> 打开功能手册<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前用户的两种写法</span></span><br><span class="line">who am i</span><br><span class="line">who mom likes</span><br></pre></td></tr></table></figure></li><li>创建用户<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新用户 woyao</span></span><br><span class="line">sudo adduser woyao</span><br><span class="line"><span class="comment"># 更新用户密码</span></span><br><span class="line">passwd woyao</span><br></pre></td></tr></table></figure></li><li>切换用户<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su -l woyao</span><br><span class="line">su woyao</span><br></pre></td></tr></table></figure></li><li>删除用户<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo userdel woyao -f</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><ul><li>创建<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line">touch 1.txt 2.txt</span><br><span class="line">touch love_&#123;1..10&#125;_woyao.txt</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir mydir</span><br><span class="line">mkdir -p user/woyao/name</span><br></pre></td></tr></table></figure></li><li>复制<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line">cp a.txt user/woyao/name</span><br><span class="line"><span class="comment"># 复制目录</span></span><br><span class="line"><span class="comment"># 将father内的子文件复制到family文件夹</span></span><br><span class="line">cp -r father family</span><br></pre></td></tr></table></figure></li><li>删除<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">rm a.txt</span><br><span class="line">rm -f a.txt</span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line">rm -rf father</span><br></pre></td></tr></table></figure></li><li>移动文件和文件重命名：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.txt 移动到 father</span></span><br><span class="line">mv a.txt father</span><br><span class="line"><span class="comment"># a.txt 重命名为b.txt</span></span><br><span class="line">mv a.txt b.txt</span><br><span class="line"><span class="comment"># 批量将后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件:</span></span><br><span class="line">rename <span class="string">&#x27;s/.txt/.c/&#x27;</span> *.txt</span><br><span class="line"><span class="comment"># 批量将文件，文件名和后缀改为大写:</span></span><br><span class="line">rename <span class="string">&#x27;y/a-z/A-Z/&#x27;</span> *.c</span><br></pre></td></tr></table></figure></li><li>查看<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt</span><br><span class="line"><span class="comment"># -n 参数显示行号</span></span><br><span class="line">cat -n a.txt</span><br><span class="line"><span class="comment"># 更多显示</span></span><br><span class="line">more a.txt</span><br><span class="line"><span class="comment"># 显示一部分</span></span><br><span class="line">less a.txt</span><br><span class="line"><span class="comment"># 文件的最后一行</span></span><br><span class="line">tail -n 1 /father/son/grandson/a.txt</span><br><span class="line"><span class="comment"># 文件的开始</span></span><br><span class="line">head b.txt</span><br><span class="line"><span class="comment"># 查看文件类型</span></span><br><span class="line">file a.txt</span><br><span class="line"><span class="comment"># 查看文件大小</span></span><br><span class="line">du -h -d 0 *.zip ~ | sort</span><br><span class="line">du -h woyao.zip</span><br></pre></td></tr></table></figure></li><li>搜索<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配所有文件名带a.txt的路径</span></span><br><span class="line">locate a.txt</span><br><span class="line"><span class="comment"># 在root目录下，查找有a.txt的路径</span></span><br><span class="line">find /root/ -name a.txt</span><br></pre></td></tr></table></figure></li><li>文件权限管理<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#x27;r&#x27;读4， &#x27;w&#x27;写2， &#x27;x&#x27;可执行1</span></span><br><span class="line"><span class="comment"># 600 等价于 -wr-----</span></span><br><span class="line"><span class="comment"># 644 等价于 -rw-r--r--</span></span><br><span class="line">chmod 600 a.txt</span><br><span class="line"><span class="comment"># 变更文件所有者</span></span><br><span class="line">sudo chown chen a.txt</span><br></pre></td></tr></table></figure></li><li>文件的压缩，解压，打包<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把woyao文件夹压缩成woyao.zip</span></span><br><span class="line"><span class="built_in">cd</span> /Desktop</span><br><span class="line">zip -r -q -o woyao.zip woyao</span><br><span class="line"><span class="comment"># 解压woyao.zip</span></span><br><span class="line">unzip woyao.zip</span><br><span class="line"><span class="comment"># 解压到指定目录</span></span><br><span class="line">unzip -q woyao.zip -d /Desktop/tomas</span><br><span class="line"><span class="comment"># 查看zip压缩包的内容</span></span><br><span class="line">unzip -l woyao.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把woyao文件夹压缩成woyao.tar</span></span><br><span class="line"><span class="built_in">cd</span> /Desktop</span><br><span class="line">tar -cf woyao.tar woyao</span><br><span class="line"><span class="comment"># 解压woyao.tar</span></span><br><span class="line">tar -xf woyao.tar</span><br><span class="line"><span class="comment"># 解压到指定目录</span></span><br><span class="line">tar -xf woyao.tar -C /Desktop/tomas</span><br><span class="line"><span class="comment"># 查看tar压缩包的内容</span></span><br><span class="line">tar -tf woyao.tar</span><br></pre></td></tr></table></figure></li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 declare 命令创建一个变量名为 tmp 的变量：</span></span><br><span class="line"><span class="built_in">declare</span> tmp</span><br><span class="line">tmp=woyao</span><br><span class="line"><span class="comment"># $符号用于表示引用一个变量的值，</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$tmp</span></span><br></pre></td></tr></table></figure><h2 id="骚操作-管道，重定向，…"><a href="#骚操作-管道，重定向，…" class="headerlink" title="骚操作(管道，重定向，…)"></a>骚操作(管道，重定向，…)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 家目录 ~</span></span><br><span class="line"><span class="built_in">echo</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重定向 &gt;, &gt;&gt;, tee</span></span><br><span class="line"><span class="comment"># 输出重定向覆盖模式(会覆盖原文件内容)</span></span><br><span class="line">cat b.gua &gt; c.gua</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello gua&quot;</span> &gt; c.gua</span><br><span class="line"><span class="comment"># 输出重定向的追加模式，不会覆盖文件内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello gua&quot;</span> &gt;&gt; c.gua</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道 |</span></span><br><span class="line"><span class="comment"># 管道符号把输出传给另一个程序作为输入</span></span><br><span class="line">cat c.gua | tee f.gua</span><br><span class="line"><span class="comment"># 显示历史密令中带有cat命令的字符串</span></span><br><span class="line"><span class="built_in">history</span> | grep cat</span><br><span class="line"></span><br><span class="line">tee: 把输入过来的数据输出到屏幕上并且重定向一份到文件</span><br><span class="line"><span class="built_in">history</span> | grep cat | tee new.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让程序在后台运行 &amp;</span></span><br><span class="line"><span class="comment"># 可以使运行的Firefox在终端后台运行</span></span><br><span class="line">firefox &amp;</span><br></pre></td></tr></table></figure><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><ol><li>安装shadowsocks<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-pip</span><br><span class="line">pip install shadowsocks</span><br><span class="line">sudo apt install nano</span><br><span class="line">nano /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><blockquote><p>shadowsocks.json 的配置如下<br>{<br> “server”:”主机的Ip地址是”,<br> “server_port”:8388,<br> “local_address”: “127.0.0.1”,<br> “local_port”:1080,<br> “password”:”密码”,<br> “timeout”:300,#超时<br> “method”:”aes-256-cfb”,#加密方式<br> “fast_open”: false<br>}</p></blockquote></li><li>后台运行<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></li><li>服务器开机自动启动，必要性不大，因为服务器基本不重启<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/usr/bin/ssserver -c /etc/shadowsocks.json -d&#x27;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列七</title>
      <link href="2021/04/20/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/"/>
      <url>2021/04/20/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="docker持续集成和部署"><a href="#docker持续集成和部署" class="headerlink" title="docker持续集成和部署"></a>docker持续集成和部署</h2><pre><code>现在是docker系列的最后一篇文章，这里直接实战吧。另外这一篇文章的代码没有测试。看一看就好，就不要实操了主要是了解一套部署流程，因为实际工作中的流程操作用到的镜像都不是这些</code></pre><h3 id="安装代码托管服务gogs"><a href="#安装代码托管服务gogs" class="headerlink" title="安装代码托管服务gogs"></a>安装代码托管服务gogs</h3><p>gogs 是一个类似github的代码托管服务, 它简单方便易于使用，我们使用它进行源代码管理.<br>将本目录下的docker-compose.yml 上传到服务器的 /root/gogs/docker-compose.yml<br>在服务器的 /root/gogs 中启动服务<code>docker-compose up -d</code>.<br>访问服务器的 3000 端口并初始化服务.</p><p>docker-compose.yml文件内容:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">    gogs:</span><br><span class="line">      image: gogs/gogs</span><br><span class="line">      restart: always</span><br><span class="line">      volumes:</span><br><span class="line">        <span class="comment"># 将 gogs 的数据文件存储在本机</span></span><br><span class="line">        - <span class="string">&quot;./data/gogs:/data&quot;</span></span><br><span class="line">      ports:</span><br><span class="line">        - <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">      environment:</span><br><span class="line">        - <span class="string">&quot;RUN_CROND=true&quot;</span></span><br><span class="line">      depends_on:</span><br><span class="line">        - postgres</span><br><span class="line">    postgres:</span><br><span class="line">      image: postgres:<span class="number">9.5</span></span><br><span class="line">      restart: always</span><br><span class="line">      volumes:</span><br><span class="line">        <span class="comment"># 将数据库文件存储到本机，以免丢失</span></span><br><span class="line">        - <span class="string">&quot;./data/postgresql:/var/lib/postgresql&quot;</span></span><br><span class="line">      ports:</span><br><span class="line">        - <span class="string">&quot;127.0.0.1:5432:5432&quot;</span></span><br><span class="line">      environment:</span><br><span class="line">        <span class="comment"># 数据库的连接信息</span></span><br><span class="line">        - <span class="string">&quot;POSTGRES_USER=admin&quot;</span></span><br><span class="line">        - <span class="string">&quot;POSTGRES_PASSWORD=123456&quot;</span></span><br><span class="line">        - <span class="string">&quot;POSTGRES_DB=gogs&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>打开 <code>&lt;server ip&gt;:3000</code>，会看到如下<br><img src="http://121.5.231.10:3000/docker/gogs.png" alt="gogs配置图片"><br>修改数据库用户为:admin, 用户密码：123456. 数据库主机改为你的服务器ip<br>点击安装</p></blockquote><h1 id="安装持续集成服务器"><a href="#安装持续集成服务器" class="headerlink" title="安装持续集成服务器"></a>安装持续集成服务器</h1><p>drone 是一个轻便简介的持续继承服务器程序。持续继承服务器的功能是我们提交代码后自动拉取，自动运行预先配置好的测试<br>以确保及发现代码中的bug。在代码测试失败后，我们可以配置通过微信，短信，邮箱等方式接收通知以便于即使修复bug<br>在代码测试成功后，我们可以配置自动部署到线上生产环境，这个过程叫持续部署<br>将本目录下的docker-compose.yml 上传到服务器的 /root/drone/docker-compose.yml. 在服务器的 /root/drone 中启动服务<code>docker-compose up -d</code><br>由于docker-compose.yml 中配置了gogs, 所以现在可以访问服务器的8000端口并使用gogs的账号登录, 它会在登录后自动同步我们存放在gogs中的项目<br>文件内容如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  server:</span><br><span class="line">    image: drone/drone:0.8.6</span><br><span class="line">    ports:</span><br><span class="line">      - 8000:8000</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/drone:/var/lib/drone/</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      <span class="comment"># false 表示禁止注册</span></span><br><span class="line">      - DRONE_OPEN=<span class="literal">false</span></span><br><span class="line">      <span class="comment"># DRONE_ADMIN 配置的用户作为管理员</span></span><br><span class="line">      - DRONE_ADMIN=kuaibiancheng.com</span><br><span class="line">      <span class="comment"># 本机主机名</span></span><br><span class="line">      - DRONE_HOST=http://111.231.98.114</span><br><span class="line">      <span class="comment"># 随机输入一个字符串</span></span><br><span class="line">      - DRONE_SECRET=random_string_123</span><br><span class="line">      <span class="comment"># 使用 gogs 服务</span></span><br><span class="line">      - DRONE_GOGS=<span class="literal">true</span></span><br><span class="line">      <span class="comment"># gogs 的地址</span></span><br><span class="line">      - DRONE_GOGS_URL=http://111.231.98.114:3000</span><br><span class="line">      <span class="comment"># gogs 的 git 用户名</span></span><br><span class="line">      - DRONE_GOGS_GIT_USERNAME=kuaibiancheng.com</span><br><span class="line">      <span class="comment"># 密码</span></span><br><span class="line">      - DRONE_GOGS_GIT_PASSWORD=123</span><br><span class="line">      <span class="comment"># 私有模式</span></span><br><span class="line">      - DRONE_GOGS_PRIVATE_MODE=<span class="literal">true</span></span><br><span class="line">      <span class="comment"># 关闭 ssl 验证（我们没有配置 https 访问）</span></span><br><span class="line">      - DRONE_GOGS_SKIP_VERIFY=<span class="literal">true</span></span><br><span class="line">  agent:</span><br><span class="line">    image: drone/agent:0.8.6</span><br><span class="line">    <span class="built_in">command</span>: agent</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - server</span><br><span class="line">    volumes:</span><br><span class="line">      <span class="comment"># 这样才可以在容器中使用宿主机的 Docker 服务</span></span><br><span class="line">      - /var/run/docker.sock:/var/run/docker.sock</span><br><span class="line">    environment:</span><br><span class="line">      <span class="comment"># secret 和上面的 DRONE_SECRET 配置一致</span></span><br><span class="line">      - DRONE_SECRET=random_string_123</span><br><span class="line">      <span class="comment"># 上面的 server 服务的 9000 端口</span></span><br><span class="line">      - DRONE_SERVER=server:9000</span><br></pre></td></tr></table></figure><h1 id="drone-的使用"><a href="#drone-的使用" class="headerlink" title="drone 的使用"></a>drone 的使用</h1><p>首先在drone 的网页中打开对仓库的监听, 点开仓库的详细页面<br>drone 使用 .drone.yml 文件配置自动测试. 如果drone监听了一个仓库，仓库的根目录下有.drone.yml文件<br>drone就会使用.drone.yml 文件中定义的步骤测试代码并做一些自定义的操作<br>自定义的操作包括通知，自动部署等<br>详见.drone.yml 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline:</span><br><span class="line">  run:</span><br><span class="line">    image: python:3.7-alpine3.8</span><br><span class="line">    commands:</span><br><span class="line">      - python3 test.py</span><br><span class="line">  deploy:</span><br><span class="line">    image: appleboy&#x2F;drone-ssh</span><br><span class="line">    host: 115.159.181.16</span><br><span class="line">    username: ubuntu</span><br><span class="line">    secrets: [ ssh_key ]</span><br><span class="line">    port: 22</span><br><span class="line">    script:</span><br><span class="line">      - cd &#x2F;home&#x2F;ubuntu&#x2F;test</span><br><span class="line">      - git pull</span><br><span class="line">      - sudo sh reload.sh</span><br></pre></td></tr></table></figure><p>如果你有其他需求，下面是drone 的文档地址，请自行参阅<br><a href="http://readme.drone.io/">http://readme.drone.io/</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><a href="http://plugins.drone.io/">插件</a></li><li><a href="http://docs.drone.io/pipeline-conditions/">让整个构建步骤只在某些分支发生变化的时候执行</a></li><li><a href="http://docs.drone.io/step-conditions/">让某一步动作在特定条件执行</a></li><li><a href="http://docs.drone.io/install-for-github/">让 Drone 支持 GitHub</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列六</title>
      <link href="2021/04/20/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/"/>
      <url>2021/04/20/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="docker在服务器部署"><a href="#docker在服务器部署" class="headerlink" title="docker在服务器部署"></a>docker在服务器部署</h2><h3 id="前面的文章也写过关于服务器怎么部署的"><a href="#前面的文章也写过关于服务器怎么部署的" class="headerlink" title="前面的文章也写过关于服务器怎么部署的"></a>前面的文章也写过关于服务器怎么部署的</h3><p>详见: <a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></p><h3 id="下面是一个安装docker的sh配置脚本"><a href="#下面是一个安装docker的sh配置脚本" class="headerlink" title="下面是一个安装docker的sh配置脚本"></a>下面是一个安装docker的sh配置脚本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方安装指南 Ubuntu 版本</span></span><br><span class="line"><span class="comment"># https://docs.docker.com/install/linux/docker-ce/ubuntu</span></span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 的源是 https，所以安装这些软件用于支持 https 的 apt 仓库</span></span><br><span class="line">sudo apt install -y apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG key</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置官方 Docker 源</span></span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你想验证 Docker 安装好了，可以运行一个 hello-world 容器</span></span><br><span class="line"><span class="comment"># sudo docker run hello-world</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列五</title>
      <link href="2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/"/>
      <url>2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="给docker加上数据持久"><a href="#给docker加上数据持久" class="headerlink" title="给docker加上数据持久"></a>给docker加上数据持久</h2><h3 id="数据券介绍"><a href="#数据券介绍" class="headerlink" title="数据券介绍"></a>数据券介绍</h3><p>我们可以在概念上把docker看做虚拟机,当容器被删除的时候，容器里所有数据都会被删除,两个不同容器之间无法互通<br>可以把数据卷理解为虚拟机的虚拟磁盘，他是独立于容器的文件.在容器中他被挂载为一个目录的形式.<br>对于容器中的应用来说，数据卷是透明的，无法感知它的存在，他就是一个普通的文件夹<br>由于数据卷独立于容器而存在，因此删除容器的时候数据卷也不会受影响。数据卷有以下优点:</p><ol><li>多容器可以通过挂载同一个数据卷来共享数据</li><li>数据卷可以方便地备份，存储数据</li></ol><h3 id="数据卷的相关命令操作"><a href="#数据卷的相关命令操作" class="headerlink" title="数据卷的相关命令操作"></a>数据卷的相关命令操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个volume</span></span><br><span class="line">docker volume create testvolume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个数据卷</span></span><br><span class="line">docker volume rm testvolume</span><br></pre></td></tr></table></figure><h3 id="在容器中使用数据卷"><a href="#在容器中使用数据卷" class="headerlink" title="在容器中使用数据卷"></a>在容器中使用数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建数据卷</span></span><br><span class="line">docker volume create web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在运行容器的时候，使用参数--mount 如下</span></span><br><span class="line"><span class="comment"># 下面的参数含义是把数据卷(web)挂载到容器的/volume目录上面</span></span><br><span class="line"><span class="comment"># 这里的webimage 镜像可以用我前面文章写得Dockerfile生成</span></span><br><span class="line"><span class="comment"># 这样就运行了一个带有数据卷的容器，这个容器的/volume目录中的内容在容器被删除之后仍然存在.</span></span><br><span class="line"><span class="comment"># 因为它实际上是存在Docker数据卷中。</span></span><br><span class="line">docker run -d --name demovolume --mount <span class="built_in">source</span>=web,target=/volume webimage</span><br></pre></td></tr></table></figure><h3 id="以下例子用于演示数据卷保存数据的特性"><a href="#以下例子用于演示数据卷保存数据的特性" class="headerlink" title="以下例子用于演示数据卷保存数据的特性"></a>以下例子用于演示数据卷保存数据的特性</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行命令在容器的 /b.txt 写入时间内容并查看</span></span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;date &gt; /b.txt&#x27;</span></span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;cat /b.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器后重新启动一个同名容器在查看，之前容器的内容已经没有了</span></span><br><span class="line">docker rm -f demovolume</span><br><span class="line">docker run -d --name demovolume --mount <span class="built_in">source</span>=web,target=/volume webimage</span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;cat /b.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存在数据卷上的文件，即使容器被删除仍然存在</span></span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;date &gt; /volume/b.txt&#x27;</span></span><br><span class="line">docker rm -f demovolume</span><br><span class="line">docker run -d --name demovolume --mount <span class="built_in">source</span>=web,target=/volume webimage</span><br><span class="line">docker <span class="built_in">exec</span> demovolume sh -c <span class="string">&#x27;cat /volume/b.txt&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="共享目录"><a href="#共享目录" class="headerlink" title="共享目录"></a>共享目录</h3><p>除了挂载数据卷以外，docker还可以挂载共享目录（这一点和虚拟机一样），共享目录的优势是使用方便，易于理解，可以在某些场景下方便使用<br>（比如开发是在宿主机中修改源代码docker中实时生效省却build镜像的过程）<br>下面用一个具体的例子来演示挂载共享目录的用法:</p><ol><li>在当前目录下创建index.html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>volume<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个在宿主机的 index.html 文件。<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>打开终端输入<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令会从nginx镜像运行一个名为nginx1的容器</span></span><br><span class="line"><span class="comment"># 并且设置了8080：80的端口映射</span></span><br><span class="line"><span class="comment"># --mount 参数的 type=bind 表明要挂载的共享目录</span></span><br><span class="line"><span class="comment"># 把宿主机的当前目录映射为容器的 /usr/share/nginx/html (这是nginx容器的静态页面文件存放路径)</span></span><br><span class="line"><span class="comment"># 这样在宿主机中访问localhost:8080会自动访问宿主机当前目录下的index.html文件 （这是nginx的默认静态文件首页）</span></span><br><span class="line"></span><br><span class="line">docker run -p 8080:80 --name nginx1 --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>,target=/usr/share/nginx/html/ nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要注意的是source参数必须使用绝对路径</span></span><br><span class="line"><span class="comment"># 所以这里使用&quot;$&#123;PWD&#125;&quot;的方式来在 Mac/Linux/Windows 中获取当前目录路径</span></span><br><span class="line"><span class="comment"># 这是一个可以在多平台通用的获取当前目录路径的方法 (windows下必须使用PowerShell)</span></span><br><span class="line"><span class="comment"># 加引号是因为路径中可能含有空格等特殊符号，如果路径有空格而未加引号，会产生错误</span></span><br></pre></td></tr></table></figure></li><li>打开浏览器输入: localhost:8080</li></ol><h3 id="其他挂载模式"><a href="#其他挂载模式" class="headerlink" title="其他挂载模式"></a>其他挂载模式</h3><p>除了挂载整个目录，还可以单独挂载一个文件。 如果要挂载单个文件，一定要要保证宿主机文件存在，否则整个路径会被认为是一个目录挂载</p><ol><li>创建index.html, 随便写点东西</li><li>打开终端输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8081:80 \</span><br><span class="line">    --name nginx2 \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>/index.html,target=/usr/share/nginx/html/test.html \</span><br><span class="line">    nginx</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  这时候我们访问http://localhost:8081 返回的是nginx的默认首页</span></span><br><span class="line">    <span class="comment">#  而访问http:/localhost:8081/test.html 返回的是挂载的单个文件</span></span><br></pre></td></tr></table></figure>注意：可以创建多文件挂载<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8082:80 \</span><br><span class="line">    --name nginx3 \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>/index.html,target=/usr/share/nginx/test.html/ \</span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="string">&quot;<span class="variable">$&#123;PWD&#125;</span>&quot;</span>/test.html,target=/usr/share/nginx/test2.html/ \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列四</title>
      <link href="2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/"/>
      <url>2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="使用compose部署多容器应用"><a href="#使用compose部署多容器应用" class="headerlink" title="使用compose部署多容器应用"></a>使用compose部署多容器应用</h2><h3 id="compose介绍"><a href="#compose介绍" class="headerlink" title="compose介绍"></a>compose介绍</h3><pre><code>`docker`被设计为程序容器，所以每一个容器只应该运行一个程序。但是在实际的项目中会有需要多个程序相互配合一起运行的情况。比如web程序通常包含app, 数据库，nginx，redis等。这些程序各自的容器需要协同工作，并且需要能够互相访问网络。比如app需要连接数据库，nginx需要能访问app才能给他做反向代理。由于docker容器是一个隔离的环境，正常情况下容器与容器之间是无法互相访问的。为了应对复杂工程的需要，我们可以手动配置多容器之间的虚拟网络，文件互访等功能来实现容器互相访问。但docker官方推出了compose程序用于配置管理多容器的运行。`compose`通过一个单独的`docker-compose.yml`配置文件来管理一组容器。</code></pre><h3 id="compose安装"><a href="#compose安装" class="headerlink" title="compose安装"></a>compose安装</h3><pre><code>在`docker for mac`, `docker for windows`中`docker-compose`是自带的。linux服务器上，需要单独安装，方法如下：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你应该检查如下的链接用最新的版本: https://github.com/docker/compose/releases</span></span><br><span class="line"><span class="comment"># 这是linux服务器的安装方法：</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose</span><br><span class="line"><span class="comment"># 给docker-compose 增加修改的权限</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment"># 由于官方的Compose程序在github速度比较慢，所以我们也可以用国内的地址安装</span></span><br><span class="line">curl -L https://get.doocloud.io/docker/compose/releases/download/1.22.0/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment"># 其他系统安装方法见官方指南： https://docs.docker.com/compose/install/</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="compose使用"><a href="#compose使用" class="headerlink" title="compose使用"></a>compose使用</h3><pre><code>`compose`把一组容器作为一个项目来进行管理，并且会设置好容器间互联的内部网络每一个容器在compose中被称之为服务（service). 如同docker使用dockerfile来描述一个镜像的构建一样.`compose`使用一个`docker-compose.yml`文件来描述`compose`项目的构建. 请注意，如果你对yml格式不太熟悉，那么可能需要查阅一下yml格式的相关信息. 下面是关于`compose`的相关命令操作<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line">docker-compose up</span><br><span class="line"><span class="comment"># 重新运行</span></span><br><span class="line">docker-compose up --build</span><br><span class="line"><span class="comment"># 用-d参数让项目后台运行</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用stop暂停容器的运行</span></span><br><span class="line">docker-compose stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用down关闭并且删除项目的所有容器</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目运行起来后，用ctrl+c终止项目</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="实例操作1-compose的使用"><a href="#实例操作1-compose的使用" class="headerlink" title="实例操作1: compose的使用"></a>实例操作1: compose的使用</h3><ol><li><p>在当前目录下创建compose1文件夹</p></li><li><p>进入compose1, 创建<code>app.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># redisdemo 是 compose 中创建的主机名，由 docker-compose.yml 中指定</span></span><br><span class="line"><span class="comment"># compose 会给每个容器提供 DNS 服务保证容器间互相访问</span></span><br><span class="line">redis = Redis(host=<span class="string">&#x27;redisdemo&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    count = redis.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;views &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>进入compose1, 创建Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install flask redis</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>进入compose1, 创建docker-compose.yml</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示这是 compose 配置文件的版本</span></span><br><span class="line">version: <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="comment"># 每个服务都是一个 Docker 容器</span></span><br><span class="line"><span class="comment"># 所以必须用 image 指定服务的镜像名或者从 Dockerfile 中 build 镜像</span></span><br><span class="line">services:</span><br><span class="line">    pyweb:</span><br><span class="line">    <span class="comment"># build 指定了 Dockerfile 所在的路径。docker build -t pyimage .</span></span><br><span class="line">    build: .</span><br><span class="line">    <span class="comment"># ports 指定暴露的端口，9000 是宿主机，5000 是容器</span></span><br><span class="line">    <span class="comment"># 可以指定多个暴露端口</span></span><br><span class="line">    ports:</span><br><span class="line">        - <span class="string">&quot;9000:5000&quot;</span></span><br><span class="line">    <span class="comment"># depends_on 设定了依赖，这里 redisdemo 会先于 pyweb 启动</span></span><br><span class="line">    <span class="comment"># 但是如果 redisdemo 启动时间长于 pyweb</span></span><br><span class="line">    <span class="comment"># 那么 pyweb 运行的时候 redisdemo 未必可用</span></span><br><span class="line">    depends_on:</span><br><span class="line">        - redisdemo</span><br><span class="line"></span><br><span class="line">    redisdemo:</span><br><span class="line">        <span class="comment"># 每个服务必须用 image 指定镜像名或者从 Dockerfile 中 build</span></span><br><span class="line">        <span class="comment"># 这里用 image 指定镜像，redis:alpine 是 redis 项目的官方 Docker 镜像</span></span><br><span class="line">        image: <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>启动项目,打开终端</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器输入: localhost:9000/. 不断刷新浏览器你会发现redis记录了该页面访问的次数变化。</p></li><li><p>输入<code>docker-compose down</code>关闭应用</p></li></ol><h3 id="实例操作2-使用共享券"><a href="#实例操作2-使用共享券" class="headerlink" title="实例操作2: 使用共享券"></a>实例操作2: 使用共享券</h3><p>在开发过程中，如果每次修改<code>app.py</code>文件都要重新build再启动容器会比较繁琐<br>我们可以用共享券的方式来直接修改程序文件,这样可以大大提高开发效率.<br>上面的实例操作一，每次修改compose1文件夹下的文件都需要输入<code>docker-compose up --build</code>重启启动应用。现在使用了共享券(volumes)，容器中<code>/code</code>下的文件都来自宿主机的当前目录。<br>.</p><ol><li><p>进入目录compose1, 修改docker-compose.yml文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改pyweb容器的配置</span></span><br><span class="line">pyweb:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">        - <span class="string">&quot;9000:5000&quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">        - redisdemo</span><br><span class="line">    volumes:</span><br><span class="line">        - .:/code</span><br></pre></td></tr></table></figure></li><li><p>进入目录compose1, 修改Dockerfile文件</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除 COPY 命令</span><br><span class="line"><span class="deletion">- COPY app.py /code/app.py</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>打开终端, 启动项目</p></li><li><p>打开浏览器输入: localhost:9000/. 不断刷新浏览器你会发现redis记录了该页面访问的次数变化。这时候修改<code>app.py</code>不需要重新启动容器</p></li><li><p>输入<code>docker-compose down</code>关闭应用</p></li></ol><h3 id="实例操作3-在服务器中使用docker-compose启动项目"><a href="#实例操作3-在服务器中使用docker-compose启动项目" class="headerlink" title="实例操作3: 在服务器中使用docker-compose启动项目"></a>实例操作3: 在服务器中使用docker-compose启动项目</h3><ol><li>进入compose1文件夹，创建upload-and-run.sh文件.<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传项目到服务器</span></span><br><span class="line"><span class="comment"># 比如`scp -r . root@xxxxx:/local/woyao`</span></span><br><span class="line">scp -r . &lt;username&gt;@&lt;server host&gt;:&lt;server path&gt;</span><br><span class="line"><span class="comment"># 在服务器重启项目</span></span><br><span class="line"><span class="comment"># 登录服务器</span></span><br><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line">ssh &lt;username&gt;@&lt;server host&gt; <span class="string">&#x27;sh &lt;server path&gt;/run.sh&#x27;</span></span><br></pre></td></tr></table></figure></li><li>进入compose1文件夹，创建run.sh文件.<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;server path&gt;</span><br><span class="line">sudo docker-compose down</span><br><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure></li><li>在本地执行<code>sh upload-and-run.sh</code></li><li>打开浏览器输入: <code>&lt;server ip&gt;:9000</code>，就可以访问了。</li><li>注意事项:</li></ol><ul><li>可能服务器docker服务会关闭，在服务器输入<code>systemctl start docker</code>重启docker。</li><li>服务器防火墙原因，只放开了80,443端口</li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列三</title>
      <link href="2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/"/>
      <url>2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="使用dockerfile打包镜像"><a href="#使用dockerfile打包镜像" class="headerlink" title="使用dockerfile打包镜像"></a>使用dockerfile打包镜像</h2><pre><code>上一篇文章，我们实现了在一个基础的ubuntu镜像中运行我们的程序。但是运行程序的过程手动执行行命令式一件很麻烦的事情。接下来我们又把执行的命令协程了脚本，提高了一定的效率。但是如果要启动多个容器，我们的自制脚本每次都要重新安装配置一次这个过程是很耗时的。有没有更简单的办法呢？有的下面介绍dockerfile.</code></pre><h3 id="dockerfile介绍"><a href="#dockerfile介绍" class="headerlink" title="dockerfile介绍"></a>dockerfile介绍</h3><pre><code>docker 可以让我们自行编写配置文件（名为Dockerfile）来构建一个镜像,这样我们就可以轻松地从自定义构建的镜像中启动多个容器, 所以在实际使用中，我们会把整个程序打包成一个新的docker. 也就是说把所得配置操作，启动运行操作都写到自己的自定义的镜像配置文件中，这样生成的镜像实例(容器)只管运行就好了。不需要额外配置</code></pre><h3 id="关于镜像相关的命令"><a href="#关于镜像相关的命令" class="headerlink" title="关于镜像相关的命令"></a>关于镜像相关的命令</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用下面的命令查看本机存储的镜像 (包括下载的和构建的)</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker image rm &lt;webimage&gt;</span><br><span class="line">or</span><br><span class="line">docker rmi -f &lt;webimage&gt;</span><br><span class="line"><span class="comment"># 构建镜像, -t表示镜像的名字和标签，.代表当前的工作目录</span></span><br><span class="line">docker build -t webimage .</span><br></pre></td></tr></table></figure></code></pre><h3 id="使用dockerfile构建的镜像启动容器"><a href="#使用dockerfile构建的镜像启动容器" class="headerlink" title="使用dockerfile构建的镜像启动容器"></a>使用dockerfile构建的镜像启动容器</h3><pre><code>下面是对dockerfile文件中内容的解释<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在dockerfile文件中 #是注释</span></span><br><span class="line"><span class="comment"># FROM用于指定构建镜像使用的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN 用于在构建镜像的时候在镜像中执行命令</span></span><br><span class="line"><span class="comment"># 这里我们安装python3 和 flask web 框架</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip2 insatll flask</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COPY 相当于命令的 docker cp</span></span><br><span class="line"><span class="comment"># 把本机当前目录下的app.py文件拷贝到镜像的 /code/app.py</span></span><br><span class="line"><span class="comment"># 和docker cp 不同的是， COPY 会自动创建镜像中不存在的目录, 比如/code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR 用于指定从镜像启动的容器内的工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 用于指定容器运行后要执行的命令和参数列表</span></span><br><span class="line"><span class="comment"># 这样从本镜像启动容器后会自动执行 python3 app.py 这个命令</span></span><br><span class="line"><span class="comment"># 由于我们已经用WORDKDIR指定了容器的工作目录</span></span><br><span class="line"><span class="comment"># 所以以下的命令都是在 /code 下执行的</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><ol><li>当前目录下创建app.py文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from Dockerfile&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li>当前目录下创建Dockerfile文件<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt -y install python3 python3-pip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install flask</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为使用了docker build -t webimage .</span></span><br><span class="line"><span class="comment"># 指明了镜像的工作目录是当前目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.py /code/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li>打开终端输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令中参数 -t webimage 指定了镜像的名字为 webimage</span></span><br><span class="line"><span class="comment"># 这个名字可以用于在之后从镜像启动容器</span></span><br><span class="line"><span class="comment"># 最后那个 . 用来指定构建镜像时候的工作目录为本机当前目录</span></span><br><span class="line">docker build -t webimage .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用下面的命令查看本机存储的镜像 (包括下载的和构建的)</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -p 8000:5000 --name demo webimage</span><br></pre></td></tr></table></figure></li><li>在浏览器输入: localhost:8000</li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列二</title>
      <link href="2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/"/>
      <url>2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="手动从镜像运行一个容器"><a href="#手动从镜像运行一个容器" class="headerlink" title="手动从镜像运行一个容器"></a>手动从镜像运行一个容器</h2><h3 id="手动启动一个容器"><a href="#手动启动一个容器" class="headerlink" title="手动启动一个容器"></a>手动启动一个容器</h3><pre><code>手动在本地电脑的docker容器中运行一个web应用<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令启动一个docker容器</span></span><br><span class="line">docker run -d -t -p 8000:5000 --name demo ubuntu:18.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这条命令的解释</span></span><br><span class="line">-d 的意思是让容器在后台运行</span><br><span class="line">-t 极少能用到，用于让一个空白的Ubuntu镜像在后台运行</span><br><span class="line">-p 用于指定端口映射，表示在本机访问8000会被自动转到容器中5000端口</span><br><span class="line">   必须保证本机没有其他应用程序占用了8000端口，否则这里会失败</span><br><span class="line">--name demo 制定了容器的名字是demo</span><br><span class="line">ubuntu:18.04 是启动容器时用的镜像名, docker会自动从镜像服务器去下载这个镜像</span><br></pre></td></tr></table></figure></code></pre><h3 id="启动容器常见的问题"><a href="#启动容器常见的问题" class="headerlink" title="启动容器常见的问题"></a>启动容器常见的问题</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个端口为3456的进程</span></span><br><span class="line">docker run -t -d -p 3456:5000 --name <span class="built_in">test</span> ubuntu:18.04</span><br><span class="line"><span class="comment"># 报错1，端口被占用，删除test容器来不安比3456端口的占用</span></span><br><span class="line">docker rm -f <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 报错2，名字已存在, 那么改名字, 也可以用上面的删除容器命令</span></span><br><span class="line">docker run -t -d -p 3456:5000 --name test1 ubuntu:18.04</span><br></pre></td></tr></table></figure></code></pre><h3 id="关于容器相关的命令"><a href="#关于容器相关的命令" class="headerlink" title="关于容器相关的命令"></a>关于容器相关的命令</h3><pre><code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最新指定数量的容器的状态</span></span><br><span class="line">docker ps -n 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终止容器</span></span><br><span class="line">docker stop &lt;container id&gt;/&lt;container name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对终止运行的容器重启, 容器id通过docker ps查询</span></span><br><span class="line">docker start &lt;container id&gt;/&lt;container name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器日志</span></span><br><span class="line">docker logs &lt;container id&gt;/&lt;container name</span><br></pre></td></tr></table></figure></code></pre><h3 id="在容器中安装必备软件"><a href="#在容器中安装必备软件" class="headerlink" title="在容器中安装必备软件"></a>在容器中安装必备软件</h3><pre><code>启动容器以后，说明了运行了一个镜像实例，比如ubuntu:18.04镜像生成的test容器。这个容器目前有了ubuntu操作系统的文件管理功能，内存管理功能，进程调度等功能。现在还需要拥有python3, pip 环境, apt工具包。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -t -p 8000:5000 --name unbuntu:18.04</span><br><span class="line"><span class="comment"># 下载apt工具包</span></span><br><span class="line">docker <span class="built_in">exec</span> demo apt update</span><br><span class="line">docker <span class="built_in">exec</span> apt -y install python3 python3-pip</span><br><span class="line"><span class="comment"># 安装flask库</span></span><br><span class="line">docker <span class="built_in">exec</span> demo pip3 install flask</span><br></pre></td></tr></table></figure></code></pre><h3 id="在容器中运行程序"><a href="#在容器中运行程序" class="headerlink" title="在容器中运行程序"></a>在容器中运行程序</h3><pre><code>上面说过，使用docker的目的就是软件应用带环境安装。现在环境好了，需要运行软件应用<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo 容器中创建/code目录</span></span><br><span class="line">docker <span class="built_in">exec</span> demo mkdir /code</span><br><span class="line"><span class="comment"># cp参数把当前文件夹的a.py拷贝到demo容器的/code/a.py</span></span><br><span class="line">docker cp a.py demo:/code/a.py</span><br><span class="line"><span class="comment"># 运行demo容器中的a.py</span></span><br><span class="line">docker <span class="built_in">exec</span> demo python3 /code/a.py</span><br></pre></td></tr></table></figure></code></pre><h3 id="用脚本的方式配置容器，然后运行脚本配置并开启新容器"><a href="#用脚本的方式配置容器，然后运行脚本配置并开启新容器" class="headerlink" title="用脚本的方式配置容器，然后运行脚本配置并开启新容器"></a>用脚本的方式配置容器，然后运行脚本配置并开启新容器</h3><pre><code>之前的一系列命令有些繁琐, 其实更好的方式是在宿主机写脚本，然后cp到docker容器中直接运行.具体操作看实例操作</code></pre><h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><ol><li>在当前目录下创建a.py文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from Docker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认端口5000</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li>在当前目录下创建install.sh文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install.sh</span></span><br><span class="line">apt update</span><br><span class="line">apt -y install python3 python3-pip</span><br><span class="line">pip3 install flask</span><br></pre></td></tr></table></figure></li><li>在当前目录下创建run.sh文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run.sh</span></span><br><span class="line"><span class="built_in">cd</span> /code</span><br><span class="line">python3 a.py</span><br></pre></td></tr></table></figure></li><li>打开终端，输入以下命令<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -t -p 8000:5000 --name unbuntu:18.04</span><br><span class="line"><span class="comment"># demo 容器中创建/code目录</span></span><br><span class="line">docker <span class="built_in">exec</span> demo mkdir /code</span><br><span class="line">docker cp install.sh <span class="string">&quot;demo:/code/install.sh&quot;</span></span><br><span class="line">docker cp run.sh <span class="string">&quot;demo:/code/run.sh&quot;</span></span><br><span class="line">docker cp a.py <span class="string">&quot;demo:/code/a.py&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> demo bash /code/install.sh</span><br><span class="line">docker <span class="built_in">exec</span> demo bash /code/run.sh</span><br></pre></td></tr></table></figure></li><li>打开浏览器输入：localhost:8000/</li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker教程系列一</title>
      <link href="2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/"/>
      <url>2021/04/19/docker%E7%B3%BB%E5%88%97/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%80/">docker概念</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%8C/">手动从镜像运行一个容器</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%89/">使用dockerfile打包镜像</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%9B%9B/">使用compose部署多容器应用</a></li><li><a href="https://chenwoyao.github.io/2021/04/19/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%BA%94/">给docker加上数据持久</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E5%85%AD/">docker在服务器部署</a></li><li><a href="https://chenwoyao.github.io/2021/04/20/docker%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B8%83/">docker持续集成和部署</a></li></ul><h2 id="docker概念篇"><a href="#docker概念篇" class="headerlink" title="docker概念篇"></a>docker概念篇</h2><h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>官方解释：通过对应用的封装、分发、部署、运行 生命周期进行管理，达到应用组件级别的“一次封装，到处运行”。<br>大白话：在以前一个软件应用在不同机器上运行，都需要对操作系统设置，各种库和组装单独下载，配置好环境变量。才能运行的起来。这种模式很不好，首先老旧的模块和当前环境不兼容就”gg思密达了”. 于是就有了软件应用带环境安装的解决方案。然后就出现了<code>虚拟机的方案</code>。但是虚拟机<strong>资源占用多</strong>，<strong>冗余步骤多</strong>，<strong>启动慢</strong>。既然虚拟机方案不好，那么革命的变更就出现了<code>linux容器方案</code>。关于<code>linux容器方案</code>的介绍:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux 容器不是模拟一个完整的操作系统，而是对进程(一个正在运行的应用)进行隔离。</span><br><span class="line">在正常进程的外面套了一个容器。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。另外容器也属于一个进程。</span><br></pre></td></tr></table></figure><p>具有<strong>启动快</strong>，<strong>占用资源少</strong>，<strong>体积小</strong>。docker属于<code>linux容器</code>的一种封装。是目前最流行的<code>linux容器方案</code>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="centOs系统"><a href="#centOs系统" class="headerlink" title="centOs系统:"></a>centOs系统:</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 添加docker稳定版本的yum软件源</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">// 安装docker</span><br><span class="line">sudo yum install -y docker-ce</span><br><span class="line"></span><br><span class="line">// 确定docker服务启动正常</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h4 id="macOs系统"><a href="#macOs系统" class="headerlink" title="macOs系统:"></a>macOs系统:</h4><p><a href="https://www.runoob.com/docker/macos-docker-install.html">参考macos系统docker的安装</a></p><h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p><a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac">docker安装官网</a></p><h3 id="docker镜像-docker-image"><a href="#docker镜像-docker-image" class="headerlink" title="docker镜像(docker image)"></a>docker镜像(docker image)</h3><p>Docker把应用程序及其依赖，打包在image文件里面。docker image 一个只读的模板, 创建Docker容器的基础。镜像相当于光盘，光盘里存储的数据是只读的，不会被更改</p><h3 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h3><p>容器是从镜像创建的应用运行实例, 一个镜像可以生成多个容器，每个容器之间，容器与宿主机之间都是相互隔离的，容器可以快速方便的运行，也可以方便的删除</p><h3 id="docker的优势"><a href="#docker的优势" class="headerlink" title="docker的优势"></a>docker的优势</h3><ol><li><p>同一环境，标准化部署 ubntu centos 等服务器的安装运行环境是不一样的<br>要使用某些新版的软件需要自行编译，非常繁琐</p></li><li><p>解决复杂的依赖问题<br>比如两个微服务 2个不同的依赖互相冲突</p></li><li><p>隔离应用的运行环境<br>比如redis获取服务器权限的漏洞</p></li><li><p>轻量级的虚拟环境，相比虚拟机而言开销小速度快</p></li><li><p>统一的服务管理<br> 不同的服务有不同的管理工具和方式<br> 如果使用了docker则统一用docker管理</p></li><li><p>dockerhub 上有许多高价值的镜像可以直接使用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react的hooks教程</title>
      <link href="2021/04/16/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/react%E7%B3%BB%E5%88%97/react%E7%9A%84hooks%E6%95%99%E7%A8%8B/"/>
      <url>2021/04/16/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/react%E7%B3%BB%E5%88%97/react%E7%9A%84hooks%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="这是一篇react的hooks教程"><a href="#这是一篇react的hooks教程" class="headerlink" title="这是一篇react的hooks教程"></a>这是一篇react的hooks教程</h2><p>另外欢迎大家访问<a href="https://chenwoyao.github.io/categories/">我的博客</a></p><h2 id="react-hooks-与-class-Component-的区别"><a href="#react-hooks-与-class-Component-的区别" class="headerlink" title="react hooks 与 class Component 的区别"></a><code>react hooks</code> 与 <code>class Component</code> 的区别</h2><ul><li>写法更加简洁，不再需要写冗长的生命周期函数</li><li><code>class Componet hoc</code> 的阅读让人看起来不易理解, 在组件之间复用状态逻辑很难.</li></ul><h2 id="hooks-使用规则"><a href="#hooks-使用规则" class="headerlink" title="hooks 使用规则"></a><code>hooks</code> 使用规则</h2><ul><li>只能在<strong>函数最外层</strong>调用 Hook。不要在循环、条件判断或者子函数中调用。</li><li>只能在<strong>React的函数组件中调用</strong>Hook。不要在其他JavaScript函数中调用。除了自定义的hook以外</li></ul><h2 id="react-hooks-常见的api使用"><a href="#react-hooks-常见的api使用" class="headerlink" title="react hooks 常见的api使用"></a><code>react hooks</code> 常见的api使用</h2><h3 id="useState-用法"><a href="#useState-用法" class="headerlink" title="useState 用法"></a><code>useState</code> 用法</h3><blockquote><p>identity: <code>const [state, setState] = useState(initialState)</code></p></blockquote><p><code>useState</code>的作用是在react函数组件中添加state的hook。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line">function Count() &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - count &lt;&#x3D;&gt; this.state.count, setCount &lt;&#x3D;&gt; this.setState</span><br><span class="line">        - setCount 支持两种写法 setCount(count + 1) or setCount(preState &#x3D;&gt; preState + 1)</span><br><span class="line">        第一种写法是一种异步机制，会将短时间内的多个setCount合并成一个方法，第二种写法是为了不使用第一种的合并机制。</span><br><span class="line">    *&#x2F;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    return &lt;div onClick&#x3D;&#123;setCount(pre &#x3D;&gt; pre + 1)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useEffect-用法"><a href="#useEffect-用法" class="headerlink" title="useEffect 用法"></a><code>useEffect</code> 用法</h3><blockquote><p>identity: <code>useEffect(callBack:clearCallBack, [deps])</code></p></blockquote><p><code>useEffect</code>的作用是在函数组件中执行副作用操作, 等价于在ComponetDidMount，ComponentDidUpdate, ComponentWillUnmount 三个函数的组合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - useEffect接受一个callBack参数和数组参数</span><br><span class="line">        - 数组中的值作为依赖，数组中的值发生变化的时候，callBack会重新调用。等价于ComponentDidUpdate</span><br><span class="line">        - callBack可以return一个clearCallBack,在组件卸载的时候调用clearCallBack。等价于ComponentWillUnmount</span><br><span class="line">        - useEffect默认会在render流程执行完以后，在调用callBack。等价于ComponetDidMount</span><br><span class="line">    *&#x2F;</span><br><span class="line">    const [isonline, setIsOnline] &#x3D; useState(false);</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [isonline])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useContext-用法"><a href="#useContext-用法" class="headerlink" title="useContext 用法"></a><code>useContext</code> 用法</h3><p><code>useContext</code>的作用是接受一个context对象，并返回该context的当前值。主要用于深层级的组件通讯。需要和React.createContext配合使用<br>context的值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt;的 value prop决定。另外value的值更新会引起调用了uesContext的组件重新渲染。</p><blockquote><p>注意调用useContext的组件即使用了React.memo进行声明，也会重新渲染。因此需要使用<a href="https://github.com/facebook/react/issues/15156">memoization</a>来进行优化.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; createContext, Children, useContext, useMemo &#125; from &#39;react&#39;</span><br><span class="line">const GlobalContext &#x3D; React.createContext()</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">    const data &#x3D; useContext(GlobalContext)</span><br><span class="line">    &#x2F;&#x2F; memoization 写法</span><br><span class="line">    return useMemo(() &#x3D;&gt; &#123;</span><br><span class="line">        return &lt;div&gt;&#123;data.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;, [data.name])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Parent() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;Parent&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;GlobalContext.Provider value&#x3D;&#123;&#123;name: &#39;woyao&#39;&#125;&#125;&gt;</span><br><span class="line">                &lt;Child &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;GlobalContext.Provider&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="useRef-用法"><a href="#useRef-用法" class="headerlink" title="useRef 用法"></a><code>useRef</code> 用法</h3><p><code>useRef</code>返回一个可变的ref对象，<code>ref.current</code>在组件内是一个全局常量。相当于在组件外写了一个全局常量。也就是说每次重新渲染函数组件时，返回的ref对象都是同一个。 常用于<em>访问Dom</em>,<em>当做全局变量</em>。</p><blockquote><p><em>访问 Dom</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef &#125; from &#39;react&#39;</span><br><span class="line">function Example() &#123;</span><br><span class="line">    const inputElement &#x3D; useRef(null)</span><br><span class="line">    const btnClick &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class="line">        inputElement.current.focus()</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &lt;input ref&#x3D;&#123;inputElement&#125; &#x2F;&gt;</span><br><span class="line">            &lt;button ref&#x3D;&#123;btn&#125; onClick&#x3D;&#123;btnClick&#125;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><em>当做全局变量</em></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef, useEffect, useState &#125; from &#39;react&#39;</span><br><span class="line">function usePrevious(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 每次重新渲染，都会执行useRef,</span><br><span class="line">    const ref &#x3D; useRef()</span><br><span class="line">    &#x2F;*</span><br><span class="line">        - 不设置依赖，每次reRender都会重新执行</span><br><span class="line">        - 能够返回上一次渲染之前value是什么值</span><br><span class="line">        - 注意是先执行return, 在执行useEffect</span><br><span class="line">    *&#x2F;</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        ref.current &#x3D; value</span><br><span class="line">    &#125;)</span><br><span class="line">    return ref.current</span><br><span class="line">&#125;</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [count, setCount] &#x3D; useState(0)</span><br><span class="line">    const preCount &#x3D; usePrevious(count)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;previous: &#123;preCount&#125; &lt;&#x2F;p&gt;</span><br><span class="line">            &lt;p&gt;now: &#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useImperativeHandle-用法"><a href="#useImperativeHandle-用法" class="headerlink" title="useImperativeHandle 用法"></a><code>useImperativeHandle</code> 用法</h3><blockquote><p>identity: <code>useImperativeHandle(ref, createHandle, [deps])</code></p></blockquote><p><code>useImperativeHandle</code>可以让你在使用<code>ref</code>时自定义暴露给父组件的实例值, 与<code>forwardRef</code>一起使用. 让你能够父组件调用子组件的方法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useRef, useImperativeHandle, forwardRef &#125; from &#39;react&#39;</span><br><span class="line">function MyInput(props, ref) &#123;</span><br><span class="line">    const inputRef &#x3D; useRef()</span><br><span class="line">    const childFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;hh&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        ref: ref实例</span><br><span class="line">        createHandle: 给ref实例绑上方法</span><br><span class="line">        [dps]: 当deps发生变化的时候, createHandle 重新执行</span><br><span class="line">    *&#x2F;</span><br><span class="line">    useImperativeHandle(ref, () &#x3D;&gt; (&#123;</span><br><span class="line">        focus: () &#x3D;&gt; &#123;</span><br><span class="line">            inputRef.current.focus()</span><br><span class="line">        &#125;,</span><br><span class="line">        childFunc</span><br><span class="line">    &#125;))</span><br><span class="line">    return &lt;input ref&#x3D;&#123;inputRef&#125; &#x2F;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    MyInput &#x3D; forwardRef(MyInput)</span><br><span class="line"></span><br><span class="line">    function App() &#123;</span><br><span class="line">        const myInputCoponent &#x3D; useRef()</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;MyInput ref&#x3D;&#123;myInputCoponent&#125; &#x2F;&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;() &#x3D;&gt; &#123; myInputCoponent.current.childFunc() &#125;&#125;&gt; focus now &lt;&#x2F;button&gt;</span><br><span class="line">            &lt;&#x2F;&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="useReducer-用法"><a href="#useReducer-用法" class="headerlink" title="useReducer 用法"></a><code>useReducer</code> 用法</h3><blockquote><p>identity: <code>const [state, dispatch] = useReducer(reducer, initialArg, init)</code></p></blockquote><p><code>useReducer</code>是useState的替代方案，接受一个形如(state, action) =&gt; newState 的 reducer, 并返回<br>当前的state以及其配套的dispatch方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const initialState &#x3D; &#123;count: 0&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;increment&#39;:</span><br><span class="line">            return &#123;count: state.count + 1&#125;;</span><br><span class="line">        case &#39;decrement&#39;:</span><br><span class="line">            return &#123;count: state.count - 1&#125;;</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, initialState);</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            Count: &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useMemo-用法"><a href="#useMemo-用法" class="headerlink" title="useMemo 用法"></a><code>useMemo</code> 用法</h3><blockquote><p>identity: <code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b])</code><br>newRenderTemplate = useMemo(() =&gt; renderTemplate(), [deps])</p></blockquote><p><code>useMemo</code>是减少组件渲染次数，优化组件性能的hook, 传入<code>useMemo</code>的函数会在渲染期间执行，请不要再函数<br>内部执行与渲染无关的操作，其实也就是只有依赖项发生变化才会生成新的memoizedValue。这样就减少了不必要的<br>渲染。一般用在组件中进行解耦操作，与这个逻辑渲染相关的逻辑发生变化就重新渲染，而不相关的就不会重新渲染。<br>大白话就是有一个count逻辑相关的渲染，还有一个和name相关的逻辑渲染。不要因为name的state属性变化导致<br>count的渲染函数也重新执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useMemo &#125; from &#39;react&#39;</span><br><span class="line">const log &#x3D; console.log.bind(console)</span><br><span class="line"></span><br><span class="line">function Child(props) &#123;</span><br><span class="line">    log(&#39;child render&#39;)</span><br><span class="line">    const [count, SetCount] &#x3D; useState(0)</span><br><span class="line">    const renderCountTemplate &#x3D; (count) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;count render&#39;)</span><br><span class="line">        return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            child, &#123;props.name&#125;</span><br><span class="line">            &#123;&#x2F;*</span><br><span class="line">                - 使用useMemo防止了不必要的渲染更新，不会因为与当前父组件的props发生变化就会重新对renderCountTemplate进行执行。</span><br><span class="line">            *&#x2F;&#125;</span><br><span class="line">            &#123; useMemo(() &#x3D;&gt; renderCountTemplate(count), [count])&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Child组件优化：组件内 prop，state 的值发生变化才会重新渲染。防止了父组件的更新，子组件也进行不必要的更新</span><br><span class="line">Child &#x3D; React.memo(Child)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">    log(&#39;parent render&#39;)</span><br><span class="line">    const [name, SetName] &#x3D; useState(&#39;&#39;)</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;parent, &#123;name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;input onChange&#x3D;&#123;(event) &#x3D;&gt; SetName(event.target.value)&#125; &#x2F;&gt;</span><br><span class="line">            &lt;Child name&#x3D;&#123;name&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useCallback-用法"><a href="#useCallback-用法" class="headerlink" title="useCallback 用法"></a><code>useCallback</code> 用法</h3><blockquote><p>identity: <code>const memoizedCallback = useCallback(() =&gt; &#123; doSomething(a, b); &#125;, [a, b]);</code></p></blockquote><p><code>useCallback</code>是减少组件渲染次数，优化组件性能的hook, 与<code>useMemo</code>类似。回调函数仅在某个依赖项改变时才会更新<br>常用在对事件函数中匿名函数的处理。当然能用到useMemo的地方，useCallback也可以用到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useCallback, useState &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">const [ count, setCount ] &#x3D; useState(0)</span><br><span class="line">function Counter() &#123;</span><br><span class="line">    &lt;!--</span><br><span class="line">        - 防止了每次count发生变化，导致的重新渲染，都需要重新生成一个新的匿名函数</span><br><span class="line">        - 也就是说 () &#x3D;&gt; &#123;setCount(count + 1)&#125; 这个匿名函数不需要再从新的内存空间中创建</span><br><span class="line">     --&gt;</span><br><span class="line">    return &lt;div onClick&#x3D;&#123;useCallback(() &#x3D;&gt; setCount(count+1), [])&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useLayoutEffect-用法"><a href="#useLayoutEffect-用法" class="headerlink" title="useLayoutEffect 用法"></a><code>useLayoutEffect</code> 用法</h3><p><code>useLayoutEffect</code> 官方解释说它会在所有的DOM变更之后同步调用effect，可能<code>useEffect</code>是在所有的DOM变更之后异步调用effect吧.</p><ul><li>可以使用它来读取 DOM 布局并同步触发重渲染</li><li>在浏览器执行绘制之前，<code>useLayoutEffect</code>内部的更新计划将被同步刷新。</li><li>这么说吧，我也不太<code>useLayoutEffect</code>的区别。有下面一段代码可以参考一下。估计在使用<code>useEffect</code>的时候带来了页面的抖动问题的时候就使用<code>useLayoutEffect</code>。网上的解释:layout会在组件树构建完毕或者刷新完毕后同步立刻执行。effect会等其他js代码执行完毕后执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (count &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      const randomNum &#x3D; 10 + Math.random()*200</span><br><span class="line">      setCount(10 + Math.random()*200);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>效果如下:<br><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0dcc15419be9?imageslim" alt="结果"></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (count &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      const randomNum &#x3D; 10 + Math.random()*200</span><br><span class="line">      setCount(10 + Math.random()*200);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>效果如下:<br><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ec0dca05c0fa6e?imageslim" alt="结果"></p></blockquote></li></ul><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><p>其实也就是hook mixin, 公共的方法逻辑可以写成自定义hooks</p><ul><li><a href="#useDidUpdate">useDidUpdate</a></li><li><a href="#useGlobalReduxHook">useGlobalReduxHook</a></li></ul><div id="useDidUpdate"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个ComponentDidUpdate的简易实现</span><br><span class="line">import &#123; useEffect, useRef &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">function useDidUpdate(cb, deps&#x3D;[]) &#123;</span><br><span class="line">  const didMount &#x3D; useRef(false)</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    if (!didMount.current) &#123;</span><br><span class="line">      didMount.current &#x3D; true</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, deps)</span><br><span class="line"></span><br><span class="line">  return didMount.current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="useGlobalReduxHook"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个redux的简易实现</span><br><span class="line">import React, &#123; useContext, useReducer &#125; from &#39;react&#39;</span><br><span class="line">const initState &#x3D; &#123; count: 0 &#125;</span><br><span class="line">const Store &#x3D; React.createContext(initStore)</span><br><span class="line">const MapActionReducer &#x3D; &#123;</span><br><span class="line">    [&#39;ADD&#39;](state, action) &#123;</span><br><span class="line">        return &#123;...state, count: action.payload&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const reducer &#x3D; (initState, action) &#x3D;&gt; &#123;</span><br><span class="line">    return MapActionReducer[action.type](initState, action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function useGlobalReduxHook(Component) &#123;</span><br><span class="line">    &#x2F;&#x2F; dispatch触发state发生变化，会重新执行渲染</span><br><span class="line">    const [state, dispatch] &#x3D; useReducer(reducer, Store)</span><br><span class="line">    return (</span><br><span class="line">        &lt;Store.Provider value&#x3D;&#123;state, dispatch&#125; &#x2F;&gt;</span><br><span class="line">            &lt;Component &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;Store.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法教程</title>
      <link href="2021/04/14/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/"/>
      <url>2021/04/14/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="这是一篇markdwon语法教程"><a href="#这是一篇markdwon语法教程" class="headerlink" title="这是一篇markdwon语法教程"></a>这是一篇markdwon语法教程</h1><p>另外欢迎大家访问<a href="https://chenwoyao.github.io/categories/">我的博客</a></p><h1 id="关于markdown"><a href="#关于markdown" class="headerlink" title="关于markdown"></a>关于markdown</h1><p>markdown 是一种文本，类似于html， 比起html文本，语法标签更少，很容易上手写作</p><h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 标题1</span></span><br><span class="line"><span class="section">## 标题2</span></span><br><span class="line"><span class="section">### 标题3</span></span><br><span class="line"><span class="section">#### 标题4</span></span><br><span class="line"><span class="section">##### 标题5</span></span><br><span class="line"><span class="section">###### 标题6</span></span><br><span class="line">快捷键: h1 + tap</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">有序列表:</span><br><span class="line"><span class="bullet">1.</span> list1</span><br><span class="line"><span class="bullet">2.</span> list2</span><br><span class="line"></span><br><span class="line">无序列表:</span><br><span class="line"><span class="bullet">-</span> list1</span><br><span class="line"><span class="bullet">*</span> list2</span><br><span class="line"><span class="bullet">    -</span> list3</span><br><span class="line"><span class="bullet">    -</span> list4</span><br><span class="line"></span><br><span class="line">任务列表：</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成任务1</span><br><span class="line"><span class="bullet">-</span> [x] 已完成任务1</span><br><span class="line"></span><br><span class="line">引用列表:</span><br><span class="line"><span class="quote">&gt; ref1</span></span><br><span class="line"><span class="quote">&gt; ref2</span></span><br></pre></td></tr></table></figure><h2 id="文字样式语法"><a href="#文字样式语法" class="headerlink" title="文字样式语法"></a>文字样式语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**加粗** [快捷键：Ctrl+B]</span><br><span class="line">__加粗2__</span><br><span class="line"></span><br><span class="line">_倾斜_</span><br><span class="line">*倾斜*</span><br><span class="line"></span><br><span class="line">~~删除线~~</span><br><span class="line">&#x3D;&#x3D;高亮&#x3D;&#x3D;</span><br><span class="line">&lt;u&gt;下划线&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure><h2 id="图片显示或者链接显示"><a href="#图片显示或者链接显示" class="headerlink" title="图片显示或者链接显示"></a>图片显示或者链接显示</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">链接语法：</span><br><span class="line">[<span class="string">我的github</span>](<span class="link">https://github.com/ChenWoyao</span>)</span><br><span class="line"></span><br><span class="line">图片语法：</span><br><span class="line">![<span class="string">alt帅哥</span>](<span class="link">./static/img/bg.png</span>)</span><br></pre></td></tr></table></figure><h2 id="表格语法"><a href="#表格语法" class="headerlink" title="表格语法"></a>表格语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|th1|th2|th3|</span><br><span class="line">|--|--|--|</span><br><span class="line">|td1|td2|td3|</span><br><span class="line">|td1|td2|   td3|</span><br></pre></td></tr></table></figure><h2 id="代码块语法"><a href="#代码块语法" class="headerlink" title="代码块语法"></a>代码块语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">表示一个代码片段：</span><br><span class="line"><span class="code">`from urllib import parse`</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span>from urllib import parse<span class="xml"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">表示一段代码块：(diff, js, php, sh 等语法都支持)</span><br><span class="line"><span class="code">``` js</span></span><br><span class="line"><span class="code">    data = &#123;</span></span><br><span class="line"><span class="code">        &#x27;a&#x27;: &#x27;test&#x27;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">` ``</span></span><br><span class="line"><span class="code">&lt;pre&gt;</span></span><br><span class="line"><span class="code">    data = &#123;</span></span><br><span class="line"><span class="code">        &#x27;a&#x27;: &#x27;test&#x27;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&lt;/pre&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释--&gt;</span><br><span class="line">快捷键: cmd + /</span><br></pre></td></tr></table></figure><h2 id="目录与锚点"><a href="#目录与锚点" class="headerlink" title="目录与锚点"></a>目录与锚点</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">展示目录树的写法：</span><br><span class="line">├── [<span class="string">README.md</span>](<span class="link">#readme</span>)</span><br><span class="line">├── [<span class="string">build</span>](<span class="link">#build</span>)</span><br><span class="line">│ ├── [<span class="string">webpack.base.js</span>](<span class="link">#webpack-base</span>)</span><br><span class="line">│ ├── [<span class="string">webpack.client.js</span>](<span class="link">#webpack-client</span>)</span><br><span class="line">│ └── [<span class="string">webpack.server.js</span>](<span class="link">#webpack-server</span>)</span><br><span class="line">├── [<span class="string">package-lock.json</span>](<span class="link">#package-lock</span>)</span><br><span class="line">├── [<span class="string">package.json</span>](<span class="link">#package.json</span>)</span><br><span class="line">└── [<span class="string">src</span>](<span class="link">#src</span>)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [<span class="string">README.md</span>](<span class="link">#readme</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">build</span>](<span class="link">#build</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.base.js</span>](<span class="link">#webpack-base</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.client.js</span>](<span class="link">#webpack-client</span>)</span><br><span class="line"><span class="bullet">    -</span> [<span class="string">webpack.server.js</span>](<span class="link">#webpack-server</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">package-lock.json</span>](<span class="link">#package-lock</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">package.json</span>](<span class="link">#package.json</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">src</span>](<span class="link">#src</span>)</span><br><span class="line"></span><br><span class="line">对应的锚点dom:</span><br><span class="line"><span class="section">## readme</span></span><br><span class="line"><span class="section">## build</span></span><br><span class="line"><span class="section">### webpack-base</span></span><br><span class="line"><span class="section">### webpack-client</span></span><br><span class="line"><span class="section">### webpack-server</span></span><br><span class="line"><span class="section">## ackage-lock</span></span><br><span class="line"><span class="section">## package.json</span></span><br><span class="line"><span class="section">## src</span></span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;readme&quot;</span>&gt;</span></span> readme <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span> build <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">------------- 【快捷键：hr后敲Tab】</span><br><span class="line">*************</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\sum<span class="emphasis">_&#123;i=1&#125;^n a_</span>i=0$$</span><br><span class="line"></span><br><span class="line">$$f(x<span class="emphasis">_1,x_</span>x,\ldots,x<span class="emphasis">_n) = x_</span>1^2 + x<span class="emphasis">_2^2 + \cdots + x_</span>n^2$$</span><br><span class="line"></span><br><span class="line">$$\sum^&#123;j-1&#125;<span class="emphasis">_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_</span>&#123;kj&#125; z<span class="emphasis">_k&#125;$$</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> markdown语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
